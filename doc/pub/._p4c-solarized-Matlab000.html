<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Programming for Computations - A Gentle Introduction to Numerical Simulations with MATLAB/Octave">
<meta name="keywords" content="computer program,programming,language programming,language computer,MATLAB,Octave,Fortran,C,C++,Python,Maple,Mathematica,syntax,bug,debugging,script (and scripting),implement,print,program run,program execute,code,comment,instruction,program statement,variable,assignment,semi-colon (easy print),calculator,text editor,Idle,prompt,program typing,program run,program execute,ipython,m-file,function,function call,atan,function input parameter,function output parameter,function return,function take a parameter,library,library function,from,import,math,module,package,linspace,xlabel,ylabel,plot,interactive use (of Matlab),import,keyboard arrow up/down,operator Arithmetic,parentheses,variable type,variable name,float,integer,string,type conversion,reserved words,variable integer,variable float,variable string,variable assignment,default,single (precision),double (precision),printing formatted,printf formatting,default,array,array element,zeros,allocate,array index,indexing zero based,indexing one based,Matlab one-based indexing,array slice of,graph,hold (on/off),plot figure,title,legend,axis,hardcopy,format png,matrix mat,matrix vector product,transpose,linear algebra,matrix,vector,error message,debugging,debugger,try-exception,exception handling,program crash,program testing,program verification,program input,program output,input,raw input,list,tuple,symbolic computations,symbolic operations,symbolic simplifications,Symbolic Toolbox,WolframAlpha,Mathematica,Sage (symbolic package),Python documentation,garbage collection,variable delete,if,elif,else,colon,indent,boolean,boolean expression,True,False,boolean True,boolean False,pseudo code,operator Logical,function,function definition,def,return,argument,parameter input,parameter output,function nargin,function nargout,variable local,variable global,doc string,function handle,function local,function global,function nested,loop for,for loop,range,loop iteration,loop index,loop double,loop multiple,loop nested,linear algebra,while loop,loop while,loop infinite,loop iteration,loop index,array sorting,Leibniz pi,Euler pi,programming game,linear interpolation,least squares method,Fourier series,integral analytically,integral exact,integral approximately,integration points,code re-use,unit tests,complex domains,Monte Carlo integration,seed (random generators),scheme,finite difference method,forward difference approximation,Forward Euler scheme,logistic model,carrying capacity,SIR model,scalar ODE,ODE scalar,vector ODE,ODE vector,system of ODEs,Heun's method,Runge-Kutta, 2nd-order method,2nd-order Runge-Kutta method,RK2,PDE,heat equation,diffusion equation,MOL forward Euler,method of lines,MOL,mesh points,cell,method of lines,unstable solutions,instability,stability criterion,Poisson equation,Laplace equation,root finding,code robust,code try-except,code exception,Newton starting value,return None,sys.exit">

<title>Programming for Computations - A Gentle Introduction to Numerical Simulations with MATLAB/Octave</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Let pre tags for code blocks have the same color as the surroundings */
pre { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u' Preface ', 0, None, '___sec0'),
              (u' Why learn programming? ', 3, None, '___sec1'),
              (u' Target audience and background knowledge ',
               3,
               None,
               '___sec2'),
              (u' Numerical methods ', 3, None, '___sec3'),
              (u' The computer language: Matlab ', 3, None, '___sec4'),
              (u' How this book is different ', 3, None, '___sec5'),
              (u' Acknowledgments ', 3, None, '___sec6'),
              (u' The first few steps ',
               0,
               u'1st:TheFirstFewSteps',
               u'1st:TheFirstFewSteps'),
              (u' What is a program? And what is programming? ',
               1,
               None,
               '___sec8'),
              (u' A Matlab program with variables ',
               1,
               u'1st:ex1',
               u'1st:ex1'),
              (u' The program ', 2, None, '___sec10'),
              (u' Dissection of the program ', 2, None, '___sec11'),
              (u' Why not just use a pocket calculator? ',
               2,
               None,
               '___sec12'),
              (u' The importance of using a text editor to write programs ',
               2,
               None,
               '___sec13'),
              (u' Write and run your first program ', 2, None, '___sec14'),
              (u' Write and run a program in Matlab ', 3, None, '___sec15'),
              (u' Write a program in a text editor and run it in Octave ',
               3,
               None,
               '___sec16'),
              (u'  A Matlab program with a library function ',
               1,
               u'1st:ex2',
               u'1st:ex2'),
              (u' A Matlab program with vectorization and plotting ',
               1,
               u'1st:ex3',
               u'1st:ex3'),
              (u' More basic concepts ', 1, None, '___sec19'),
              (u' Using Matlab interactively ', 2, None, '___sec20'),
              (u' Arithmetics, parentheses and round-off errors ',
               2,
               None,
               '___sec21'),
              (u' Variables ', 2, None, '___sec22'),
              (u' Formatting text and numbers ', 2, None, '___sec23'),
              (u' Arrays ', 2, None, '___sec24'),
              (u' Plotting ', 2, None, '___sec25'),
              (u' Error messages and warnings ', 2, None, '___sec26'),
              (u' Input data ', 2, None, '___sec27'),
              (u' Symbolic computations ', 2, None, '___sec28'),
              (u' Concluding remarks ', 2, None, '___sec29'),
              (u' Exercises ', 1, None, '___sec30'),
              (u' Exercise 1: Error messages ',
               2,
               u'1st:exer:ErrorMessages',
               u'1st:exer:ErrorMessages'),
              (u' Exercise 2: Volume of a cube ',
               2,
               u'1st:exer:cubeVolume',
               u'1st:exer:cubeVolume'),
              (u' Exercise 3: Area and circumference of a circle ',
               2,
               u'1st:exer:areaCircle',
               u'1st:exer:areaCircle'),
              (u' Exercise 4: Volumes of three cubes ',
               2,
               u'1st:exer:volumes3cubes',
               u'1st:exer:volumes3cubes'),
              (u' Exercise 5: Average of integers ',
               2,
               u'1st:exer:averageOf5Integers',
               u'1st:exer:averageOf5Integers'),
              (u' Exercise 6: Interactive computing of volume and area ',
               2,
               u'1st:exer:cubeVolInteractively',
               u'1st:exer:cubeVolInteractively'),
              (u' Exercise 7: Update variable at command prompt ',
               2,
               u'1st:exer:updateVarInteractively',
               u'1st:exer:updateVarInteractively'),
              (u' Exercise 8: Formatted print to screen ',
               2,
               u'1st:exer:printfScreen',
               u'1st:exer:printfScreen'),
              (u' Exercise 9: Matlab documentation and random numbers ',
               2,
               u'1st:exer:PythonDocRandom',
               u'1st:exer:PythonDocRandom'),
              (u' Basic constructions ',
               0,
               u'2nd:BasicConstructins',
               u'2nd:BasicConstructins'),
              (u' If tests, colon and indentation ', 1, None, '___sec41'),
              (u' Functions ', 1, u'sec:functions', u'sec:functions'),
              (u' For loops ', 1, u'sec:for:loops', u'sec:for:loops'),
              (u' While loops ', 1, u'sec:while:loops', u'sec:while:loops'),
              (u' Reading from and writing to files ',
               1,
               u'sec:file:reading:writing',
               u'sec:file:reading:writing'),
              (u' Exercises ', 1, None, '___sec46'),
              (u' Exercise 10: Introducing errors ',
               2,
               u'2nd:exer:IntroducingErrors',
               u'2nd:exer:IntroducingErrors'),
              (u' Exercise 11: Compare integers a and b ',
               2,
               u'2nd:exer:compInt',
               u'2nd:exer:compInt'),
              (u' Exercise 12: Functions for circumference and area of a circle ',
               2,
               u'2nd:exer:funcCircArea',
               u'2nd:exer:funcCircArea'),
              (u' Exercise 13: Function for area of a rectangle ',
               2,
               u'2nd:exer:funcAreaRectangle',
               u'2nd:exer:funcAreaRectangle'),
              (u' Exercise 14: Area of a polygon ',
               2,
               u'2nd:exer:area:polygon',
               u'2nd:exer:area:polygon'),
              (u' Exercise 15: Average of integers ',
               2,
               u'2nd:exer:avNInt',
               u'2nd:exer:avNInt'),
              (u' Exercise 16: While loop with errors ',
               2,
               u'2nd:exer:whileLoopErrors',
               u'2nd:exer:whileLoopErrors'),
              (u' Exercise 17: Area of rectangle versus circle ',
               2,
               u'2nd:exer:areaRectCircle',
               u'2nd:exer:areaRectCircle'),
              (u' Exercise 18: Find crossing points of two graphs ',
               2,
               u'2nd:exer:Cross2Graphs',
               u'2nd:exer:Cross2Graphs'),
              (u' Exercise 19: Sort array with numbers ',
               2,
               u'2nd:exer:sortNumbers',
               u'2nd:exer:sortNumbers'),
              (u' Exercise 20: Compute $\\pi$ ',
               2,
               u'2nd:exer:computingPi',
               u'2nd:exer:computingPi'),
              (u' Exercise 21: Compute combinations of sets ',
               2,
               u'2nd:exer:combinatorics1',
               u'2nd:exer:combinatorics1'),
              (u' Exercise 22: Frequency of random numbers ',
               2,
               u'2nd:exer:numberOccurrence',
               u'2nd:exer:numberOccurrence'),
              (u' Remarks ', 3, None, '___sec60'),
              (u' Exercise 23: Game 21 ',
               2,
               u'2nd:exer:Game21',
               u'2nd:exer:Game21'),
              (u' Exercise 24: Linear interpolation ',
               2,
               u'2nd:exer:linearInterpol',
               u'2nd:exer:linearInterpol'),
              (u' Exercise 25: Test straight line requirement ',
               2,
               u'2nd:exer:testStraightLine',
               u'2nd:exer:testStraightLine'),
              (u' Exercise 26: Fit straight line to data ',
               2,
               u'2nd:exer:fitLine',
               u'2nd:exer:fitLine'),
              (u' Remarks ', 3, None, '___sec65'),
              (u' Exercise 27: Fit sines to straight line ',
               2,
               u'2nd:exer:fitSines',
               u'2nd:exer:fitSines'),
              (u' Remarks ', 3, None, '___sec67'),
              (u' Exercise 28: Count occurrences of a string in a string ',
               2,
               u'2nd:exer:countTextString',
               u'2nd:exer:countTextString'),
              (u' Computing integrals ',
               0,
               u'sec:integrals',
               u'sec:integrals'),
              (u' Basic ideas of numerical integration ',
               1,
               u'sec:integrals:basic',
               u'sec:integrals:basic'),
              (u' Computational example ', 3, None, '___sec71'),
              (u' The composite trapezoidal rule ',
               1,
               u'sec:integrals:trap',
               u'sec:integrals:trap'),
              (u' The general formula ',
               2,
               u'sec:integrals:formula',
               u'sec:integrals:formula'),
              (u' Implementation ',
               2,
               u'sec:integrals:trap:impl',
               u'sec:integrals:trap:impl'),
              (u' Specific or general implementation? ', 3, None, '___sec75'),
              (u' Implementation with functions ', 3, None, '___sec76'),
              (u' Solving our specific problem in a session ',
               3,
               None,
               '___sec77'),
              (u' Solving our specific problem in a program ',
               3,
               None,
               '___sec78'),
              (u' Alternative flat special-purpose implementation ',
               2,
               None,
               '___sec79'),
              (u' The composite midpoint method ',
               1,
               u'sec:integrals:Midpoint',
               u'sec:integrals:Midpoint'),
              (u' The idea ', 3, None, '___sec81'),
              (u' The general formula ', 2, None, '___sec82'),
              (u' Implementation ',
               2,
               u'sec:midpoint:code',
               u'sec:midpoint:code'),
              (u' Comparing the trapezoidal and the midpoint methods ',
               2,
               None,
               '___sec84'),
              (u' Testing ', 1, None, '___sec85'),
              (u' Problems with brief testing procedures ',
               2,
               None,
               '___sec86'),
              (u' Test procedures ',
               2,
               u'sec:integrals:testprocs',
               u'sec:integrals:testprocs'),
              (u' Hand-computed results ', 3, None, '___sec88'),
              (u' Solving a problem without numerical errors ',
               3,
               None,
               '___sec89'),
              (u' Demonstrating correct convergence rates ',
               3,
               None,
               '___sec90'),
              (u' Constructing unit tests and writing test functions ',
               2,
               u'sec:integrals:test:functions',
               u'sec:integrals:test:functions'),
              (u' Hand-computed numerical results ', 3, None, '___sec92'),
              (u' Solving a problem without numerical errors ',
               3,
               None,
               '___sec93'),
              (u' Demonstrating correct convergence rates ',
               3,
               None,
               '___sec94'),
              (u' Vectorization ', 1, None, '___sec95'),
              (u' Vectorizing the midpoint rule ', 3, None, '___sec96'),
              (u' Vectorizing the trapezoidal rule ', 3, None, '___sec97'),
              (u' Measuring computational speed ', 1, None, '___sec98'),
              (u' Double and triple integrals ',
               1,
               u'sec:int:double',
               u'sec:int:double'),
              (u' The midpoint rule for a double integral ',
               2,
               u'sec:int:double:midpoint',
               u'sec:int:double:midpoint'),
              (u' Derivation via one-dimensional integrals ',
               3,
               None,
               '___sec101'),
              (u' Direct derivation ', 3, None, '___sec102'),
              (u' Programming a double sum ', 3, None, '___sec103'),
              (u' Reusing code for one-dimensional integrals ',
               3,
               None,
               '___sec104'),
              (u' Verification via test functions ', 3, None, '___sec105'),
              (u' The midpoint rule for a triple integral ',
               2,
               None,
               '___sec106'),
              (u' Theory ', 3, None, '___sec107'),
              (u' Implementation ', 3, None, '___sec108'),
              (u' Monte Carlo integration for complex-shaped domains ',
               2,
               u'sec:int:complex:domain',
               u'sec:int:complex:domain'),
              (u' The Monte Carlo integration algorithm ',
               3,
               None,
               '___sec110'),
              (u' Implementation ', 3, None, '___sec111'),
              (u' Verification ', 3, None, '___sec112'),
              (u' Test function for function with random numbers ',
               3,
               None,
               '___sec113'),
              (u' Integral over a circle ', 3, None, '___sec114'),
              (u' Exercises ', 1, None, '___sec115'),
              (u' Exercise 29: Hand calculations for the trapezoidal method ',
               2,
               u'sec:exer:trap:hand',
               u'sec:exer:trap:hand'),
              (u' Exercise 30: Hand calculations for the midpoint method ',
               2,
               u'sec:exer:midpt:hand',
               u'sec:exer:midpt:hand'),
              (u' Exercise 31: Compute a simple integral ',
               2,
               u'sec:exer:trap:mid:parabola',
               u'sec:exer:trap:mid:parabola'),
              (u' Exercise 32: Hand-calculations with sine integrals ',
               2,
               u'sec:exer:hand:sine',
               u'sec:exer:hand:sine'),
              (u' Exercise 33: Make test functions for the midpoint method ',
               2,
               u'sec:exer:test:midpoint',
               u'sec:exer:test:midpoint'),
              (u' Exercise 34: Explore round-off errors with large numbers ',
               2,
               u'sec:exer:test:roundoff',
               u'sec:exer:test:roundoff'),
              (u' Exercise 35: Write test functions for $\\int_0^4\\sqrt{x}dx$ ',
               2,
               u'sec:exer:test:convrates:sqrt',
               u'sec:exer:test:convrates:sqrt'),
              (u' Remarks ', 3, None, '___sec123'),
              (u' Exercise 36: Rectangle methods ',
               2,
               u'sec:exer:rectangleMethod',
               u'sec:exer:rectangleMethod'),
              (u' Exercise 37: Adaptive integration ',
               2,
               u'sec:exer:adaptive:int',
               u'sec:exer:adaptive:int'),
              (u' Remarks ', 3, None, '___sec126'),
              (u' Exercise 38: Integrating x raised to x ',
               2,
               u'sec:exer:integrate:x2x',
               u'sec:exer:integrate:x2x'),
              (u' Exercise 39: Integrate products of sine functions ',
               2,
               u'sec:exer:sine:products',
               u'sec:exer:sine:products'),
              (u' Exercise 40: Revisit fit of sines to a function ',
               2,
               u'sec:exer:revisitFitSines',
               u'sec:exer:revisitFitSines'),
              (u' Exercise 41: Derive the trapezoidal rule for a double integral ',
               2,
               u'sec:exer:trapezoidal:2D',
               u'sec:exer:trapezoidal:2D'),
              (u' Exercise 42: Compute the area of a triangle by Monte Carlo integration ',
               2,
               u'sec:exer:MC:ellipse',
               u'sec:exer:MC:ellipse'),
              (u' Solving ordinary differential equations ',
               0,
               u'5th:SolvODEs',
               u'5th:SolvODEs'),
              (u' Population growth ', 1, u'sec:de:pg', u'sec:de:pg'),
              (u' Derivation of the model ',
               2,
               u'sec:de:pg:model',
               u'sec:de:pg:model'),
              (u' Numerical solution ',
               2,
               u'sec:de:pg:numerics',
               u'sec:de:pg:numerics'),
              (u' Programming the Forward Euler scheme; the special case ',
               2,
               u'sec:de:pg:prog1',
               u'sec:de:pg:prog1'),
              (u' Understanding the Forward Euler method ',
               2,
               u'sec:de:pg:geom',
               u'sec:de:pg:geom'),
              (u' Programming the Forward Euler scheme; the general case ',
               2,
               u'sec:de:FE:gen',
               u'sec:de:FE:gen'),
              (u' Making the population growth model more realistic ',
               2,
               None,
               '___sec139'),
              (u' Verification: exact linear solution of the discrete equations ',
               2,
               u'sec:de:growth:test:linear',
               u'sec:de:growth:test:linear'),
              (u' Spreading of diseases ', 1, None, '___sec141'),
              (u' Spreading of a flu ', 2, u'sec:de:flu', u'sec:de:flu'),
              (u' A Forward Euler method for the differential equation system ',
               2,
               u'sec:de:flu:FE',
               u'sec:de:flu:FE'),
              (u' Programming the numerical method; the special case ',
               2,
               u'sec:de:flu:prog:spec',
               u'sec:de:flu:prog:spec'),
              (u' Outbreak or not ', 2, None, '___sec145'),
              (u' Abstract problem and notation ',
               2,
               u'sec:de:flu:generic',
               u'sec:de:flu:generic'),
              (u' Programming the numerical method; the general case ',
               2,
               u'sec:de:flu:prog:generic',
               u'sec:de:flu:prog:generic'),
              (u' Time-restricted immunity ', 2, None, '___sec148'),
              (u' Incorporating vaccination ',
               2,
               u'sec:de:flu:vaccine',
               u'sec:de:flu:vaccine'),
              (u' Discontinuous coefficients: a vaccination campaign ',
               2,
               u'sec:de:flu:vaccine:discont',
               u'sec:de:flu:vaccine:discont'),
              (u' Oscillating one-dimensional systems ',
               1,
               u'sec:de:vib',
               u'sec:de:vib'),
              (u' Derivation of a simple model ', 2, None, '___sec152'),
              (u' Numerical solution ', 2, None, '___sec153'),
              (u' Programming the numerical method; the special case ',
               2,
               u'sec:de:vib:special',
               u'sec:de:vib:special'),
              (u' A magic fix of the numerical method ',
               2,
               None,
               '___sec155'),
              (u" The 2nd-order Runge-Kutta method (or Heun's method) ",
               2,
               u'sec:de:osc:Heun',
               u'sec:de:osc:Heun'),
              (u' Odespy: software for solving ODEs ',
               2,
               u'sec:de:osc:odespy',
               u'sec:de:osc:odespy'),
              (u' The 4th-order Runge-Kutta method ', 2, None, '___sec158'),
              (u' The algorithm ', 3, None, '___sec159'),
              (u' Application ', 3, None, '___sec160'),
              (u' Implementation ', 3, None, '___sec161'),
              (u' Derivation ', 3, None, '___sec162'),
              (u' More effects: damping, nonlinearity, and external forces ',
               2,
               None,
               '___sec163'),
              (u' The Euler-Cromer scheme ', 3, None, '___sec164'),
              (u' The 4-th order Runge-Kutta method ', 3, None, '___sec165'),
              (u' Illustration of linear damping ', 2, None, '___sec166'),
              (u' Illustration of linear damping with sinusoidal excitation ',
               2,
               None,
               '___sec167'),
              (u' Spring-mass system with sliding friction ',
               2,
               u'sec:de:vib:ode2:sliding:friction',
               u'sec:de:vib:ode2:sliding:friction'),
              (u' A finite difference method; undamped, linear case ',
               2,
               u'sec:de:vib:2nd',
               u'sec:de:vib:2nd'),
              (u' A finite difference method; linear damping ',
               2,
               u'sec:de:vib:2nd:damped1',
               u'sec:de:vib:2nd:damped1'),
              (u' Exercises ', 1, None, '___sec171'),
              (u' Exercise 43: Geometric construction of the Forward Euler method ',
               2,
               u'sec:de:exer:geom',
               u'sec:de:exer:geom'),
              (u' Exercise 44: Make test functions for the Forward Euler method ',
               2,
               u'sec:de:exer:FE:test1',
               u'sec:de:exer:FE:test1'),
              (u" Exercise 45: Implement and evaluate Heun's method ",
               2,
               u'sec:de:exer:Heun:pg',
               u'sec:de:exer:Heun:pg'),
              (u' Exercise 46: Find an appropriate time step; logistic model ',
               2,
               u'sec:de:exer:logistic:dtopt',
               u'sec:de:exer:logistic:dtopt'),
              (u' Exercise 47: Find an appropriate time step; SIR model ',
               2,
               u'sec:de:exer:SIR:dtopt',
               u'sec:de:exer:SIR:dtopt'),
              (u' Exercise 48: Model an adaptive vaccination campaign ',
               2,
               u'sec:de:exer:SIRV:padapt',
               u'sec:de:exer:SIRV:padapt'),
              (u' Exercise 49: Make a SIRV model with time-limited effect of vaccination ',
               2,
               u'sec:de:exer:SIRV:padapt',
               u'sec:de:exer:SIRV:padapt'),
              (u' Exercise 50: Refactor a flat program ',
               2,
               u'sec:de:exer:vib:FE:func',
               u'sec:de:exer:vib:FE:func'),
              (u' Exercise 51: Simulate oscillations by a general ODE solver ',
               2,
               u'sec:de:exer:vib:ode_FE',
               u'sec:de:exer:vib:ode_FE'),
              (u' Exercise 52: Compute the energy in oscillations ',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u' Exercise 53: Use a Backward Euler scheme for population growth ',
               2,
               u'sec:de:exer:pg:BE',
               u'sec:de:exer:pg:BE'),
              (u' Exercise 54: Use a Crank-Nicolson scheme for population growth ',
               2,
               u'sec:de:exer:pg:CN',
               u'sec:de:exer:pg:CN'),
              (u' Exercise 55: Understand finite differences via Taylor series ',
               2,
               u'sec:de:exer:fd:Taylor',
               u'sec:de:exer:fd:Taylor'),
              (u' Exercise 56: Use a Backward Euler scheme for oscillations ',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u' Remarks ', 3, None, '___sec186'),
              (u" Exercise 57: Use Heun's method for the SIR model ",
               2,
               u'sec:de:exer:SIR:Heun',
               u'sec:de:exer:SIR:Heun'),
              (u' Exercise 58: Use Odespy to solve a simple ODE ',
               2,
               u'sec:de:exer:odespy:decay',
               u'sec:de:exer:odespy:decay'),
              (u' Exercise 59: Set up a Backward Euler scheme for oscillations ',
               2,
               u'sec:de:exer:osc:BE',
               u'sec:de:exer:osc:BE'),
              (u' Exercise 60: Set up a Forward Euler scheme for nonlinear and damped oscillations ',
               2,
               u'sec:de:exer:osc:FE:general',
               u'sec:de:exer:osc:FE:general'),
              (u' Exercise 61: Discretize an initial condition ',
               2,
               u'sec:de:exer:osc:2nd:V0ic',
               u'sec:de:exer:osc:2nd:V0ic'),
              (u' Solving partial differential equations ',
               0,
               u'6th:SolvPDEs',
               u'6th:SolvPDEs'),
              (u' Finite difference methods ',
               1,
               u'6th:SolvPDEs:MOLandFE',
               u'6th:SolvPDEs:MOLandFE'),
              (u' Reduction of a PDE to a system of ODEs ',
               2,
               u'sec:pde:diff1D:reduce',
               u'sec:pde:diff1D:reduce'),
              (u' Construction of a test problem with known discrete solution ',
               2,
               u'sec:pde:diff1D:testproblem',
               u'sec:pde:diff1D:testproblem'),
              (u' Implementation: Forward Euler method ',
               2,
               None,
               '___sec196'),
              (u' Application: heat conduction in a rod ',
               2,
               u'sec:pde:diff1D:rod',
               u'sec:pde:diff1D:rod'),
              (u' Vectorization ', 2, None, '___sec198'),
              (u' Using Odespy to solve the system of ODEs ',
               2,
               None,
               '___sec199'),
              (u' Implicit methods ', 2, None, '___sec200'),
              (u' Exercises ', 1, None, '___sec201'),
              (u' Exercise 62: Simulate a diffusion equation by hand ',
               2,
               u'sec:pde:diff1D:exer:handFE',
               u'sec:pde:diff1D:exer:handFE'),
              (u' Exercise 63: Compute temperature variations in the ground ',
               2,
               u'sec:pde:diff1D:exer:groundtemp',
               u'sec:pde:diff1D:exer:groundtemp'),
              (u' Exercise 64: Compare implicit methods ',
               2,
               u'sec:pde:diff1D:exer:compare:implicit',
               u'sec:pde:diff1D:exer:compare:implicit'),
              (u' Exercise 65: Explore adaptive and implicit methods ',
               2,
               u'sec:pde:diff1D:exer:groundtemp:adapt',
               u'sec:pde:diff1D:exer:groundtemp:adapt'),
              (u' Exercise 66: Investigate the $\\theta$ rule ',
               2,
               u'sec:pde:diff1D:exer:CN',
               u'sec:pde:diff1D:exer:CN'),
              (u' Remarks ', 3, None, '___sec207'),
              (u' Exercise 67: Compute the diffusion of a Gaussian peak ',
               2,
               u'sec:pde:diff1D:exer:Gaussian',
               u'sec:pde:diff1D:exer:Gaussian'),
              (u' Exercise 68: Vectorize a function for computing the area of a polygon ',
               2,
               u'2nd:exer:area:polygon2',
               u'2nd:exer:area:polygon2'),
              (u' Exercise 69: Explore symmetry ',
               2,
               u'sec:pde:diff1D:exer:Gaussian:symm',
               u'sec:pde:diff1D:exer:Gaussian:symm'),
              (u' Remarks ', 3, None, '___sec211'),
              (u' Exercise 70: Compute solutions as $t\\rightarrow\\infty$ ',
               2,
               u'sec:pde:diff1D:exer:stationary',
               u'sec:pde:diff1D:exer:stationary'),
              (u' Remarks ', 3, None, '___sec213'),
              (u' Exercise 71: Solve a two-point boundary value problem ',
               2,
               u'sec:pde:diff1D:exer:stationary2',
               u'sec:pde:diff1D:exer:stationary2'),
              (u' Solving nonlinear algebraic equations ',
               0,
               u'4th:NonlinAlgEq',
               u'4th:NonlinAlgEq'),
              (u' Brute force methods ',
               1,
               u'4th:bruteforce',
               u'4th:bruteforce'),
              (u' Brute force root finding ', 2, None, '___sec217'),
              (u' Numerical algorithm ', 3, None, '___sec218'),
              (u' Implementation ', 3, None, '___sec219'),
              (u' Brute force optimization ', 2, None, '___sec220'),
              (u' Numerical algorithm ', 3, None, '___sec221'),
              (u' Implementation ', 3, None, '___sec222'),
              (u' Model problem for algebraic equations ',
               2,
               None,
               '___sec223'),
              (u" Newton's method ",
               1,
               u'4th:NonlinAlgEq:Newt',
               u'4th:NonlinAlgEq:Newt'),
              (u" Deriving and implementing Newton's method ",
               2,
               None,
               '___sec225'),
              (u' Making a more efficient and robust implementation ',
               2,
               u'4th:Newton:robust',
               u'4th:Newton:robust'),
              (u' The secant method ',
               1,
               u'4th:NonlinAlgEq:Secant',
               u'4th:NonlinAlgEq:Secant'),
              (u' The bisection method ',
               1,
               u'4th:NonlinAlgEq:Bisect',
               u'4th:NonlinAlgEq:Bisect'),
              (u' Rate of convergence ',
               1,
               u'4th:NonlinAlgEq:RateConv',
               u'4th:NonlinAlgEq:RateConv'),
              (u' Exercises ', 1, None, '___sec230'),
              (u" Exercise 72: Understand why Newton's method can fail ",
               2,
               u'4th:exer:Newton:failure',
               u'4th:exer:Newton:failure'),
              (u' Exercise 73: See if the secant method fails ',
               2,
               u'4th:exer:Secant:failure',
               u'4th:exer:Secant:failure'),
              (u' Exercise 74: Understand how the bisection method cannot fail ',
               2,
               u'4th:exer:Bisection:failure',
               u'4th:exer:Bisection:failure'),
              (u" Exercise 75: Combine the bisection method with Newton's method ",
               2,
               u'4th:exer:Bisection:Newton',
               u'4th:exer:Bisection:Newton'),
              (u" Exercise 76: Write a test function for Newton's method ",
               2,
               u'4th:exer:NewtonHand',
               u'4th:exer:NewtonHand'),
              (u' Exercise 77: Solve nonlinear equation for a vibrating beam ',
               2,
               u'4th:exer:beam:vib',
               u'4th:exer:beam:vib'),
              (u' References ', 0, None, '___sec237')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    
<a name="part0000"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
</td><td>
<div style="text-align: right;"><a href="._p4c-solarized-Matlab001.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- ------------------- main content ---------------------- -->

<p>


<center><h1>Programming for Computations - A Gentle Introduction to Numerical Simulations with MATLAB/Octave</h1></center>  <!-- document title -->

<p>
<!-- author(s): Svein Linge, and Hans Petter Langtangen -->

<center>
<b>Svein Linge</b> [1]
</center>

<center>
<b>Hans Petter Langtangen</b> [2]
</center>

<p>
<!-- institution(s) -->

<center>[1] <b>Telemark University College and Simula Research Laboratory</b></center>
<center>[2] <b>Simula Research Laboratory and University of Oslo</b></center>
<p>
<center><h4>May 17, 2015</h4></center> <!-- date -->

<h1 id="___sec0">Preface </h1> <hr>

<p>
Computing, in the sense of doing mathematical calculations, is a skill that mankind has developed over thousands of years. Programming, on the other hand, is in its infancy, with a history that spans a few decades only. Both topics are vastly comprehensive and usually taught as separate subjects in educational institutions around the world, especially at the undergraduate level. This book is about
the <em>combination</em> of the two, because computing today becomes so much more powerful when combined with programming.

<p>
Most universities and colleges implicitly require students to specialize in computer science if they want to learn the craft of programming, since other student programs usually do not offer programming to an extent demanded for really mastering this craft. Common arguments claim that it is sufficient with a brief introduction, that there is not enough room for learning programming in addition to all other must-have subjects, and that there is so much software available that few really need to program themselves. A consequence is that engineering students often graduate with shallow knowledge about programming, unless they happened to choose the computer science direction.

<p>
We think this is an unfortunate situation.
There is no doubt that practicing engineers and scientists need to know their pen and paper mathematics. They must also be able to run off-the-shelf software for important standard tasks and will certainly do that a lot. Nevertheless, the benefits of mastering programming are many.

<h3 id="___sec1">Why learn programming? </h3>

<ol>
<li> Ready-made software is limited to handling certain standard problems. What do you do when the problem at hand is not covered by the software you bought? Fortunately, a lot of modern software systems are extensible via programming. In fact, many systems demand parts of the problem specification (e.g., material models) to be specified by computer code.</li>
<li> With programming skills, you may extend the flexibility of existing software packages by combining them. For example, you may integrate packages that do not speak to each other from the outset. This makes the work flow simpler, more efficient, and more reliable, and it puts you in position to attack new problems.</li>
<li> It is easy to use excellent ready-made software the wrong way. Insight in programming and the mathematics behind is fundamental for understanding complex software, avoiding pitfalls, and become a safe user.</li>
<li> Bugs (errors in computer code) are present in most larger computer programs (also in the ones from the shop!). What do you do when your ready-made software gives unexpected results? Is it a bug, is it wrong use, or is it the mathematically correct result? Experience with programming of mathematics gives you a good background for answering these questions. The one who can program, can also make tailored code for a simplified problem setting and use that to verify the computations done with off-the-shelf software.</li>
<li> Lots of skilled people around the world solve computational problems by writing their own code and offer their code for free on the Internet. To take advantage of this truly great source of software in a reliable way, one must normally be able to understand and possibly modify computer code offered by others.</li>
<li> It is recognized world wide that students struggle with mathematics and physics. Too many find such subjects difficult and boring. With programming, we can execute the good old subjects in a brand new way! According to the authors' own experience, students find it much more motivating and enlightening when programming is made an integrated part of mathematics and physical science courses. In particular, the problem being solved can be much more realistic than when the mathematics is restricted to what you can do with pen and paper.</li>
<li> Finally, we launch our most important argument for learning computer programming: the <em>algorithmic thinking</em> that comes with the process of writing a program for a computational problem enforces a thorough understanding of both the problem and solution method. We can simply quote the famous Norwegian computer scientist Kristen Nyggaard: &quot;Programming is understanding&quot;.</li>
</ol>

In the authors' experience, programming is an excellent pedagogical tool for understanding mathematics: &quot;You think you know when you can learn, are more sure when you can write, even more when you can teach, but certain when you can program&quot; (Alan Perlis, computer scientist, 1922-1990). Consider, for example, integration. A numerical method for integration has a much stronger focus on what the integral actually is and
means compared to analytical methods, where much time and effort must be devoted to integration by parts, integration by substitution, etc. Moreover, when programming the numerical integration formula, it becomes evident that it works for &quot;all&quot; mathematical functions and that the implementation should be in terms of a <em>general</em> function applicable to &quot;all&quot; integrals. In this way, students learn to recognize a special problem as belonging to a class of problems (e.g., integration, differential equations, root finding), for which we have general numerical methods implemented in widely applicable software. When they write this software, as we do in this book, they learn how to generalize and increase the abstraction level of the mathematical problem. When they use this software, they learn how a special case should be attacked by general methods and software for the class of problems that comprises the special case at hand. This is the power of mathematics in a nutshell, and it is paramount that students understand this way of thinking.

<h3 id="___sec2">Target audience and background knowledge </h3>

<p>
This book was written for students, teachers, engineers and scientists that know <em>nothing</em> about programming and numerical methods from before, but who seek a <em>minimum</em> of the fundamental skills required to get started with programming as a tool for solving scientific and engineering problems. Some knowledge of one- and multi-variable calculus is assumed. The basic programming concepts are presented in only 50 pages (Chapters 1 and 2), before practical applications of these concepts are demonstrated in important mathematical subjects addressed in the remaining parts of the book (Chapters 3-6). Each chapter is followed by a set of exercises that cover a wide range of application areas, e.g. biology, geology, statistics, physics and mathematics. The exercises were particularly designed to bring across important points from the text. The reader will realize that the modest content of the first 50 pages can in fact bring you quite far in powerful problem solving! All code presented in this book can be downloaded from <a href="http://hplgit.github.io/prog4comp" target="_self"><tt>http://hplgit.github.io/prog4comp</tt></a>.

<p>
Learning the very basics of programming should not take long, but as with any other craft, mastering the skill requires continued and extensive practice. Some beginning practice is gained through Chapters 3-6, but the authors strongly emphasize that this is only a start. Students should continue to practice programming in subsequent courses, while those who exercise self-study, should keep up the learning process through continued application of the craft. The book is a good starting point when teaching computer programming as an integrated part of standard university courses in mathematics and physical sciences. In our experience, such an integration is doable and indeed rewarding.

<h3 id="___sec3">Numerical methods </h3>

<p>
An overall goal with this book is to motivate computer programming as a very powerful tool for doing mathematics. All examples are related to mathematics and its use in engineering and science. However, to solve mathematical problems through computer programming, we need numerical methods. Explaining basic numerical methods is therefore an integral part of the book. Our choice of topics is governed by what is most needed in science and engineering, as well as in the teaching of applied physical science courses. Mathematical models are then central, with differential equations constituting the most frequent type of models. Consequently, the numerical focus in this book is on differential equations. As a soft pedagogical starter for the programming of mathematics, we have chosen the topic of numerical integration. There is also a chapter on root finding, which is important for the numerical solution on nonlinear differential equations.  We remark that the book is deliberately brief on numerical methods. This is because our focus is on <em>implementing</em> numerical algorithms, but to develop reliable, working programs, the programmer must be confident about the basic ideas of the numerical approximations involved.

<h3 id="___sec4">The computer language: Matlab </h3>

<p>
We have chosen to use the programming language Matlab, because this language gives very compact and readable code that closely resembles the mathematical
recipe for solving the problem at hand. Matlab also has a gentle learning curve. There is a
Python
companion of this book in case that language is preferred.
We use the term <em>Matlab</em> throughout this book to mean the commercial MATLAB (R) software <a href="._p4c-solarized-Matlab029.html#matlab">[1]</a>
<em>or</em> the open source alternative Octave <a href="._p4c-solarized-Matlab029.html#octave">[2]</a>.
Comparing these two versions of the book provides an excellent demonstration of how similar these languages are. Other computer languages, like Fortran, C, and C++, have a strong position in science and engineering. During the last two decades, however, there has been a significant shift in popularity from these compiled languages to more
high-level and easier-to-read languages like MATLAB, Python, R, Maple, Mathematica, and IDL, for instance. This latter class of languages is computationally less efficient, but superior with respect to overall human problem solving efficiency. This book emphasizes <em>how to think like a programmer</em>, rather than focusing on technical language details. Thus, the book should put the reader in a good position for learning other programming languages later, including the classic ones: Fortran, C, and C++.

<h3 id="___sec5">How this book is different </h3>

<p>
There are numerous texts on computer programming and numerical methods, so how does the present one differ from the existing literature? Compared to books on numerical methods, our book has a much stronger emphasis on the craft of programming and on verification. We want to give students a thorough understanding of how one thinks about programming as a problem solving method and how one can be sure that programs are correct (well, you can never be completely sure, but we show how you can provide convincing evidence for correctness).

<p>
Even though there are lots of books on numerical methods where many algorithms have a corresponding computer implementation (see, e.g.,
<a href="._p4c-solarized-Matlab029.html#Conte_de_Boor_1980">[3]</a> <a href="._p4c-solarized-Matlab029.html#Press_et_al_1992">[4]</a> <a href="._p4c-solarized-Matlab029.html#Recktenwald_2000">[5]</a> <a href="._p4c-solarized-Matlab029.html#Nakamura_2002">[6]</a> <a href="._p4c-solarized-Matlab029.html#Otto_Denier_2005">[7]</a> <a href="._p4c-solarized-Matlab029.html#Moler_2004">[8]</a> <a href="._p4c-solarized-Matlab029.html#Sewell_2005">[9]</a> <a href="._p4c-solarized-Matlab029.html#Danaila_et_al_2007">[10]</a> <a href="._p4c-solarized-Matlab029.html#Trefethen_2000">[11]</a> <a href="._p4c-solarized-Matlab029.html#Trefethen_2012">[12]</a> <a href="._p4c-solarized-Matlab029.html#Lyche_Merrien_2014">[13]</a> <a href="._p4c-solarized-Matlab029.html#Siauw_Bayen_2014">[14]</a> <a href="._p4c-solarized-Matlab029.html#Harder_Khoury_2015">[15]</a> <a href="._p4c-solarized-Matlab029.html#Young_Mohlenkamp_2015">[16]</a> <a href="._p4c-solarized-Matlab029.html#Baochuan_2015">[17]</a> <a href="._p4c-solarized-Matlab029.html#Kiusalaas_2005">[18]</a>)
it is assumed that the reader &quot;can program&quot; beforehand. The present book teaches the craft of structured programming along with the numerical methods. Furthermore, we have so far not found any other numerical methods book that has a strong emphasis on verifying implementations. In this book, unit testing and corresponding test functions are introduced early on. We also put much emphasis on coding algorithms as <em>functions</em>, as opposed to &quot;flat programs&quot;, which often dominate in the literature and among practitioners. Functions are reusable because they utilize the general formulation of a mathematical algorithm such that it becomes applicable to a large class of problems.

<p>
There are also numerous books on computer programming, but to our knowledge only one <a href="._p4c-solarized-Matlab029.html#Langtangen_2012">[19]</a> that aims to teach programming in the context of numerical methods and scientific applications. That book <a href="._p4c-solarized-Matlab029.html#Langtangen_2012">[19]</a> has its primary focus on teaching Python and is a very comprehensive introduction to Python as a language and the thinking about programming as a computer scientist. Sometimes one needs a text that does not go so deep into the language-specific details,
but instead targets the shortest path to reliable mathematical problem solving through programming. With this attitude in mind, a lot of topics were left out of the present book, simply because they were not <em>strictly</em> needed in the mathematical problem solving process.
An example of such a topic is object-oriented programming.

<p>
Whenever the need for a <em>structured introduction to programming</em> arises in science and engineering courses, this book may be your option, either for self-study or for use in organized teaching. The thinking, habits, and practice covered in a couple of hundred pages will put readers in a firm position for utilizing and understanding the power of computers for problem solving in science and engineering.

<h3 id="___sec6">Acknowledgments </h3>

<p>
First of all we must thank all the classes at Telemark Engineering College that worked their way through early versions of this text and reported various kinds of problems.
Special acknowledgement goes to Edirisinghe V. P. J. Manjula for his careful reading of the manuscript and for his constructive suggestions for improvement.
The careful proof reading by Yapi Donatien Achou is also highly appreciated.
Some colleagues???????????????????????
Svein Linge is particularly thankful to Prof. Marius Lysaker
for their fruitful collaboration on introducing programming as an integral part
of mathematics and physics bachelor courses at Telemark Engineering College.

<p>
The text was written in the <a href="https://github.com/hplgit/doconce" target="_self">DocOnce</a> <a href="._p4c-solarized-Matlab029.html#doconce">[20]</a> markup language,
which allowed us to work with a single text source for both the Python
and the Matlab version of this book, and to produce various electronic
versions of the book.

<p>
<!-- Table of contents -->

<h2>Table of contents</h2>

<p>
<a href="#___sec0"> Preface </a><br>
<a href="._p4c-solarized-Matlab001.html#1st:TheFirstFewSteps"> The first few steps </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab001.html#___sec8"> What is a program? And what is programming? </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab002.html#1st:ex1"> A Matlab program with variables </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab002.html#___sec10"> The program </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab002.html#___sec11"> Dissection of the program </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab002.html#___sec12"> Why not just use a pocket calculator? </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab002.html#___sec13"> The importance of using a text editor to write programs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab002.html#___sec14"> Write and run your first program </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab003.html#1st:ex2">  A Matlab program with a library function </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab004.html#1st:ex3"> A Matlab program with vectorization and plotting </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec19"> More basic concepts </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec20"> Using Matlab interactively </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec21"> Arithmetics, parentheses and round-off errors </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec22"> Variables </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec23"> Formatting text and numbers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec24"> Arrays </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec25"> Plotting </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec26"> Error messages and warnings </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec27"> Input data </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec28"> Symbolic computations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab005.html#___sec29"> Concluding remarks </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#___sec30"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:ErrorMessages"> Exercise 1: Error messages </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:cubeVolume"> Exercise 2: Volume of a cube </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:areaCircle"> Exercise 3: Area and circumference of a circle </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:volumes3cubes"> Exercise 4: Volumes of three cubes </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:averageOf5Integers"> Exercise 5: Average of integers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:cubeVolInteractively"> Exercise 6: Interactive computing of volume and area </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:updateVarInteractively"> Exercise 7: Update variable at command prompt </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:printfScreen"> Exercise 8: Formatted print to screen </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab006.html#1st:exer:PythonDocRandom"> Exercise 9: Matlab documentation and random numbers </a><br>
<a href="._p4c-solarized-Matlab007.html#2nd:BasicConstructins"> Basic constructions </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab007.html#___sec41"> If tests, colon and indentation </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab008.html#sec:functions"> Functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab009.html#sec:for:loops"> For loops </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab010.html#sec:while:loops"> While loops </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab010.html#sec:file:reading:writing"> Reading from and writing to files </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#___sec46"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:IntroducingErrors"> Exercise 10: Introducing errors </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:compInt"> Exercise 11: Compare integers a and b </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:funcCircArea"> Exercise 12: Functions for circumference and area of a circle </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:funcAreaRectangle"> Exercise 13: Function for area of a rectangle </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:area:polygon"> Exercise 14: Area of a polygon </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:avNInt"> Exercise 15: Average of integers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:whileLoopErrors"> Exercise 16: While loop with errors </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:areaRectCircle"> Exercise 17: Area of rectangle versus circle </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:Cross2Graphs"> Exercise 18: Find crossing points of two graphs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:sortNumbers"> Exercise 19: Sort array with numbers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:computingPi"> Exercise 20: Compute \( \pi \) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:combinatorics1"> Exercise 21: Compute combinations of sets </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:numberOccurrence"> Exercise 22: Frequency of random numbers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:Game21"> Exercise 23: Game 21 </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:linearInterpol"> Exercise 24: Linear interpolation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:testStraightLine"> Exercise 25: Test straight line requirement </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:fitLine"> Exercise 26: Fit straight line to data </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:fitSines"> Exercise 27: Fit sines to straight line </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab011.html#2nd:exer:countTextString"> Exercise 28: Count occurrences of a string in a string </a><br>
<a href="._p4c-solarized-Matlab012.html#sec:integrals"> Computing integrals </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab012.html#sec:integrals:basic"> Basic ideas of numerical integration </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab013.html#sec:integrals:trap"> The composite trapezoidal rule </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab013.html#sec:integrals:formula"> The general formula </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab013.html#sec:integrals:trap:impl"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab013.html#___sec79"> Alternative flat special-purpose implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#sec:integrals:Midpoint"> The composite midpoint method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#___sec82"> The general formula </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#sec:midpoint:code"> Implementation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#___sec84"> Comparing the trapezoidal and the midpoint methods </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#___sec85"> Testing </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#___sec86"> Problems with brief testing procedures </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#sec:integrals:testprocs"> Test procedures </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#sec:integrals:test:functions"> Constructing unit tests and writing test functions </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#___sec95"> Vectorization </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#___sec98"> Measuring computational speed </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#sec:int:double"> Double and triple integrals </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#sec:int:double:midpoint"> The midpoint rule for a double integral </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#___sec106"> The midpoint rule for a triple integral </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab014.html#sec:int:complex:domain"> Monte Carlo integration for complex-shaped domains </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#___sec115"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:trap:hand"> Exercise 29: Hand calculations for the trapezoidal method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:midpt:hand"> Exercise 30: Hand calculations for the midpoint method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:trap:mid:parabola"> Exercise 31: Compute a simple integral </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:hand:sine"> Exercise 32: Hand-calculations with sine integrals </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:test:midpoint"> Exercise 33: Make test functions for the midpoint method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:test:roundoff"> Exercise 34: Explore round-off errors with large numbers </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:test:convrates:sqrt"> Exercise 35: Write test functions for \( \int_0^4\sqrt{x}dx \) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:rectangleMethod"> Exercise 36: Rectangle methods </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:adaptive:int"> Exercise 37: Adaptive integration </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:integrate:x2x"> Exercise 38: Integrating x raised to x </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:sine:products"> Exercise 39: Integrate products of sine functions </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:revisitFitSines"> Exercise 40: Revisit fit of sines to a function </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:trapezoidal:2D"> Exercise 41: Derive the trapezoidal rule for a double integral </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab015.html#sec:exer:MC:ellipse"> Exercise 42: Compute the area of a triangle by Monte Carlo integration </a><br>
<a href="._p4c-solarized-Matlab016.html#5th:SolvODEs"> Solving ordinary differential equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab017.html#sec:de:pg"> Population growth </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab017.html#sec:de:pg:model"> Derivation of the model </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab017.html#sec:de:pg:numerics"> Numerical solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab017.html#sec:de:pg:prog1"> Programming the Forward Euler scheme; the special case </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab017.html#sec:de:pg:geom"> Understanding the Forward Euler method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab017.html#sec:de:FE:gen"> Programming the Forward Euler scheme; the general case </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab017.html#___sec139"> Making the population growth model more realistic </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab017.html#sec:de:growth:test:linear"> Verification: exact linear solution of the discrete equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#___sec141"> Spreading of diseases </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#sec:de:flu"> Spreading of a flu </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#sec:de:flu:FE"> A Forward Euler method for the differential equation system </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#sec:de:flu:prog:spec"> Programming the numerical method; the special case </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#___sec145"> Outbreak or not </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#sec:de:flu:generic"> Abstract problem and notation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#sec:de:flu:prog:generic"> Programming the numerical method; the general case </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#___sec148"> Time-restricted immunity </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#sec:de:flu:vaccine"> Incorporating vaccination </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab018.html#sec:de:flu:vaccine:discont"> Discontinuous coefficients: a vaccination campaign </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#sec:de:vib"> Oscillating one-dimensional systems </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#___sec152"> Derivation of a simple model </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#___sec153"> Numerical solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#sec:de:vib:special"> Programming the numerical method; the special case </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#___sec155"> A magic fix of the numerical method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#sec:de:osc:Heun"> The 2nd-order Runge-Kutta method (or Heun's method) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#sec:de:osc:odespy"> Odespy: software for solving ODEs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#___sec158"> The 4th-order Runge-Kutta method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#___sec163"> More effects: damping, nonlinearity, and external forces </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#___sec166"> Illustration of linear damping </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#___sec167"> Illustration of linear damping with sinusoidal excitation </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#sec:de:vib:ode2:sliding:friction"> Spring-mass system with sliding friction </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#sec:de:vib:2nd"> A finite difference method; undamped, linear case </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab019.html#sec:de:vib:2nd:damped1"> A finite difference method; linear damping </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#___sec171"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:geom"> Exercise 43: Geometric construction of the Forward Euler method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:FE:test1"> Exercise 44: Make test functions for the Forward Euler method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:Heun:pg"> Exercise 45: Implement and evaluate Heun's method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:logistic:dtopt"> Exercise 46: Find an appropriate time step; logistic model </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:SIR:dtopt"> Exercise 47: Find an appropriate time step; SIR model </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:SIRV:padapt"> Exercise 48: Model an adaptive vaccination campaign </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:SIRV:padapt"> Exercise 49: Make a SIRV model with time-limited effect of vaccination </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:vib:FE:func"> Exercise 50: Refactor a flat program </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:vib:ode_FE"> Exercise 51: Simulate oscillations by a general ODE solver </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:vib:BE"> Exercise 52: Compute the energy in oscillations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:pg:BE"> Exercise 53: Use a Backward Euler scheme for population growth </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:pg:CN"> Exercise 54: Use a Crank-Nicolson scheme for population growth </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:fd:Taylor"> Exercise 55: Understand finite differences via Taylor series </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:vib:BE"> Exercise 56: Use a Backward Euler scheme for oscillations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:SIR:Heun"> Exercise 57: Use Heun's method for the SIR model </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:odespy:decay"> Exercise 58: Use Odespy to solve a simple ODE </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:osc:BE"> Exercise 59: Set up a Backward Euler scheme for oscillations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:osc:FE:general"> Exercise 60: Set up a Forward Euler scheme for nonlinear and damped oscillations </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab020.html#sec:de:exer:osc:2nd:V0ic"> Exercise 61: Discretize an initial condition </a><br>
<a href="._p4c-solarized-Matlab021.html#6th:SolvPDEs"> Solving partial differential equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#6th:SolvPDEs:MOLandFE"> Finite difference methods </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:reduce"> Reduction of a PDE to a system of ODEs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:testproblem"> Construction of a test problem with known discrete solution </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#___sec196"> Implementation: Forward Euler method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:rod"> Application: heat conduction in a rod </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#___sec198"> Vectorization </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#___sec199"> Using Odespy to solve the system of ODEs </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#___sec200"> Implicit methods </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#___sec201"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:handFE"> Exercise 62: Simulate a diffusion equation by hand </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:groundtemp"> Exercise 63: Compute temperature variations in the ground </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:compare:implicit"> Exercise 64: Compare implicit methods </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:groundtemp:adapt"> Exercise 65: Explore adaptive and implicit methods </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:CN"> Exercise 66: Investigate the \( \theta \) rule </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:Gaussian"> Exercise 67: Compute the diffusion of a Gaussian peak </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#2nd:exer:area:polygon2"> Exercise 68: Vectorize a function for computing the area of a polygon </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:Gaussian:symm"> Exercise 69: Explore symmetry </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:stationary"> Exercise 70: Compute solutions as \( t\rightarrow\infty \) </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab022.html#sec:pde:diff1D:exer:stationary2"> Exercise 71: Solve a two-point boundary value problem </a><br>
<a href="._p4c-solarized-Matlab023.html#4th:NonlinAlgEq"> Solving nonlinear algebraic equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab023.html#4th:bruteforce"> Brute force methods </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab023.html#___sec217"> Brute force root finding </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab023.html#___sec220"> Brute force optimization </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab023.html#___sec223"> Model problem for algebraic equations </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab024.html#4th:NonlinAlgEq:Newt"> Newton's method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab024.html#___sec225"> Deriving and implementing Newton's method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab024.html#4th:Newton:robust"> Making a more efficient and robust implementation </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab025.html#4th:NonlinAlgEq:Secant"> The secant method </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab026.html#4th:NonlinAlgEq:Bisect"> The bisection method </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab027.html#4th:NonlinAlgEq:RateConv"> Rate of convergence </a><br>
&nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab028.html#___sec230"> Exercises </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab028.html#4th:exer:Newton:failure"> Exercise 72: Understand why Newton's method can fail </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab028.html#4th:exer:Secant:failure"> Exercise 73: See if the secant method fails </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab028.html#4th:exer:Bisection:failure"> Exercise 74: Understand how the bisection method cannot fail </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab028.html#4th:exer:Bisection:Newton"> Exercise 75: Combine the bisection method with Newton's method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab028.html#4th:exer:NewtonHand"> Exercise 76: Write a test function for Newton's method </a><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <a href="._p4c-solarized-Matlab028.html#4th:exer:beam:vib"> Exercise 77: Solve nonlinear equation for a vibrating beam </a><br>
<a href="._p4c-solarized-Matlab029.html#___sec237"> References </a><br>
</p>
<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
</td><td>
<div style="text-align: right;"><a href="._p4c-solarized-Matlab001.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

