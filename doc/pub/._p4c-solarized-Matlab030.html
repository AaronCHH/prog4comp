<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="A Gentle Introduction to Programming for Computations">
<meta name="keywords" content="computer program,programming,language programming,language computer,Matlab,Octave,Fortran,C,C++,Python,Maple,Mathematica,syntax,bug,debugging,script (and scripting),implement,print,program run,program execute,code,comment,instruction,program statement,variable,assignment,semi-colon (easy print),calculator,text editor,Idle,prompt,program typing,program run,program execute,ipython,m-file,function,function call,atan,function input parameter,function output parameter,function return,function take a parameter,library,library function,from,import,math,module,package,linspace,xlabel,ylabel,plot,interactive use (of Matlab),import,keyboard arrow up/down,operator Arithmetic,parentheses,variable type,variable name,float,integer,string,type conversion,reserved words,variable integer,variable float,variable string,variable assignment,default,single (precision),double (precision),printing formatted,printf formatting,default,array,array element,zeros,allocate,array index,indexing zero based,indexing one based,Matlab one-based indexing,array slice of,graph,hold (on/off),plot figure,title,legend,axis,hardcopy,format png,matrix mat,matrix vector product,transpose,linear algebra,matrix,vector,error message,debugging,debugger,try-exception,exception handling,program crash,program testing,program verification,program input,program output,input,raw input,symbolic computations,symbolic operations,symbolic simplifications,Symbolic Toolbox,WolframAlpha,Mathematica,Sage (symbolic package),Python documentation,garbage collection,variable delete,if,elif,else,colon,indent,boolean,boolean expression,True,False,boolean True,boolean False,operator Logical,function,function definition,def,return,argument,parameter input,parameter output,function nargin,function nargout,variable local,variable global,doc string,function handle,function local,function global,function nested,loop for,for loop,range,loop iteration,loop index,loop double,loop multiple,loop nested,linear algebra,while loop,loop while,loop infinite,loop iteration,loop index,array sorting,Leibniz pi,Euler pi,programming game,linear interpolation,least squares method,Fourier series,integral analytically,integral exact,integral approximately,integration points,pseudo code,code re-use,unit tests,finite difference method,forward difference approximation,Forward Euler scheme,logistic model,carrying capacity,SIR model,scalar ODE,ODE scalar,vector ODE,ODE vector,system of ODEs,Heun's method,Runge-Kutta, 2nd-order method,2nd-order Runge-Kutta method,RK2,PDE,heat equation,diffusion equation,MOL forward Euler,method of lines,MOL,stability,instability,MOL backward Euler,tridiagonal matrix,stability,instability,Taylor series approximation,polynomial,equation solver,code robust,code try-except,code exception,Newton starting value,return None,sys.exit,tolerance">

<title>A Gentle Introduction to Programming for Computations</title>


<link href="https://raw.githubusercontent.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://raw.github.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Let pre tags for code blocks have the same color as the surroundings */
pre { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u' Preface ', 0, None, '___sec0'),
              (u' The first few steps ',
               0,
               u'1st:TheFirstFewSteps',
               u'1st:TheFirstFewSteps'),
              (u' What is a program? And what is programming? ',
               1,
               None,
               '___sec2'),
              (u' A Matlab program with variables ',
               1,
               u'1st:ex1',
               u'1st:ex1'),
              (u' The program ', 2, None, '___sec4'),
              (u' Dissection of the program ', 2, None, '___sec5'),
              (u' Why not just use a pocket calculator? ',
               2,
               None,
               '___sec6'),
              (u' The importance of using a text editor to write programs ',
               2,
               None,
               '___sec7'),
              (u' Write and run your first program ', 2, None, '___sec8'),
              (u' Write and run a program in Matlab ', 3, None, '___sec9'),
              (u' Write a program in a text editor and run it in Octave ',
               3,
               None,
               '___sec10'),
              (u'  A Matlab program with a library function ',
               1,
               u'1st:ex2',
               u'1st:ex2'),
              (u' A Matlab program with vectorization and plotting ',
               1,
               u'1st:ex3',
               u'1st:ex3'),
              (u' More basic concepts ', 1, None, '___sec13'),
              (u' Using Matlab interactively ', 2, None, '___sec14'),
              (u' Arithmetics, parentheses and round-off error ',
               2,
               None,
               '___sec15'),
              (u' Variables ', 2, None, '___sec16'),
              (u' Formatting text and numbers ', 2, None, '___sec17'),
              (u' Arrays and more on plotting ', 2, None, '___sec18'),
              (u' Error messages and warnings ', 2, None, '___sec19'),
              (u' Input data ', 2, None, '___sec20'),
              (u' Reading from and writing to files ', 2, None, '___sec21'),
              (u' Symbolic computations ', 2, None, '___sec22'),
              (u' Exercises ', 1, None, '___sec23'),
              (u' Exercise 1: Error messages ',
               2,
               u'1st:exer:ErrorMessages',
               u'1st:exer:ErrorMessages'),
              (u' Exercise 2: Volume of a cube ',
               2,
               u'1st:exer:cubeVolume',
               u'1st:exer:cubeVolume'),
              (u' Exercise 3: Area and circumference of a circle ',
               2,
               u'1st:exer:areaCircle',
               u'1st:exer:areaCircle'),
              (u' Exercise 4: Volumes of three cubes ',
               2,
               u'1st:exer:volumes3cubes',
               u'1st:exer:volumes3cubes'),
              (u' Exercise 5: Average of integers ',
               2,
               u'1st:exer:averageOf5Integers',
               u'1st:exer:averageOf5Integers'),
              (u' Exercise 6: Volume and area at command prompt ',
               2,
               u'1st:exer:cubeVolInteractively',
               u'1st:exer:cubeVolInteractively'),
              (u' Exercise 7: Update variable at command prompt ',
               2,
               u'1st:exer:updateVarInteractively',
               u'1st:exer:updateVarInteractively'),
              (u' Exercise 8: Formatted print to screen ',
               2,
               u'1st:exer:printfScreen',
               u'1st:exer:printfScreen'),
              (u' Exercise 9: Matlab documentation and random numbers ',
               2,
               u'1st:exer:PythonDocRandom',
               u'1st:exer:PythonDocRandom'),
              (u' Basic constructions ',
               0,
               u'2nd:BasicConstructins',
               u'2nd:BasicConstructins'),
              (u' if tests, colon and indent ', 1, None, '___sec34'),
              (u' Functions ', 1, None, '___sec35'),
              (u' For loops ', 1, u'sec:for:loops', u'sec:for:loops'),
              (u' While loops ', 1, u'sec:while:loops', u'sec:while:loops'),
              (u' Exercises ', 1, None, '___sec38'),
              (u' Exercise 10: Introducing errors ',
               2,
               u'2nd:exer:IntroducingErrors',
               u'2nd:exer:IntroducingErrors'),
              (u' Exercise 11: Compare integers a and b ',
               2,
               u'2nd:exer:compInt',
               u'2nd:exer:compInt'),
              (u' Exercise 12: Functions for circumference and area of a circle ',
               2,
               u'2nd:exer:funcCircArea',
               u'2nd:exer:funcCircArea'),
              (u' Exercise 13: Function for area of a rectangle ',
               2,
               u'2nd:exer:funcAreaRectangle',
               u'2nd:exer:funcAreaRectangle'),
              (u' Exercise 14: Average of integers ',
               2,
               u'2nd:exer:avNInt',
               u'2nd:exer:avNInt'),
              (u' Exercise 15: While loop with errors ',
               2,
               u'2nd:exer:whileLoopErrors',
               u'2nd:exer:whileLoopErrors'),
              (u' Exercise 16: Area of rectangle versus circle ',
               2,
               u'2nd:exer:areaRectCircle',
               u'2nd:exer:areaRectCircle'),
              (u' Exercise 17: Find crossing points of two graphs ',
               2,
               u'2nd:exer:Cross2Graphs',
               u'2nd:exer:Cross2Graphs'),
              (u' Exercise 18: Sort array with numbers ',
               2,
               u'2nd:exer:sortNumbers',
               u'2nd:exer:sortNumbers'),
              (u' Exercise 19: Computing $\\pi$ ',
               2,
               u'2nd:exer:computingPi',
               u'2nd:exer:computingPi'),
              (u' Exercise 20: Find right number combination ',
               2,
               u'2nd:exer:numberCombination',
               u'2nd:exer:numberCombination'),
              (u' Exercise 21: Frequency of random numbers ',
               2,
               u'2nd:exer:numberOccurrence',
               u'2nd:exer:numberOccurrence'),
              (u' Remarks ', 3, None, '___sec51'),
              (u' Exercise 22: Game 21 ',
               2,
               u'2nd:exer:Game21',
               u'2nd:exer:Game21'),
              (u' Exercise 23: Linear interpolation ',
               2,
               u'2nd:exer:linearInterpol',
               u'2nd:exer:linearInterpol'),
              (u' Exercise 24: Test straight line requirement ',
               2,
               u'2nd:exer:testStraightLine',
               u'2nd:exer:testStraightLine'),
              (u' Exercise 25: Fit straight line to data ',
               2,
               u'2nd:exer:fitLine',
               u'2nd:exer:fitLine'),
              (u' Remarks ', 3, None, '___sec56'),
              (u' Exercise 26: Fit sines to straight line ',
               2,
               u'2nd:exer:fitSines',
               u'2nd:exer:fitSines'),
              (u' Remarks ', 3, None, '___sec58'),
              (u' Computing integrals ',
               0,
               u'sec:integrals',
               u'sec:integrals'),
              (u' Basic ideas of numerical integration ',
               1,
               u'sec:integrals:basic',
               u'sec:integrals:basic'),
              (u' The composite trapezoidal rule ',
               1,
               u'sec:integrals:trap',
               u'sec:integrals:trap'),
              (u' The idea ',
               2,
               u'sec:integrals:trap:idea',
               u'sec:integrals:trap:idea'),
              (u' The general formula ',
               2,
               u'sec:integrals:formula',
               u'sec:integrals:formula'),
              (u' Implementation ',
               2,
               u'sec:integrals:trap:impl',
               u'sec:integrals:trap:impl'),
              (u' Specific or general implementation? ', 3, None, '___sec65'),
              (u' Implementation with functions ', 3, None, '___sec66'),
              (u' Solving our specific problem in a session ',
               3,
               None,
               '___sec67'),
              (u' Solving our specific problem in a program ',
               3,
               None,
               '___sec68'),
              (u' Alternative flat special-purpose implementation ',
               2,
               None,
               '___sec69'),
              (u' The composite midpoint method ',
               1,
               u'sec:integrals:Midpoint',
               u'sec:integrals:Midpoint'),
              (u' The idea ', 3, None, '___sec71'),
              (u' The general formula ', 2, None, '___sec72'),
              (u' Implementation ', 2, None, '___sec73'),
              (u' Comparing the trapezoidal and the midpoint methods ',
               2,
               None,
               '___sec74'),
              (u' Testing ', 1, None, '___sec75'),
              (u' Problems with brief testing procedures ',
               2,
               None,
               '___sec76'),
              (u' Test procedures ',
               2,
               u'sec:integrals:testprocs',
               u'sec:integrals:testprocs'),
              (u' Hand-computed results ', 3, None, '___sec78'),
              (u' Solving a problem without numerical errors ',
               3,
               None,
               '___sec79'),
              (u' Demonstrate correct convergence rates ',
               3,
               None,
               '___sec80'),
              (u' Test functions for test procedures ',
               2,
               u'sec:integrals:test:functions',
               u'sec:integrals:test:functions'),
              (u' Hand-computed results ', 3, None, '___sec82'),
              (u' Solving a problem without numerical errors ',
               3,
               None,
               '___sec83'),
              (u' Demonstrate correct convergence rates ',
               3,
               None,
               '___sec84'),
              (u' Vectorization ', 1, None, '___sec85'),
              (u' Measuring computational speed ', 1, None, '___sec86'),
              (u' Double and triple integrals ', 1, None, '___sec87'),
              (u' Exercises ', 1, None, '___sec88'),
              (u' Exercise 27: Hand calculations for the trapezoidal method ',
               2,
               u'sec:exer:trap:hand',
               u'sec:exer:trap:hand'),
              (u' Exercise 28: Hand calculations for the midpoint method ',
               2,
               u'sec:exer:midpt:hand',
               u'sec:exer:midpt:hand'),
              (u' Exercise 29: Compute a simple integral ',
               2,
               u'sec:exer:trap:mid:parabola',
               u'sec:exer:trap:mid:parabola'),
              (u' Exercise 30: Hand-calculations with sine integrals ',
               2,
               u'sec:exer:hand:sine',
               u'sec:exer:hand:sine'),
              (u' Exercise 31: Make test functions for the midpoint method ',
               2,
               u'sec:exer:test:midpoint',
               u'sec:exer:test:midpoint'),
              (u' Exercise 32: Explore round-off errors with large numbers ',
               2,
               u'sec:exer:test:roundoff',
               u'sec:exer:test:roundoff'),
              (u' Exercise 33: Write test functions for $\\int_0^4\\sqrt{x}dx$ ',
               2,
               u'sec:exer:test:convrates:sqrt',
               u'sec:exer:test:convrates:sqrt'),
              (u' Remarks ', 3, None, '___sec96'),
              (u' Exercise 34: Rectangle methods ',
               2,
               u'sec:exer:rectangleMethod',
               u'sec:exer:rectangleMethod'),
              (u' Exercise 35: Adaptive integration ',
               2,
               u'sec:exer:adaptive:int',
               u'sec:exer:adaptive:int'),
              (u' Remarks ', 3, None, '___sec99'),
              (u' Exercise 36: Integrating x raised to x ',
               2,
               u'sec:exer:integrate:x2x',
               u'sec:exer:integrate:x2x'),
              (u' Exercise 37: Revisit fit of sines to a function ',
               2,
               u'sec:exer:revisitFitSines',
               u'sec:exer:revisitFitSines'),
              (u' Solving ordinary differential equations ',
               0,
               u'5th:SolvODEs',
               u'5th:SolvODEs'),
              (u' Population growth ', 1, u'sec:de:pg', u'sec:de:pg'),
              (u' Derivation of the model ',
               2,
               u'sec:de:pg:model',
               u'sec:de:pg:model'),
              (u' Numerical solution ',
               2,
               u'sec:de:pg:numerics',
               u'sec:de:pg:numerics'),
              (u' Programming the Forward Euler scheme; the special case ',
               2,
               u'sec:de:pg:prog1',
               u'sec:de:pg:prog1'),
              (u' Understanding the Forward Euler method ',
               2,
               u'sec:de:pg:geom',
               u'sec:de:pg:geom'),
              (u' Programming the Forward Euler scheme; the general case ',
               2,
               u'sec:de:FE:gen',
               u'sec:de:FE:gen'),
              (u' Making the population growth model more realistic ',
               2,
               None,
               '___sec109'),
              (u' Verification: exact linear solution of the discrete equations ',
               2,
               u'sec:de:growth:test:linear',
               u'sec:de:growth:test:linear'),
              (u' Spreading of diseases ', 1, None, '___sec111'),
              (u' Spreading of a flu ', 2, u'sec:de:flu', u'sec:de:flu'),
              (u' A Forward Euler method for the differential equation system ',
               2,
               u'sec:de:flu:FE',
               u'sec:de:flu:FE'),
              (u' Programming the numerical method; the special case ',
               2,
               u'sec:de:flu:prog:spec',
               u'sec:de:flu:prog:spec'),
              (u' Outbreak or not ', 2, None, '___sec115'),
              (u' Abstract problem and notation ',
               2,
               u'sec:de:flu:generic',
               u'sec:de:flu:generic'),
              (u' Programming the numerical method; the general case ',
               2,
               u'sec:de:flu:prog:generic',
               u'sec:de:flu:prog:generic'),
              (u' Time-restricted immunity ', 2, None, '___sec118'),
              (u' Incorporating vaccination ', 2, None, '___sec119'),
              (u' Discontinuous coefficients: a vaccination campaign ',
               2,
               u'sec:de:flu:vaccine:discont',
               u'sec:de:flu:vaccine:discont'),
              (u' Oscillating one-dimensional systems ',
               1,
               u'sec:de:vib',
               u'sec:de:vib'),
              (u' Derivation of a simple model ', 2, None, '___sec122'),
              (u' Numerical solution ', 2, None, '___sec123'),
              (u' Programming the numerical method; the special case ',
               2,
               u'sec:de:vib:special',
               u'sec:de:vib:special'),
              (u' A magic fix of the numerical method ',
               2,
               None,
               '___sec125'),
              (u" The 2nd-order Runge-Kutta method (or Heun's method) ",
               2,
               u'sec:de:osc:Heun',
               u'sec:de:osc:Heun'),
              (u' Odespy: software for solving ODEs ',
               2,
               u'sec:de:osc:odespy',
               u'sec:de:osc:odespy'),
              (u' The 4th-order Runge-Kutta method ', 2, None, '___sec128'),
              (u' The algorithm ', 3, None, '___sec129'),
              (u' Application ', 3, None, '___sec130'),
              (u' Implementation ', 3, None, '___sec131'),
              (u' Derivation ', 3, None, '___sec132'),
              (u' More effects: damping, nonlinearity, and external forces ',
               2,
               None,
               '___sec133'),
              (u' The Euler-Cromer scheme ', 3, None, '___sec134'),
              (u' The 4-th order Runge-Kutta method ', 3, None, '___sec135'),
              (u' Illustration of linear damping ', 2, None, '___sec136'),
              (u' Illustration of linear damping with sinusoidal excitation ',
               2,
               None,
               '___sec137'),
              (u' Spring-mass system with sliding friction ',
               2,
               u'sec:de:vib:ode2:sliding:friction',
               u'sec:de:vib:ode2:sliding:friction'),
              (u' A finite difference method; undamped, linear case ',
               2,
               u'sec:de:vib:2nd',
               u'sec:de:vib:2nd'),
              (u' A finite difference method; linear damping ',
               2,
               u'sec:de:vib:2nd:damped1',
               u'sec:de:vib:2nd:damped1'),
              (u' Exercises ', 1, None, '___sec141'),
              (u' Exercise 38: Geometric construction of the Forward Euler method ',
               2,
               u'sec:de:exer:geom',
               u'sec:de:exer:geom'),
              (u' Exercise 39: Make test functions for the Forward Euler method ',
               2,
               u'sec:de:exer:FE:test1',
               u'sec:de:exer:FE:test1'),
              (u" Exercise 40: Implement and evaluate Heun's method ",
               2,
               u'sec:de:exer:Heun:pg',
               u'sec:de:exer:Heun:pg'),
              (u' Exercise 41: Find an appropriate time step; logistic model ',
               2,
               u'sec:de:exer:logistic:dtopt',
               u'sec:de:exer:logistic:dtopt'),
              (u' Exercise 42: Find an appropriate time step; SIR model ',
               2,
               u'sec:de:exer:SIR:dtopt',
               u'sec:de:exer:SIR:dtopt'),
              (u' Exercise 43: Model an adaptive vaccination campaign ',
               2,
               u'sec:de:exer:SIRV:padapt',
               u'sec:de:exer:SIRV:padapt'),
              (u' Exercise 44: Refactor a flat program ',
               2,
               u'sec:de:exer:vib:FE:func',
               u'sec:de:exer:vib:FE:func'),
              (u' Exercise 45: Simulate oscillations by a general ODE solver ',
               2,
               u'sec:de:exer:vib:ode_FE',
               u'sec:de:exer:vib:ode_FE'),
              (u' Exercise 46: Compute the energy in oscillations ',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u' Exercise 47: Use a Backward Euler scheme for population growth ',
               2,
               u'sec:de:exer:pg:BE',
               u'sec:de:exer:pg:BE'),
              (u' Exercise 48: Use a Crank-Nicolson scheme for population growth ',
               2,
               u'sec:de:exer:pg:CN',
               u'sec:de:exer:pg:CN'),
              (u' Exercise 49: Understand finite differences via Taylor series ',
               2,
               u'sec:de:exer:fd:Taylor',
               u'sec:de:exer:fd:Taylor'),
              (u' Exercise 50: Use a Backward Euler scheme for oscillations ',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u' Remarks ', 3, None, '___sec155'),
              (u" Exercise 51: Use Heun's method for the SIR model ",
               2,
               u'sec:de:exer:SIR:Heun',
               u'sec:de:exer:SIR:Heun'),
              (u' Exercise 52: Use Odespy to solve a simple ODE ',
               2,
               u'sec:de:exer:odespy:decay',
               u'sec:de:exer:odespy:decay'),
              (u' Exercise 53: Set up a Backward Euler scheme for oscillations ',
               2,
               u'sec:de:exer:osc:BE',
               u'sec:de:exer:osc:BE'),
              (u' Exercise 54: Set up a Forward Euler scheme for nonlinear and damped oscillations ',
               2,
               u'sec:de:exer:osc:FE:general',
               u'sec:de:exer:osc:FE:general'),
              (u' Exercise 55: Discretize an initial condition ',
               2,
               u'sec:de:exer:osc:2nd:V0ic',
               u'sec:de:exer:osc:2nd:V0ic'),
              (u' Solving Partial Differential Equations ',
               0,
               u'6th:SolvPDEs',
               u'6th:SolvPDEs'),
              (u' The Method of Lines combined with the Forward Euler scheme ',
               1,
               u'6th:SolvPDEs:MOLandFE',
               u'6th:SolvPDEs:MOLandFE'),
              (u' The Method of Lines combined with the Backward Euler scheme ',
               1,
               u'6th:SolvPDEs:MOLandBE',
               u'6th:SolvPDEs:MOLandBE'),
              (u' A glimpse of the Finite Element Method  ',
               1,
               u'6th:SolvPDEs:FEM',
               u'6th:SolvPDEs:FEM'),
              (u' Exercises ', 1, None, '___sec165'),
              (u' Exercise 56: Temperature distribution with forward Euler ',
               2,
               u'6th:exer:TempDistribFE',
               u'6th:exer:TempDistribFE'),
              (u' Exercise 57: Matrix-vector hand calculations ',
               2,
               u'6th:exer:MatrixVectorHandCalc',
               u'6th:exer:MatrixVectorHandCalc'),
              (u' Exercise 58: Temperature distribution with backward Euler ',
               2,
               u'6th:exer:tempDistribBE',
               u'6th:exer:tempDistribBE'),
              (u' Exercise 59: Temperature distribution with Crank-Nicolson ',
               2,
               u'6th:exer:tempDistribCN',
               u'6th:exer:tempDistribCN'),
              (u' Appendix: Taylor series approximation ',
               0,
               u'A:AppTaylor',
               u'A:AppTaylor'),
              (u' Appendix: Solving nonlinear algebraic equations ',
               0,
               u'4th:NonlinAlgEq',
               u'4th:NonlinAlgEq'),
              (u' Brute force method ',
               2,
               u'4th:bruteforce',
               u'4th:bruteforce'),
              (u' Model problem for algebraic equations ',
               2,
               None,
               '___sec173'),
              (u" Newton's method ",
               1,
               u'4th:NonlinAlgEq:Newt',
               u'4th:NonlinAlgEq:Newt'),
              (u' Making a more efficient and robust implementation ',
               2,
               u'4th:Newton:robust',
               u'4th:Newton:robust'),
              (u' The Secant method ',
               1,
               u'4th:NonlinAlgEq:Secant',
               u'4th:NonlinAlgEq:Secant'),
              (u' The Bisection method ',
               1,
               u'4th:NonlinAlgEq:Bisect',
               u'4th:NonlinAlgEq:Bisect'),
              (u' Rate of convergence ',
               1,
               u'4th:NonlinAlgEq:RateConv',
               u'4th:NonlinAlgEq:RateConv'),
              (u' Solving multiple nonlinear algebraic equations ',
               1,
               u'4th:NonlinAlgEq:MultEqNewt',
               u'4th:NonlinAlgEq:MultEqNewt'),
              (u' Exercises ', 1, None, '___sec180'),
              (u' Exercise 60: Brute force solver based on zero crossings ',
               2,
               u'4th:exer:crossings',
               u'4th:exer:crossings'),
              (u" Exercise 61: Understand why Newton's method can fail ",
               2,
               u'4th:exer:Newton:failure',
               u'4th:exer:Newton:failure'),
              (u' Exercise 62: See if the Secant method fails ',
               2,
               u'4th:exer:Secant:failure',
               u'4th:exer:Secant:failure'),
              (u' Exercise 63: Understand how the Bisection method cannot fail ',
               2,
               u'4th:exer:Bisection:failure',
               u'4th:exer:Bisection:failure'),
              (u" Exercise 64: Combine the Bisection method with Newton's method ",
               2,
               u'4th:exer:Bisection:Newton',
               u'4th:exer:Bisection:Newton'),
              (u' Exercise 65: Straight line crossing (Bisection method) ',
               2,
               u'4th:exer:straightLineCrossing',
               u'4th:exer:straightLineCrossing'),
              (u" Exercise 66: Newton's method by hand ",
               2,
               u'4th:exer:NewtonHand',
               u'4th:exer:NewtonHand'),
              (u" Exercise 67: Intersecting graphs (Newton's method) ",
               2,
               u'4th:exer:intersectingGraphsNewton',
               u'4th:exer:intersectingGraphsNewton'),
              (u' Exercise 68: Finding many solutions ',
               2,
               u'4th:exer:findingManySolutions',
               u'4th:exer:findingManySolutions'),
              (u' Exercise 69: Combining Bisection and Newton ',
               2,
               u'4th:exer:combBisectNewt',
               u'4th:exer:combBisectNewt'),
              (u" Exercise 70: Timing Newton's method ",
               2,
               u'4th:exer:timingNewton',
               u'4th:exer:timingNewton'),
              (u' Exercise 71: Problematic starting value ',
               2,
               u'4th:exer:problemStartVal',
               u'4th:exer:problemStartVal'),
              (u' Exercise 72: Secant method by hand ',
               2,
               u'4th:exer:secantHand',
               u'4th:exer:secantHand'),
              (u' Exercise 73: Intersecting graphs (Secant method) ',
               2,
               u'4th:exer:intersectingGraphsSecant',
               u'4th:exer:intersectingGraphsSecant'),
              (u' Exercise 74: Two nonlinear equations ',
               2,
               u'4th:exer:twoNonlinEqns',
               u'4th:exer:twoNonlinEqns'),
              (u' Exercise 75: Fixed point iteration ',
               2,
               u'4th:exer:fixedPointIt',
               u'4th:exer:fixedPointIt'),
              (u' References ', 0, None, '___sec197')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    
<a name="part0030"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._p4c-solarized-Matlab029.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._p4c-solarized-Matlab031.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1>The Bisection method <a name="4th:NonlinAlgEq:Bisect"></a></h1>

<p>
Neither Newton's method nor the Secant method can guarantee that an
existing solution will be found (see <a href="._p4c-solarized-Matlab033.html#4th:exer:Newton:failure">Exercise 61: Understand why Newton's method can fail</a> and <a href="._p4c-solarized-Matlab033.html#4th:exer:Secant:failure">Exercise 62: See if the Secant method fails</a>). The
Bisection method, however, does that. However, if there are several
solutions present, it finds only one of them, just as Newton's method
and the Secant method.  The Bisection method is slower than the other
two methods, so reliability comes with a cost of speed.

<p>
To solve \( x^2 - 9 = 0 \), \( x \in \left[0, 1000\right] \) with the
Bisection method, we reason as follows.  The first key idea is that if \( f(x)
= x^2 - 9 \) is <em>continuous</em> on the interval and the function values for
the interval endpoints (\( x_L = 0 \), \( x_R =1000 \)) have <em>opposite signs</em>,
\( f(x) \) <em>must</em> cross the \( x \) axis at least once on the interval. That
is, we know there is at least one solution.

<p>
The second key idea comes from dividing the interval in two equal
parts, one to the left and one to the right of the midpoint \( x_M =
500 \). By evaluating the sign of \( f(x_M) \), we will immediately know
whether a solution must exist to the left or right of \( x_M \). This is
so, since if \( f(x_M) \ge 0 \), we know that \( f(x) \) has to cross the \( x \)
axis between \( x_L \) and \( x_M \) at least once (using the same
argument as for the original interval). Likewise, if instead \( f(x_M)
\le 0 \), we know that \( f(x) \) has to cross the \( x \) axis between \( x_M \)
and \( x_R \) at least once.

<p>
In any case, we may proceed with half the interval only. The exception
is if \( f(x_M) \approx 0 \), in which case a solution is found. Such
interval halving can be continued until a solution is found. A
"solution" in this case, is when \( |f(x_M)| \) is sufficiently close to
zero, more precisely (as before): \( |f(x_M)| < \epsilon \), where
\( \epsilon \) is a small number specified by the user.

<p>
The sketched strategy seems reasonable, so let us write a program that
solves the equation this way (<code>bisection_method.m</code>):

<p>
<!-- begin verbatim block  mpro-->
<pre><code>function bisection_method()
    f = @(x) x^2 - 9;
    eps = 1e-6;
    a = 0;   b = 1000;
    [solution, no_iterations] = bisection(f, a, b, eps);
    if solution &lt;= b   %solution found
        fprintf('Number of function calls: %d\n',1+2*no_iterations);
        fprintf('A solution is: %f\n',solution);
    else
        fprintf('Abort execution.\n');
    end
end

function [result1, result2] = bisection(f, x_L, x_R, eps)
    if f(x_L)*f(x_R) &gt; 0
        fprintf('Error! Function does not have opposite\n');
        fprintf('signs at interval endpoints!')
        exit(1)
    end
    x_M = (x_L + x_R)/2.0;
    f_M = f(x_M);
    iteration_counter = 1;
    while abs(f_M) &gt; eps
        left_f = f(x_L);
        right_f = f(x_R);
        if left_f*f_M &gt; 0   %i.e. same sign
            x_L = x_M;
        else
            x_R = x_M;
        end
        x_M = (x_L + x_R)/2;
        f_M = f(x_M);
        iteration_counter = iteration_counter + 2;
    end
    result1 = x_M;
    result2 = iteration_counter;
end
</code></pre>
<!-- end verbatim block -->

<p>
Note that we first check if \( f \) changes sign in \( [a,b] \), because that
is a requirement for the algorithm to work. The algorithm also relies
on a continuous \( f(x) \) function, but this is very challenging
for computer code to check.

<p>
We get the following printout to the screen when <code>bisection_method.m</code> is run:

<p>
<!-- begin verbatim block  dat-->
<pre><code>Number of function calls: 61
A solution is: 3.000000
</code></pre>
<!-- end verbatim block -->
As expected, the number of function calls is much higher than with the previous methods.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Required work in the Bisection method.</b>
<p>
If the starting interval of the Bisection method is bounded by \( a \) and
\( b \), and the solution at step \( n \) is taken to be the middle value, the
error is bounded as

$$
\begin{equation}
\frac{|b-a|}{2^n},
\tag{157}
\end{equation}
$$

because the initial interval has been halved \( n \) times.
Therefore, to meet a tolerance \( \epsilon \), we need \( n \) iterations such that
the length of the current interval equals \( \epsilon \):

$$ \frac{|b-a|}{2^n}=\epsilon\quad\Rightarrow\quad
n = \frac{\ln ((b-a)/\epsilon)}{\ln 2}\thinspace .
$$

This is a great advantage of the Bisection method: we know beforehand
how many iterations \( n \) it takes to meet a certain accuracy
\( \epsilon \) in the solution.
</div>


<p>
As with the two previous methods, the function <code>bisection</code> is
stored as a separate file <code>bisection.m</code> for easy use by other programs.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._p4c-solarized-Matlab029.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._p4c-solarized-Matlab031.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

