<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Programming for Computations - A Gentle Introduction to Numerical Simulations with Python">
<meta name="keywords" content="computer program,programming,language programming,language computer,MATLAB,Octave,Fortran,C,C++,Python,Maple,Mathematica,syntax,bug,debugging,script (and scripting),implement,print,program run,program execute,code,comment,instruction,program statement,variable,assignment,calculator,text editor,Idle,prompt,program typing,program run,program execute,ipython,function,function call,atan,function input parameter,function output parameter,function return,function take a parameter,library,library function,from,import,math,module,package,linspace,xlabel,ylabel,plot,interactive use (of Python),import,keyboard arrow up/down,Python shell,operator Arithmetic,parentheses,variable type,variable name,object,float,int,str,type conversion,reserved words,variable int,variable float,variable str,variable assignment,type conversion automatic,integer division,round-off error,printing formatted,printf formatting,default,array,array element,zeros,allocate,array index,indexing zero based,indexing one based,Python zero-based indexing,array slice of,graph,hold (on/off),plot figure,title,legend,axis,hardcopy,format png,matrix mat,matrix vector product,transpose,linear algebra,matrix,vector,error message,debugging,debugger,try-exception,exception handling,program crash,program testing,program verification,program input,program output,input,raw input,list,tuple,symbolic computations,symbolic operations,symbolic simplifications,SymPy,library SymPy,WolframAlpha,Mathematica,Sage (symbolic package),Python documentation,garbage collection,variable delete,if,elif,else,colon,indent,boolean,boolean expression,True,False,boolean True,boolean False,pseudo code,operator Logical,function,function definition,def,return,argument,parameter input,parameter output,variable local,variable global,argument keyword,argument named,argument ordinary,argument positional,doc string,function handle,function local,function global,function nested,lambda function,loop for,for loop,range,loop iteration,loop index,loop double,loop multiple,loop nested,linear algebra,while loop,loop while,loop infinite,loop iteration,loop index,list,list append,list convert to array,list delete,list create,tuple,list comprehension,array sorting,Leibniz pi,Euler pi,programming game,linear interpolation,least squares method,Fourier series,integral analytically,integral exact,integral approximately,integration points,code re-use,unit tests,complex domains,Monte Carlo integration,seed (random generators),scheme,finite difference method,forward difference approximation,Forward Euler scheme,logistic model,carrying capacity,SIR model,scalar ODE,ODE scalar,vector ODE,ODE vector,system of ODEs,Heun's method,Runge-Kutta, 2nd-order method,2nd-order Runge-Kutta method,RK2,PDE,heat equation,diffusion equation,MOL forward Euler,method of lines,MOL,mesh points,cell,method of lines,unstable solutions,instability,stability criterion,Poisson equation,Laplace equation,root finding,code robust,code try-except,code exception,Newton starting value,return None,sys.exit,Idle,Emacs,Vim,Gedit,TextWrangler,Notepad++">

<title>Programming for Computations - A Gentle Introduction to Numerical Simulations with Python</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Let pre tags for code blocks have the same color as the surroundings */
pre { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u' Preface ', 0, None, '___sec0'),
              (u' Why learn programming? ', 3, None, '___sec1'),
              (u' Target audience and background knowledge ',
               3,
               None,
               '___sec2'),
              (u' Numerical methods ', 3, None, '___sec3'),
              (u' The computer language: Python ', 3, None, '___sec4'),
              (u' How this book is different ', 3, None, '___sec5'),
              (u' Acknowledgments ', 3, None, '___sec6'),
              (u' The first few steps ',
               0,
               u'1st:TheFirstFewSteps',
               u'1st:TheFirstFewSteps'),
              (u' What is a program? And what is programming? ',
               1,
               None,
               '___sec8'),
              (u' A Python program with variables ',
               1,
               u'1st:ex1',
               u'1st:ex1'),
              (u' The program ', 2, None, '___sec10'),
              (u' Dissection of the program ', 2, None, '___sec11'),
              (u' Why not just use a pocket calculator? ',
               2,
               None,
               '___sec12'),
              (u' The importance of using a text editor to write programs ',
               2,
               None,
               '___sec13'),
              (u' Installation of Python ', 2, None, '___sec14'),
              (u' Write and run your first program ', 2, None, '___sec15'),
              (u'  A Python program with a library function ',
               1,
               u'1st:ex2',
               u'1st:ex2'),
              (u' A Python program with vectorization and plotting ',
               1,
               u'1st:ex3',
               u'1st:ex3'),
              (u' More basic concepts ', 1, None, '___sec18'),
              (u' Using Python interactively ', 2, None, '___sec19'),
              (u' Arithmetics, parentheses and round-off errors ',
               2,
               None,
               '___sec20'),
              (u' Variables and objects ', 2, None, '___sec21'),
              (u' Integer division ', 2, None, '___sec22'),
              (u' Formatting text and numbers ', 2, None, '___sec23'),
              (u' Arrays ', 2, None, '___sec24'),
              (u' Plotting ', 2, None, '___sec25'),
              (u' Error messages and warnings ', 2, None, '___sec26'),
              (u' Input data ', 2, None, '___sec27'),
              (u' Symbolic computations ', 2, None, '___sec28'),
              (u' Concluding remarks ', 2, None, '___sec29'),
              (u' Exercises ', 1, None, '___sec30'),
              (u' Exercise 1: Error messages ',
               2,
               u'1st:exer:ErrorMessages',
               u'1st:exer:ErrorMessages'),
              (u' Exercise 2: Volume of a cube ',
               2,
               u'1st:exer:cubeVolume',
               u'1st:exer:cubeVolume'),
              (u' Exercise 3: Area and circumference of a circle ',
               2,
               u'1st:exer:areaCircle',
               u'1st:exer:areaCircle'),
              (u' Exercise 4: Volumes of three cubes ',
               2,
               u'1st:exer:volumes3cubes',
               u'1st:exer:volumes3cubes'),
              (u' Exercise 5: Average of integers ',
               2,
               u'1st:exer:averageOf5Integers',
               u'1st:exer:averageOf5Integers'),
              (u' Exercise 6: Interactive computing of volume and area ',
               2,
               u'1st:exer:cubeVolInteractively',
               u'1st:exer:cubeVolInteractively'),
              (u' Exercise 7: Peculiar results from division ',
               2,
               u'1st:exer:intDivInteractively',
               u'1st:exer:intDivInteractively'),
              (u' Exercise 8: Update variable at command prompt ',
               2,
               u'1st:exer:updateVarInteractively',
               u'1st:exer:updateVarInteractively'),
              (u' Exercise 9: Formatted print to screen ',
               2,
               u'1st:exer:printfScreen',
               u'1st:exer:printfScreen'),
              (u' Exercise 10: Python documentation and random numbers ',
               2,
               u'1st:exer:PythonDocRandom',
               u'1st:exer:PythonDocRandom'),
              (u' Basic constructions ',
               0,
               u'2nd:BasicConstructins',
               u'2nd:BasicConstructins'),
              (u' If tests, colon and indentation ', 1, None, '___sec42'),
              (u' Functions ', 1, u'sec:functions', u'sec:functions'),
              (u' For loops ', 1, u'sec:for:loops', u'sec:for:loops'),
              (u' While loops ', 1, u'sec:while:loops', u'sec:while:loops'),
              (u' Lists and tuples - alternatives to arrays ',
               1,
               u'sec:lists',
               u'sec:lists'),
              (u' Reading from and writing to files ',
               1,
               u'sec:file:reading:writing',
               u'sec:file:reading:writing'),
              (u' Exercises ', 1, None, '___sec48'),
              (u' Exercise 11: Errors with colon, indent, etc. ',
               2,
               u'2nd:exer:ErrorsColonIndent',
               u'2nd:exer:ErrorsColonIndent'),
              (u' Exercise 12: Compare integers a and b ',
               2,
               u'2nd:exer:compInt',
               u'2nd:exer:compInt'),
              (u' Exercise 13: Functions for circumference and area of a circle ',
               2,
               u'2nd:exer:funcCircArea',
               u'2nd:exer:funcCircArea'),
              (u' Exercise 14: Function for area of a rectangle ',
               2,
               u'2nd:exer:funcAreaRectangle',
               u'2nd:exer:funcAreaRectangle'),
              (u' Exercise 15: Area of a polygon ',
               2,
               u'2nd:exer:area:polygon',
               u'2nd:exer:area:polygon'),
              (u' Exercise 16: Average of integers ',
               2,
               u'2nd:exer:avNInt',
               u'2nd:exer:avNInt'),
              (u' Exercise 17: While loop with errors ',
               2,
               u'2nd:exer:whileLoopErrors',
               u'2nd:exer:whileLoopErrors'),
              (u' Exercise 18: Area of rectangle versus circle ',
               2,
               u'2nd:exer:areaRectCircle',
               u'2nd:exer:areaRectCircle'),
              (u' Exercise 19: Find crossing points of two graphs ',
               2,
               u'2nd:exer:Cross2Graphs',
               u'2nd:exer:Cross2Graphs'),
              (u' Exercise 20: Sort array with numbers ',
               2,
               u'2nd:exer:sortNumbers',
               u'2nd:exer:sortNumbers'),
              (u' Exercise 21: Compute $\\pi$ ',
               2,
               u'2nd:exer:computingPi',
               u'2nd:exer:computingPi'),
              (u' Exercise 22: Compute combinations of sets ',
               2,
               u'2nd:exer:combinatorics1',
               u'2nd:exer:combinatorics1'),
              (u' Exercise 23: Frequency of random numbers ',
               2,
               u'2nd:exer:numberOccurrence',
               u'2nd:exer:numberOccurrence'),
              (u' Remarks ', 3, None, '___sec62'),
              (u' Exercise 24: Game 21 ',
               2,
               u'2nd:exer:Game21',
               u'2nd:exer:Game21'),
              (u' Exercise 25: Linear interpolation ',
               2,
               u'2nd:exer:linearInterpol',
               u'2nd:exer:linearInterpol'),
              (u' Exercise 26: Test straight line requirement ',
               2,
               u'2nd:exer:testStraightLine',
               u'2nd:exer:testStraightLine'),
              (u' Exercise 27: Fit straight line to data ',
               2,
               u'2nd:exer:fitLine',
               u'2nd:exer:fitLine'),
              (u' Remarks ', 3, None, '___sec67'),
              (u' Exercise 28: Fit sines to straight line ',
               2,
               u'2nd:exer:fitSines',
               u'2nd:exer:fitSines'),
              (u' Remarks ', 3, None, '___sec69'),
              (u' Exercise 29: Count occurrences of a string in a string ',
               2,
               u'2nd:exer:countTextString',
               u'2nd:exer:countTextString'),
              (u' Remarks ', 3, None, '___sec71'),
              (u' Computing integrals ',
               0,
               u'sec:integrals',
               u'sec:integrals'),
              (u' Basic ideas of numerical integration ',
               1,
               u'sec:integrals:basic',
               u'sec:integrals:basic'),
              (u' Computational example ', 3, None, '___sec74'),
              (u' The composite trapezoidal rule ',
               1,
               u'sec:integrals:trap',
               u'sec:integrals:trap'),
              (u' The general formula ',
               2,
               u'sec:integrals:formula',
               u'sec:integrals:formula'),
              (u' Implementation ',
               2,
               u'sec:integrals:trap:impl',
               u'sec:integrals:trap:impl'),
              (u' Specific or general implementation? ', 3, None, '___sec78'),
              (u' Implementation with functions ', 3, None, '___sec79'),
              (u' Solving our specific problem in a session ',
               3,
               None,
               '___sec80'),
              (u' Solving our specific problem in a program ',
               3,
               None,
               '___sec81'),
              (u' Making a module ', 2, None, '___sec82'),
              (u' Alternative flat special-purpose implementation ',
               2,
               None,
               '___sec83'),
              (u' The composite midpoint method ',
               1,
               u'sec:integrals:Midpoint',
               u'sec:integrals:Midpoint'),
              (u' The idea ', 3, None, '___sec85'),
              (u' The general formula ', 2, None, '___sec86'),
              (u' Implementation ',
               2,
               u'sec:midpoint:code',
               u'sec:midpoint:code'),
              (u' Comparing the trapezoidal and the midpoint methods ',
               2,
               None,
               '___sec88'),
              (u' Testing ', 1, None, '___sec89'),
              (u' Problems with brief testing procedures ',
               2,
               None,
               '___sec90'),
              (u' Test procedures ',
               2,
               u'sec:integrals:testprocs',
               u'sec:integrals:testprocs'),
              (u' Hand-computed results ', 3, None, '___sec92'),
              (u' Solving a problem without numerical errors ',
               3,
               None,
               '___sec93'),
              (u' Demonstrating correct convergence rates ',
               3,
               None,
               '___sec94'),
              (u' Constructing unit tests and writing test functions ',
               2,
               u'sec:integrals:test:functions',
               u'sec:integrals:test:functions'),
              (u' Hand-computed numerical results ', 3, None, '___sec96'),
              (u' Solving a problem without numerical errors ',
               3,
               None,
               '___sec97'),
              (u' Demonstrating correct convergence rates ',
               3,
               None,
               '___sec98'),
              (u' Vectorization ', 1, None, '___sec99'),
              (u' Vectorizing the midpoint rule ', 3, None, '___sec100'),
              (u' Vectorizing the trapezoidal rule ', 3, None, '___sec101'),
              (u' Measuring computational speed ', 1, None, '___sec102'),
              (u' Double and triple integrals ',
               1,
               u'sec:int:double',
               u'sec:int:double'),
              (u' The midpoint rule for a double integral ',
               2,
               u'sec:int:double:midpoint',
               u'sec:int:double:midpoint'),
              (u' Derivation via one-dimensional integrals ',
               3,
               None,
               '___sec105'),
              (u' Direct derivation ', 3, None, '___sec106'),
              (u' Programming a double sum ', 3, None, '___sec107'),
              (u' Reusing code for one-dimensional integrals ',
               3,
               None,
               '___sec108'),
              (u' Verification via test functions ', 3, None, '___sec109'),
              (u' The midpoint rule for a triple integral ',
               2,
               None,
               '___sec110'),
              (u' Theory ', 3, None, '___sec111'),
              (u' Implementation ', 3, None, '___sec112'),
              (u' Monte Carlo integration for complex-shaped domains ',
               2,
               u'sec:int:complex:domain',
               u'sec:int:complex:domain'),
              (u' The Monte Carlo integration algorithm ',
               3,
               None,
               '___sec114'),
              (u' Implementation ', 3, None, '___sec115'),
              (u' Verification ', 3, None, '___sec116'),
              (u' Test function for function with random numbers ',
               3,
               None,
               '___sec117'),
              (u' Integral over a circle ', 3, None, '___sec118'),
              (u' Exercises ', 1, None, '___sec119'),
              (u' Exercise 30: Hand calculations for the trapezoidal method ',
               2,
               u'sec:exer:trap:hand',
               u'sec:exer:trap:hand'),
              (u' Exercise 31: Hand calculations for the midpoint method ',
               2,
               u'sec:exer:midpt:hand',
               u'sec:exer:midpt:hand'),
              (u' Exercise 32: Compute a simple integral ',
               2,
               u'sec:exer:trap:mid:parabola',
               u'sec:exer:trap:mid:parabola'),
              (u' Exercise 33: Hand-calculations with sine integrals ',
               2,
               u'sec:exer:hand:sine',
               u'sec:exer:hand:sine'),
              (u' Exercise 34: Make test functions for the midpoint method ',
               2,
               u'sec:exer:test:midpoint',
               u'sec:exer:test:midpoint'),
              (u' Exercise 35: Explore round-off errors with large numbers ',
               2,
               u'sec:exer:test:roundoff',
               u'sec:exer:test:roundoff'),
              (u' Exercise 36: Write test functions for $\\int_0^4\\sqrt{x}dx$ ',
               2,
               u'sec:exer:test:convrates:sqrt',
               u'sec:exer:test:convrates:sqrt'),
              (u' Remarks ', 3, None, '___sec127'),
              (u' Exercise 37: Rectangle methods ',
               2,
               u'sec:exer:rectangleMethod',
               u'sec:exer:rectangleMethod'),
              (u' Exercise 38: Adaptive integration ',
               2,
               u'sec:exer:adaptive:int',
               u'sec:exer:adaptive:int'),
              (u' Remarks ', 3, None, '___sec130'),
              (u' Exercise 39: Integrating x raised to x ',
               2,
               u'sec:exer:integrate:x2x',
               u'sec:exer:integrate:x2x'),
              (u' Exercise 40: Integrate products of sine functions ',
               2,
               u'sec:exer:sine:products',
               u'sec:exer:sine:products'),
              (u' Exercise 41: Revisit fit of sines to a function ',
               2,
               u'sec:exer:revisitFitSines',
               u'sec:exer:revisitFitSines'),
              (u' Exercise 42: Derive the trapezoidal rule for a double integral ',
               2,
               u'sec:exer:trapezoidal:2D',
               u'sec:exer:trapezoidal:2D'),
              (u' Exercise 43: Compute the area of a triangle by Monte Carlo integration ',
               2,
               u'sec:exer:MC:ellipse',
               u'sec:exer:MC:ellipse'),
              (u' Solving ordinary differential equations ',
               0,
               u'5th:SolvODEs',
               u'5th:SolvODEs'),
              (u' Population growth ', 1, u'sec:de:pg', u'sec:de:pg'),
              (u' Derivation of the model ',
               2,
               u'sec:de:pg:model',
               u'sec:de:pg:model'),
              (u' Numerical solution ',
               2,
               u'sec:de:pg:numerics',
               u'sec:de:pg:numerics'),
              (u' Programming the Forward Euler scheme; the special case ',
               2,
               u'sec:de:pg:prog1',
               u'sec:de:pg:prog1'),
              (u' Understanding the Forward Euler method ',
               2,
               u'sec:de:pg:geom',
               u'sec:de:pg:geom'),
              (u' Programming the Forward Euler scheme; the general case ',
               2,
               u'sec:de:FE:gen',
               u'sec:de:FE:gen'),
              (u' Making the population growth model more realistic ',
               2,
               None,
               '___sec143'),
              (u' Verification: exact linear solution of the discrete equations ',
               2,
               u'sec:de:growth:test:linear',
               u'sec:de:growth:test:linear'),
              (u' Spreading of diseases ', 1, None, '___sec145'),
              (u' Spreading of a flu ', 2, u'sec:de:flu', u'sec:de:flu'),
              (u' A Forward Euler method for the differential equation system ',
               2,
               u'sec:de:flu:FE',
               u'sec:de:flu:FE'),
              (u' Programming the numerical method; the special case ',
               2,
               u'sec:de:flu:prog:spec',
               u'sec:de:flu:prog:spec'),
              (u' Outbreak or not ', 2, None, '___sec149'),
              (u' Abstract problem and notation ',
               2,
               u'sec:de:flu:generic',
               u'sec:de:flu:generic'),
              (u' Programming the numerical method; the general case ',
               2,
               u'sec:de:flu:prog:generic',
               u'sec:de:flu:prog:generic'),
              (u' Time-restricted immunity ', 2, None, '___sec152'),
              (u' Incorporating vaccination ',
               2,
               u'sec:de:flu:vaccine',
               u'sec:de:flu:vaccine'),
              (u' Discontinuous coefficients: a vaccination campaign ',
               2,
               u'sec:de:flu:vaccine:discont',
               u'sec:de:flu:vaccine:discont'),
              (u' Oscillating one-dimensional systems ',
               1,
               u'sec:de:vib',
               u'sec:de:vib'),
              (u' Derivation of a simple model ', 2, None, '___sec156'),
              (u' Numerical solution ', 2, None, '___sec157'),
              (u' Programming the numerical method; the special case ',
               2,
               u'sec:de:vib:special',
               u'sec:de:vib:special'),
              (u' A magic fix of the numerical method ',
               2,
               None,
               '___sec159'),
              (u" The 2nd-order Runge-Kutta method (or Heun's method) ",
               2,
               u'sec:de:osc:Heun',
               u'sec:de:osc:Heun'),
              (u' Odespy: software for solving ODEs ',
               2,
               u'sec:de:osc:odespy',
               u'sec:de:osc:odespy'),
              (u' The 4th-order Runge-Kutta method ', 2, None, '___sec162'),
              (u' The algorithm ', 3, None, '___sec163'),
              (u' Application ', 3, None, '___sec164'),
              (u' Implementation ', 3, None, '___sec165'),
              (u' Derivation ', 3, None, '___sec166'),
              (u' More effects: damping, nonlinearity, and external forces ',
               2,
               None,
               '___sec167'),
              (u' The Euler-Cromer scheme ', 3, None, '___sec168'),
              (u' The 4-th order Runge-Kutta method ', 3, None, '___sec169'),
              (u' Illustration of linear damping ', 2, None, '___sec170'),
              (u' Illustration of linear damping with sinusoidal excitation ',
               2,
               None,
               '___sec171'),
              (u' Spring-mass system with sliding friction ',
               2,
               u'sec:de:vib:ode2:sliding:friction',
               u'sec:de:vib:ode2:sliding:friction'),
              (u' A finite difference method; undamped, linear case ',
               2,
               u'sec:de:vib:2nd',
               u'sec:de:vib:2nd'),
              (u' A finite difference method; linear damping ',
               2,
               u'sec:de:vib:2nd:damped1',
               u'sec:de:vib:2nd:damped1'),
              (u' Exercises ', 1, None, '___sec175'),
              (u' Exercise 44: Geometric construction of the Forward Euler method ',
               2,
               u'sec:de:exer:geom',
               u'sec:de:exer:geom'),
              (u' Exercise 45: Make test functions for the Forward Euler method ',
               2,
               u'sec:de:exer:FE:test1',
               u'sec:de:exer:FE:test1'),
              (u" Exercise 46: Implement and evaluate Heun's method ",
               2,
               u'sec:de:exer:Heun:pg',
               u'sec:de:exer:Heun:pg'),
              (u' Exercise 47: Find an appropriate time step; logistic model ',
               2,
               u'sec:de:exer:logistic:dtopt',
               u'sec:de:exer:logistic:dtopt'),
              (u' Exercise 48: Find an appropriate time step; SIR model ',
               2,
               u'sec:de:exer:SIR:dtopt',
               u'sec:de:exer:SIR:dtopt'),
              (u' Exercise 49: Model an adaptive vaccination campaign ',
               2,
               u'sec:de:exer:SIRV:padapt',
               u'sec:de:exer:SIRV:padapt'),
              (u' Exercise 50: Make a SIRV model with time-limited effect of vaccination ',
               2,
               u'sec:de:exer:SIRV:padapt',
               u'sec:de:exer:SIRV:padapt'),
              (u' Exercise 51: Refactor a flat program ',
               2,
               u'sec:de:exer:vib:FE:func',
               u'sec:de:exer:vib:FE:func'),
              (u' Exercise 52: Simulate oscillations by a general ODE solver ',
               2,
               u'sec:de:exer:vib:ode_FE',
               u'sec:de:exer:vib:ode_FE'),
              (u' Exercise 53: Compute the energy in oscillations ',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u' Exercise 54: Use a Backward Euler scheme for population growth ',
               2,
               u'sec:de:exer:pg:BE',
               u'sec:de:exer:pg:BE'),
              (u' Exercise 55: Use a Crank-Nicolson scheme for population growth ',
               2,
               u'sec:de:exer:pg:CN',
               u'sec:de:exer:pg:CN'),
              (u' Exercise 56: Understand finite differences via Taylor series ',
               2,
               u'sec:de:exer:fd:Taylor',
               u'sec:de:exer:fd:Taylor'),
              (u' Exercise 57: Use a Backward Euler scheme for oscillations ',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u' Remarks ', 3, None, '___sec190'),
              (u" Exercise 58: Use Heun's method for the SIR model ",
               2,
               u'sec:de:exer:SIR:Heun',
               u'sec:de:exer:SIR:Heun'),
              (u' Exercise 59: Use Odespy to solve a simple ODE ',
               2,
               u'sec:de:exer:odespy:decay',
               u'sec:de:exer:odespy:decay'),
              (u' Exercise 60: Set up a Backward Euler scheme for oscillations ',
               2,
               u'sec:de:exer:osc:BE',
               u'sec:de:exer:osc:BE'),
              (u' Exercise 61: Set up a Forward Euler scheme for nonlinear and damped oscillations ',
               2,
               u'sec:de:exer:osc:FE:general',
               u'sec:de:exer:osc:FE:general'),
              (u' Exercise 62: Discretize an initial condition ',
               2,
               u'sec:de:exer:osc:2nd:V0ic',
               u'sec:de:exer:osc:2nd:V0ic'),
              (u' Solving partial differential equations ',
               0,
               u'6th:SolvPDEs',
               u'6th:SolvPDEs'),
              (u' Finite difference methods ',
               1,
               u'6th:SolvPDEs:MOLandFE',
               u'6th:SolvPDEs:MOLandFE'),
              (u' Reduction of a PDE to a system of ODEs ',
               2,
               u'sec:pde:diff1D:reduce',
               u'sec:pde:diff1D:reduce'),
              (u' Construction of a test problem with known discrete solution ',
               2,
               u'sec:pde:diff1D:testproblem',
               u'sec:pde:diff1D:testproblem'),
              (u' Implementation: Forward Euler method ',
               2,
               None,
               '___sec200'),
              (u' Application: heat conduction in a rod ',
               2,
               u'sec:pde:diff1D:rod',
               u'sec:pde:diff1D:rod'),
              (u' Vectorization ', 2, None, '___sec202'),
              (u' Using Odespy to solve the system of ODEs ',
               2,
               None,
               '___sec203'),
              (u' Implicit methods ', 2, None, '___sec204'),
              (u' Exercises ', 1, None, '___sec205'),
              (u' Exercise 63: Simulate a diffusion equation by hand ',
               2,
               u'sec:pde:diff1D:exer:handFE',
               u'sec:pde:diff1D:exer:handFE'),
              (u' Exercise 64: Compute temperature variations in the ground ',
               2,
               u'sec:pde:diff1D:exer:groundtemp',
               u'sec:pde:diff1D:exer:groundtemp'),
              (u' Exercise 65: Compare implicit methods ',
               2,
               u'sec:pde:diff1D:exer:compare:implicit',
               u'sec:pde:diff1D:exer:compare:implicit'),
              (u' Exercise 66: Explore adaptive and implicit methods ',
               2,
               u'sec:pde:diff1D:exer:groundtemp:adapt',
               u'sec:pde:diff1D:exer:groundtemp:adapt'),
              (u' Exercise 67: Investigate the $\\theta$ rule ',
               2,
               u'sec:pde:diff1D:exer:CN',
               u'sec:pde:diff1D:exer:CN'),
              (u' Remarks ', 3, None, '___sec211'),
              (u' Exercise 68: Compute the diffusion of a Gaussian peak ',
               2,
               u'sec:pde:diff1D:exer:Gaussian',
               u'sec:pde:diff1D:exer:Gaussian'),
              (u' Exercise 69: Vectorize a function for computing the area of a polygon ',
               2,
               u'2nd:exer:area:polygon2',
               u'2nd:exer:area:polygon2'),
              (u' Exercise 70: Explore symmetry ',
               2,
               u'sec:pde:diff1D:exer:Gaussian:symm',
               u'sec:pde:diff1D:exer:Gaussian:symm'),
              (u' Remarks ', 3, None, '___sec215'),
              (u' Exercise 71: Compute solutions as $t\\rightarrow\\infty$ ',
               2,
               u'sec:pde:diff1D:exer:stationary',
               u'sec:pde:diff1D:exer:stationary'),
              (u' Remarks ', 3, None, '___sec217'),
              (u' Exercise 72: Solve a two-point boundary value problem ',
               2,
               u'sec:pde:diff1D:exer:stationary2',
               u'sec:pde:diff1D:exer:stationary2'),
              (u' Solving nonlinear algebraic equations ',
               0,
               u'4th:NonlinAlgEq',
               u'4th:NonlinAlgEq'),
              (u' Brute force methods ',
               1,
               u'4th:bruteforce',
               u'4th:bruteforce'),
              (u' Brute force root finding ', 2, None, '___sec221'),
              (u' Numerical algorithm ', 3, None, '___sec222'),
              (u' Implementation ', 3, None, '___sec223'),
              (u' Brute force optimization ', 2, None, '___sec224'),
              (u' Numerical algorithm ', 3, None, '___sec225'),
              (u' Implementation ', 3, None, '___sec226'),
              (u' Model problem for algebraic equations ',
               2,
               None,
               '___sec227'),
              (u" Newton's method ",
               1,
               u'4th:NonlinAlgEq:Newt',
               u'4th:NonlinAlgEq:Newt'),
              (u" Deriving and implementing Newton's method ",
               2,
               None,
               '___sec229'),
              (u' Making a more efficient and robust implementation ',
               2,
               u'4th:Newton:robust',
               u'4th:Newton:robust'),
              (u' The secant method ',
               1,
               u'4th:NonlinAlgEq:Secant',
               u'4th:NonlinAlgEq:Secant'),
              (u' The bisection method ',
               1,
               u'4th:NonlinAlgEq:Bisect',
               u'4th:NonlinAlgEq:Bisect'),
              (u' Rate of convergence ',
               1,
               u'4th:NonlinAlgEq:RateConv',
               u'4th:NonlinAlgEq:RateConv'),
              (u' Exercises ', 1, None, '___sec234'),
              (u" Exercise 73: Understand why Newton's method can fail ",
               2,
               u'4th:exer:Newton:failure',
               u'4th:exer:Newton:failure'),
              (u' Exercise 74: See if the secant method fails ',
               2,
               u'4th:exer:Secant:failure',
               u'4th:exer:Secant:failure'),
              (u' Exercise 75: Understand how the bisection method cannot fail ',
               2,
               u'4th:exer:Bisection:failure',
               u'4th:exer:Bisection:failure'),
              (u" Exercise 76: Combine the bisection method with Newton's method ",
               2,
               u'4th:exer:Bisection:Newton',
               u'4th:exer:Bisection:Newton'),
              (u" Exercise 77: Write a test function for Newton's method ",
               2,
               u'4th:exer:NewtonHand',
               u'4th:exer:NewtonHand'),
              (u' Exercise 78: Solve nonlinear equation for a vibrating beam ',
               2,
               u'4th:exer:beam:vib',
               u'4th:exer:beam:vib'),
              (u' Appendix: Getting access to Python ',
               0,
               u'app:accesspy',
               u'app:accesspy'),
              (u' Required software ',
               1,
               u'sec:accesspy:softwarelist',
               u'sec:accesspy:softwarelist'),
              (u' Installing software on your laptop: Mac OS X and Windows ',
               1,
               u'sec:accesspy:MacWin',
               u'sec:accesspy:MacWin'),
              (u' Anaconda and Spyder ',
               1,
               u'sec:accesspy:anaconda',
               u'sec:accesspy:anaconda'),
              (u' Spyder on Mac ', 2, None, '___sec245'),
              (u' Installation of additional packages ',
               2,
               None,
               '___sec246'),
              (u' Installing SciTools on Mac ', 2, None, '___sec247'),
              (u' Installing SciTools on Windows ', 2, None, '___sec248'),
              (u' VMWare Fusion virtual machine ',
               1,
               u'sec:accesspy:vmware',
               u'sec:accesspy:vmware'),
              (u' Installing Ubuntu ',
               2,
               u'sec:accesspy:vmware:fullblown:machine',
               u'sec:accesspy:vmware:fullblown:machine'),
              (u' Installing software on Ubuntu ', 2, None, '___sec251'),
              (u' File sharing ', 2, None, '___sec252'),
              (u' Dual boot on Windows ', 1, None, '___sec253'),
              (u' Vagrant virtual machine ',
               1,
               u'sec:accesspy:vagrant',
               u'sec:accesspy:vagrant'),
              (u' How to write and run a Python program ',
               1,
               u'sec:accesspy:writerun',
               u'sec:accesspy:writerun'),
              (u' The need for a text editor ', 2, None, '___sec256'),
              (u' Spyder ', 2, None, '___sec257'),
              (u' Text editors ', 2, None, '___sec258'),
              (u' Terminal windows ', 2, None, '___sec259'),
              (u' Using a plain text editor and a terminal window ',
               2,
               None,
               '___sec260'),
              (u' The SageMathCloud and Wakari web services ',
               1,
               u'sec:accesspy:sagemath:wakari',
               u'sec:accesspy:sagemath:wakari'),
              (u' Basic intro to SageMathCloud ', 2, None, '___sec262'),
              (u' Basic intro to Wakari ', 2, None, '___sec263'),
              (u' Installing your own Python packages ',
               2,
               None,
               '___sec264'),
              (u' Writing IPython notebooks ',
               1,
               u'sec:accesspy:ipynb',
               u'sec:accesspy:ipynb'),
              (u' A simple program in the notebook ', 2, None, '___sec266'),
              (u' Mixing text, mathematics, code, and graphics ',
               2,
               None,
               '___sec267'),
              (u' References ', 0, None, '___sec268')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="p4c-bootstrap-Python.html">Programming for Computations - A Gentle Introduction to Numerical Simulations with Python</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python000.html#___sec0" style="font-size: 80%;">Preface</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#1st:TheFirstFewSteps" style="font-size: 80%;">The first few steps</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#2nd:BasicConstructins" style="font-size: 80%;">Basic constructions</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python013.html#sec:integrals" style="font-size: 80%;">Computing integrals</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python017.html#5th:SolvODEs" style="font-size: 80%;">Solving ordinary differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#6th:SolvPDEs" style="font-size: 80%;">Solving partial differential equations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python024.html#4th:NonlinAlgEq" style="font-size: 80%;">Solving nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python030.html#app:accesspy" style="font-size: 80%;">Appendix: Getting access to Python</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python039.html#___sec268" style="font-size: 80%;">References</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0020"></a>
<!-- !split -->

<h1 id="sec:de:vib">Oscillating one-dimensional systems</h1>

<p>
Numerous engineering constructions and devices contain materials
that act like springs. Such springs give rise to oscillations, and
controlling oscillations is a key engineering task. We shall now
learn to simulate oscillating systems.

<p>
As always, we start with the simplest meaningful mathematical
model, which for oscillations is a second-order differential equation:

$$
\begin{equation}
u''(t) + \omega^2 u(t) = 0,
\tag{45}
\end{equation}
$$

where \( \omega \) is a given physical parameter. Equation <a href="#mjx-eqn-45">(45)</a>
models a one-dimensional system oscillating without damping
(i.e., with negligible damping). One-dimensional here means that some
motion takes place along one dimension only in some coordinate system.
Along with <a href="#mjx-eqn-45">(45)</a> we need the two <em>initial conditions</em>
\( u(0) \) and \( u'(0) \).

<h2 id="___sec156">Derivation of a simple model </h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 34:  Sketch of a one-dimensional, oscillating dynamic system (without friction). <div id="sec:de:vib:ode1:fig1"></div> </p></center>
<p><img src="figs/oscillator_spring.png" align="bottom" width=600></p>
</center>

<p>
Many engineering systems undergo oscillations, and differential
equations constitute the key tool to understand, predict, and control the
oscillations.  We start with the simplest possible model that
captures the essential dynamics of an oscillating system. Some body
with mass \( m \) is attached to a spring and moves along a line
without friction, see Figure <a href="#sec:de:vib:ode1:fig1">34</a>
for a sketch (rolling wheels
indicate &quot;no friction&quot;).
When the spring is stretched (or compressed), the spring force pulls (or pushes) the body back and work
&quot;against&quot; the motion. More precisely, let \( x(t) \) be the position of
the body on the \( x \) axis, along which the body moves. The spring is
not stretched when \( x=0 \), so the force is zero, and \( x=0 \) is hence
the equilibrium position of the body. The spring force is \( -kx \),
where \( k \) is a constant to be measured. We assume that there are no
other forces (e.g., no friction). Newton's 2nd law of motion \( F=ma \)
then has \( F=-kx \) and \( a=\ddot x \),

$$
\begin{equation}
-kx = m\ddot x,
\tag{46}
\end{equation}
$$

which can be rewritten as

$$
\begin{equation}
x'' + \omega^2x = 0,
\tag{47}
\end{equation}
$$

by introducing \( \omega = \sqrt{k/m} \) (which is very common).

<p>
Equation <a href="#mjx-eqn-47">(47)</a>
is a <em>second-order</em> differential equation, and therefore we need
<em>two</em> initial conditions, one on the position \( x(0) \) and one on the
velocity \( x'(0) \). Here we choose the body to be at rest, but
moved away from its equilibrium position:

$$ x(0)=X_0,\quad x'(0)=0\thinspace . $$

The exact solution of <a href="#mjx-eqn-47">(47)</a> with these initial
conditions is \( x(t)=X_0\cos\omega t \). This can easily be verified by
substituting into <a href="#mjx-eqn-47">(47)</a> and checking the initial
conditions. The solution tells that such a spring-mass system
oscillates back and forth as described by a cosine curve.

<p>
The differential equation <a href="#mjx-eqn-47">(47)</a> appears in numerous
other contexts. A classical example is a simple pendulum that
oscillates back and forth. Physics books derive, from Newton's second law
of motion, that

$$ mL\theta'' + mg\sin \theta = 0,$$

where \( m \) is the mass of the body at the end of a pendulum with length \( L \),
\( g \) is the acceleration of gravity, and \( \theta \) is the angle the pendulum makes
with the vertical. Considering small angles \( \theta \), \( \sin \theta\approx \theta \),
and we get <a href="#mjx-eqn-47">(47)</a> with \( x=\theta \), \( \omega = \sqrt{g/L} \),
\( x(0)=\Theta \), and \( x'(0)=0 \), if \( \Theta \) is the initial angle and the
pendulum is at rest at \( t=0 \).

<h2 id="___sec157">Numerical solution </h2>

<p>
We have not looked at numerical methods for handling second-order
derivatives, and such methods are an option, but we know how to solve
first-order differential equations and even systems of first-order
equations. With a little, yet very common, trick we can rewrite
<a href="#mjx-eqn-47">(47)</a> as a first-order system of two differential
equations. We introduce \( u=x \) and \( v=x'=u' \) as <em>two</em> new unknown functions.
The two corresponding equations arise from the definition \( v=u' \) and
the original equation <a href="#mjx-eqn-47">(47)</a>:

$$
\begin{align}
u' &= v,
\tag{48} \\ 
v' &= -\omega^2 u\thinspace .
\tag{49}
\end{align}
$$

(Notice that we can use \( u''=v' \) to remove the second-order derivative from
Newton's 2nd law.)

<p>
We can now apply the Forward Euler method to
<a href="#mjx-eqn-48">(48)</a>-<a href="#mjx-eqn-49">(49)</a>,
exactly as we did in the section <a href="._p4c-bootstrap-Python019.html#sec:de:flu:FE">A Forward Euler method for the differential equation system</a>:

$$
\begin{align}
\frac{u^{n+1}-u^n}{\Delta t} &= v^n,
\tag{50} \\ 
\frac{v^{n+1}-v^n}{\Delta t}  &= -\omega^2 u^n,
\tag{51}
\end{align}
$$

resulting in the computational scheme

$$
\begin{align}
u^{n+1} &= u^n + \Delta t\,v^n,
\tag{52} \\ 
v^{n+1} &= v^n -\Delta t\,\omega^2 u^n\thinspace .
\tag{53}
\end{align}
$$

<h2 id="sec:de:vib:special">Programming the numerical method; the special case</h2>

<p>
A simple program for <a href="#mjx-eqn-52">(52)</a>-<a href="#mjx-eqn-53">(53)</a>
follows the same ideas as in the section <a href="._p4c-bootstrap-Python019.html#sec:de:flu:prog:spec">Programming the numerical method; the special case</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> zeros, linspace, pi, cos, array
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>

omega <span style="color: #666666">=</span> <span style="color: #666666">2</span>
P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>omega
dt <span style="color: #666666">=</span> P<span style="color: #666666">/20</span>
T <span style="color: #666666">=</span> <span style="color: #666666">3*</span>P
N_t <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, N_t<span style="color: #666666">*</span>dt, N_t<span style="color: #666666">+1</span>)

u <span style="color: #666666">=</span> zeros(N_t<span style="color: #666666">+1</span>)
v <span style="color: #666666">=</span> zeros(N_t<span style="color: #666666">+1</span>)

<span style="color: #408080; font-style: italic"># Initial condition</span>
X_0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>
u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> X_0
v[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

<span style="color: #408080; font-style: italic"># Step equations forward in time</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_t):
    u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>v[n]
    v[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> v[n] <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>omega<span style="color: #666666">**2*</span>u[n]

fig <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>figure()
l1, l2 <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>plot(t, u, <span style="color: #BA2121">&#39;b-&#39;</span>, t, X_0<span style="color: #666666">*</span>cos(omega<span style="color: #666666">*</span>t), <span style="color: #BA2121">&#39;r--&#39;</span>)
fig<span style="color: #666666">.</span>legend((l1, l2), (<span style="color: #BA2121">&#39;numerical&#39;</span>, <span style="color: #BA2121">&#39;exact&#39;</span>), <span style="color: #BA2121">&#39;upper left&#39;</span>)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
plt<span style="color: #666666">.</span>show()
plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>); plt<span style="color: #666666">.</span>savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>)
</pre></div>
<p>
(See file <a href="https://github.com/hplgit/prog4comp/src/py/osc_FE.py" target="_self"><tt>osc_FE.py</tt></a>.)

<p>
Since we already know the exact solution as \( u(t)=X_0\cos\omega
t \), we have reasoned as follows to find an appropriate simulation interval
\( [0,T] \) and also how many points we should choose.  The
solution has a period \( P=2\pi/\omega \). (The period \( P \) is the time difference
between two peaks of the \( u(t)\sim\cos\omega t \) curve.)
Simulating for three periods of
the cosine function, \( T=3P \), and choosing \( \Delta t \) such that there
are 20 intervals per period gives \( \Delta t=P/20 \) and a total of
\( N_t=T/\Delta t \) intervals. The rest of the program is a
straightforward coding of the Forward Euler scheme.

<p>
Figure <a href="#sec:de:osc:fig1">35</a> shows a comparison between the numerical
solution and the exact solution of the differential equation.
To our surprise, the numerical solution looks wrong. Is this
discrepancy due to a programming error or a problem with the Forward
Euler method?

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 35:  Simulation of an oscillating system. <div id="sec:de:osc:fig1"></div> </p></center>
<p><img src="figs/osc_FE_20pp.png" align="bottom" width=600></p>
</center>

<p>
First of all, even before trying to run the program, you should sit down and
compute two steps in the time loop with a calculator so you have some
intermediate results to compare with. Using \( X_0=2 \), \( dt=0.157079632679 \),
and \( \omega=2 \), we get \( u^1=2 \), \( v^1=-1.25663706 \), \( u^2=1.80260791 \),
and \( v^2=-2.51327412 \). Such calculations show that
the program is seemingly correct. (Later, we can use such values to
construct a unit test and a corresponding test function.)

<p>
The next step is to reduce the discretization parameter
\( \Delta t \) and see if the results become more accurate.
Figure <a href="#sec:de:osc:fig2">36</a> shows the numerical and exact solution for
the cases \( \Delta t = P/40, P/160, P/2000 \). The results clearly become
better, and the finest resolution gives graphs that cannot be visually
distinguished. Nevertheless, the finest resolution involves 6000
computational intervals in total, which is considered quite much.
This is no problem on a modern laptop, however, as the computations take just
a fraction of a second.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 36:  Simulation of an oscillating system with different time steps. Upper left: 40 steps per oscillation period. Upper right: 160 steps per period. Lower left: 2000 steps per period. Lower right: 2000 steps per period, but longer simulation. <div id="sec:de:osc:fig2"></div> </p></center>
<p><img src="figs/osc_FE_3dt.png" align="bottom" width=800></p>
</center>

<p>
Although 2000 intervals per oscillation period seem sufficient for an
accurate numerical solution, the lower right graph in Figure <a href="#sec:de:osc:fig2">36</a> shows that if we increase the simulation time, here to 20 periods, there is
a little growth of the amplitude, which becomes significant over time.
The conclusion is that the Forward Euler method has a fundamental problem with
its growing amplitudes, and that very small \( \Delta t \) is required to
achieve satisfactory results. The longer the simulation is, the smaller
\( \Delta t \) has to be. It is certainly time to look for more effective
numerical methods!

<h2 id="___sec159">A magic fix of the numerical method </h2>

<p>
In the Forward Euler scheme,

$$
\begin{align*}
u^{n+1} &= u^n + \Delta t\,v^n,\\ 
v^{n+1} &= v^n -\Delta t\,\omega^2 u^n,
\end{align*}
$$

we can replace \( u^n \) in the last equation by the recently computed value
\( u^{n+1} \) from the first equation:

$$
\begin{align}
u^{n+1} &= u^n + \Delta t\,v^n,
\tag{54} \\ 
v^{n+1} &= v^n -\Delta t\,\omega^2 u^{n+1}\thinspace .
\tag{55}
\end{align}
$$

<p>
Before justifying this fix more mathematically, let us try it on the
previous example. The results appear in Figure <a href="#sec:de:osc:fig3">37</a>.
We see that the amplitude <em>does not grow</em>, but the phase is not
entirely correct. After 40 periods (Figure <a href="#sec:de:osc:fig3">37</a> right)
we see a significant difference between the numerical and the exact solution.
Decreasing \( \Delta t \) decreases the error. For example, with 2000 intervals per
period, we only see a small phase error even after 50,000 periods (!).
We can safely conclude that the fix results in an excellent numerical method!

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 37:  Adjusted method: first four periods (left) and period 36-40 (right). <div id="sec:de:osc:fig3"></div> </p></center>
<p><img src="figs/osc2.png" align="bottom" width=800></p>
</center>

<p>
Let us interpret the adjusted scheme mathematically. First we order
<a href="#mjx-eqn-54">(54)</a>-<a href="#mjx-eqn-55">(55)</a>
such that the difference approximations to derivatives become
transparent:

$$
\begin{align}
\frac{u^{n+1} - u^n}{\Delta t} &= v^n,
\tag{56} \\ 
\frac{v^{n+1} - v^n}{\Delta t} &= -\omega^2 u^{n+1}\thinspace .
\tag{57}
\end{align}
$$

We interpret <a href="#mjx-eqn-56">(56)</a> as the
differential equation sampled at mesh point \( t_n \), because
we have \( v^n \) on the right-hand side.
The left-hand side is then a <em>forward difference</em> or Forward Euler
approximation to the derivative \( u' \), see Figure <a href="._p4c-bootstrap-Python018.html#sec:de:fig:FE">21</a>.
On the other hand, we interpret <a href="#mjx-eqn-57">(57)</a>
as the differential equation sampled at mesh point \( t_{n+1} \),
since we have \( u^{n+1} \) on the right-hand side. In this case,
the difference approximation on the left-hand side is
a <em>backward difference</em>,

$$ v'(t_{n+1}) \approx \frac{v^{n+1} - v^n}{\Delta t}\quad\hbox{ or }\quad
v'(t_{n}) \approx \frac{v^{n} - v^{n-1}}{\Delta t}\thinspace . $$

Figure <a href="#sec:de:fig:BE">38</a> illustrates the backward difference.
The accuracy of the backward difference is \( \Oof{\Delta t} \), the
same as for the forward difference (but the proportionality constant
in the error term has different sign).
The resulting discretization method for <a href="#mjx-eqn-57">(57)</a>
is often referred to as a Backward Euler scheme.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 38:  Illustration of a backward difference approximation to the derivative. <div id="sec:de:fig:BE"></div> </p></center>
<p><img src="figs/fd_backward.png" align="bottom" width=500></p>
</center>

<p>
To summarize, using a forward difference for the first equation and a
backward difference for the second equation results in a much
better method than just using forward differences in both equations.

<p>
The standard way of expressing this scheme in physics is to
change the order of the equations,
$$
\begin{align}
v' &= -\omega^2 u,
\tag{58}\\ 
u' &= v,
\tag{59}
\end{align}
$$

and apply a forward difference to <a href="#mjx-eqn-58">(58)</a>
and a backward difference to <a href="#mjx-eqn-59">(59)</a>:

$$
\begin{align}
v^{n+1} &= v^n -\Delta t\,\omega^2 u^{n},
\tag{60}\\ 
u^{n+1} &= u^n + \Delta t\,v^{n+1}\thinspace .
\tag{61}
\end{align}
$$

That is, first the velocity \( v \) is updated and then the position \( u \),
using the most recently computed velocity.
There is no difference between
<a href="#mjx-eqn-60">(60)</a>-<a href="#mjx-eqn-61">(61)</a>
and
<a href="#mjx-eqn-54">(54)</a>-<a href="#mjx-eqn-55">(55)</a>
with respect to accuracy, so the order of the original differential
equations does not matter.
The scheme <a href="#mjx-eqn-60">(60)</a>-<a href="#mjx-eqn-61">(61)</a>
goes under the names <a href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method" target="_self">Semi-implicit Euler</a> or Euler-Cromer.
The implementation of
<a href="#mjx-eqn-60">(60)</a>-<a href="#mjx-eqn-61">(61)</a>
is found in the file <code>osc_EC.py</code>. The core of the code goes like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">u <span style="color: #666666">=</span> zeros(N_t<span style="color: #666666">+1</span>)
v <span style="color: #666666">=</span> zeros(N_t<span style="color: #666666">+1</span>)

<span style="color: #408080; font-style: italic"># Initial condition</span>
u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">2</span>
v[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> <span style="color: #666666">0</span>

<span style="color: #408080; font-style: italic"># Step equations forward in time</span>
<span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_t):
    v[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> v[n] <span style="color: #666666">-</span> dt<span style="color: #666666">*</span>omega<span style="color: #666666">**2*</span>u[n]
    u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>v[n<span style="color: #666666">+1</span>]
</pre></div>

<h2 id="sec:de:osc:Heun">The 2nd-order Runge-Kutta method (or Heun's method)</h2>

<p>
A very popular method for solving scalar and vector ODEs of first
order is the 2nd-order Runge-Kutta method (RK2), also known as Heun's method.
The idea, first thinking of a scalar ODE, is to form a <em>centered difference</em>
approximation to the derivative between two time steps:

$$ u'(t_n+\frac{1}{2}\Delta t)\approx \frac{u^{n+1}-u^n}{\Delta t}\thinspace .$$

The centered difference formula is visualized in Figure <a href="#sec:de:fig:CN">39</a>.
The accuracy of the centered difference is \( \Oof{\Delta t^2} \), one order
higher than the forward and backward differences.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 39:  Illustration of a centered difference approximation to the derivative. <div id="sec:de:fig:CN"></div> </p></center>
<p><img src="figs/fd_centered_CN.png" align="bottom" width=500></p>
</center>

<p>
The problem with such a centered scheme for the general ODE \( u'=f(u,t) \) is
that we get

$$ \frac{u^{n+1}-u^n}{\Delta t} = f(u^{n+\frac{1}{2}},t_{n+\frac{1}{2}}),$$

which leads to difficulties since we do not know what \( u^{n+\frac{1}{2}} \)
is. However, we can approximate the value of \( f \) between two time
levels by the arithmetic average of the values at \( t_n \) and \( t_{n+1} \):

$$ f(u^{n+\frac{1}{2}},t_{n+\frac{1}{2}}) \approx
\frac{1}{2}(f(u^n, t_n) + f(u^{n+1}, t_{n+1}))\thinspace .$$

This results in

$$ \frac{u^{n+1}-u^n}{\Delta t} =
\frac{1}{2}(f(u^n, t_n) + f(u^{n+1}, t_{n+1})),$$

which in general is a <em>nonlinear algebraic equation</em> for \( u^{n+1} \)
if \( f(u,t) \) is not a linear function of \( u \). To deal with the unknown term
\( f(u^{n+1}, t_{n+1}) \), without solving nonlinear equations,
we can approximate or predict \( u^{n+1} \)
using a Forward Euler step:

$$ u^{n+1} = u^n + \Delta tf(u^n,t_n)\thinspace .$$

This reasoning gives rise to the method

$$
\begin{align}
u^* &= u^n + \Delta tf(u^n,t_n),\\ 
u^{n+1} &= u^n + \frac{\Delta t}{2}(
f(u^n,t_n) + f(u^{*},t_{n+1})\thinspace .
\end{align}
$$

The scheme applies to both scalar and vector ODEs.

<p>
For an oscillating system with \( f=(v,-\omega^2u) \) the file
<code>osc_Heun.py</code> implements this method. 
The <code>demo</code> function in that file runs the simulation for 10 periods
with 20 time steps per period.
The corresponding numerical and exact solution are shown
in Figure <a href="#sec:de:osc:fig:Heun">40</a>. We see that the amplitude grows,
but not as much as for the Forward Euler method. However, the
Euler-Cromer method is much better!

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 40:  Simulation of 10 periods of oscillations by Heun's method. <div id="sec:de:osc:fig:Heun"></div> </p></center>
<p><img src="figs/osc_Heun.png" align="bottom" width=600></p>
</center>

<p>
We should add that in problems where the Forward Euler method gives
satisfactory approximations, such as growth/decay problems or
the SIR model, the 2nd-order Runge-Kutta method or
Heun's method, usually works considerably better and produces
greater accuracy for the same computational cost. It is therefore
a very valuable method to be aware of, although it cannot compete
with the Euler-Cromer scheme for oscillation problems.
The derivation of the RK2/Heun scheme is also good general training in
&quot;numerical thinking&quot;.

<h2 id="sec:de:osc:odespy">Odespy: software for solving ODEs</h2>

<p>
There is a jungle of methods for solving ODEs, and it would be nice to
have easy access to implementations of a wide range of methods,
especially the sophisticated
and complicated <em>adaptive</em> methods that adjusts \( \Delta t \) automatically
to obtain a prescribed accuracy. The Python package
<a href="https://github.com/hplgit/odespy" target="_self">Odespy</a> gives easy access to a lot
of numerical methods for ODEs.

<p>
The simplest possible example on
using Odespy is to
solve \( u'=u \), \( u(0)=2 \), for 100 time steps until \( t=4 \):

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">odespy</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(u, t):
    <span style="color: #008000; font-weight: bold">return</span> u

method <span style="color: #666666">=</span> odespy<span style="color: #666666">.</span>Heun   <span style="color: #408080; font-style: italic"># or, e.g., odespy.ForwardEuler</span>
solver <span style="color: #666666">=</span> method(f)
solver<span style="color: #666666">.</span>set_initial_condition(<span style="color: #666666">2</span>)
time_points <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0</span>, <span style="color: #666666">4</span>, <span style="color: #666666">101</span>)
u, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(time_points)
</pre></div>
<p>
In other words, you define your right-hand side function <code>f(u, t)</code>,
initialize an Odespy <code>solver</code> object, set the initial condition,
compute a collection of time points where you want the solution,
and ask for the solution. The returned arrays <code>u</code> and <code>t</code> can be
plotted directly: <code>plot(t, u</code>).

<p>
A nice feature of Odespy is that problem parameters can be
arguments to the user's <code>f(u, t)</code> function. For example,
if our ODE problem is \( u'=-au+b \), with two problem parameters
\( a \) and \( b \), we may write our <code>f</code> function as

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(u, t, a, b):
    <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">-</span>a<span style="color: #666666">*</span>u <span style="color: #666666">+</span> b
</pre></div>
<p>
The extra, problem-dependent arguments <code>a</code> and <code>b</code> can be transferred
to this function
if we collect their values in a list or tuple
when creating the Odespy solver and use the <code>f_args</code> argument:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">a <span style="color: #666666">=</span> <span style="color: #666666">2</span>
b <span style="color: #666666">=</span> <span style="color: #666666">1</span>
solver <span style="color: #666666">=</span> method(f, f_args<span style="color: #666666">=</span>[a, b])
</pre></div>
<p>
This is a good feature because problem parameters must otherwise be
global variables - now they can be arguments in our right-hand side
function in a natural way. <a href="._p4c-bootstrap-Python021.html#sec:de:exer:odespy:decay">Exercise 59: Use Odespy to solve a simple ODE</a> asks
you to make a complete implementation of this problem and plot the
solution.

<p>
Using Odespy to solve oscillation ODEs like \( u''+\omega^2u=0 \),
reformulated as a system \( u'=v \) and \( v'=-\omega^2u \), is done
as follows. We specify
a given number of time steps per period and compute the
associated time steps and end time of the simulation (<code>T</code>),
given a number of periods to simulate:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">odespy</span>

<span style="color: #408080; font-style: italic"># Define the ODE system</span>
<span style="color: #408080; font-style: italic"># u&#39; = v</span>
<span style="color: #408080; font-style: italic"># v&#39; = -omega**2*u</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(sol, t, omega<span style="color: #666666">=2</span>):
    u, v <span style="color: #666666">=</span> sol
    <span style="color: #008000; font-weight: bold">return</span> [v, <span style="color: #666666">-</span>omega<span style="color: #666666">**2*</span>u]

<span style="color: #408080; font-style: italic"># Set and compute problem dependent parameters</span>
omega <span style="color: #666666">=</span> <span style="color: #666666">2</span>
X_0 <span style="color: #666666">=</span> <span style="color: #666666">1</span>
number_of_periods <span style="color: #666666">=</span> <span style="color: #666666">40</span>
time_intervals_per_period <span style="color: #666666">=</span> <span style="color: #666666">20</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, linspace, cos
P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>omega                      <span style="color: #408080; font-style: italic"># length of one period</span>
dt <span style="color: #666666">=</span> P<span style="color: #666666">/</span>time_intervals_per_period    <span style="color: #408080; font-style: italic"># time step</span>
T <span style="color: #666666">=</span> number_of_periods<span style="color: #666666">*</span>P             <span style="color: #408080; font-style: italic"># final simulation time</span>

<span style="color: #408080; font-style: italic"># Create Odespy solver object</span>
odespy_method <span style="color: #666666">=</span> odespy<span style="color: #666666">.</span>RK2
solver <span style="color: #666666">=</span> odespy_method(f, f_args<span style="color: #666666">=</span>[omega])

<span style="color: #408080; font-style: italic"># The initial condition for the system is collected in a list</span>
solver<span style="color: #666666">.</span>set_initial_condition([X_0, <span style="color: #666666">0</span>])

<span style="color: #408080; font-style: italic"># Compute the desired time points where we want the solution</span>
N_t <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))              <span style="color: #408080; font-style: italic"># no of time intervals</span>
time_points <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, T, N_t<span style="color: #666666">+1</span>)

<span style="color: #408080; font-style: italic"># Solve the ODE problem</span>
sol, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(time_points)

<span style="color: #408080; font-style: italic"># Note: sol contains both displacement and velocity</span>
<span style="color: #408080; font-style: italic"># Extract original variables</span>
u <span style="color: #666666">=</span> sol[:,<span style="color: #666666">0</span>]
v <span style="color: #666666">=</span> sol[:,<span style="color: #666666">1</span>]
</pre></div>
<p>
The last two statements are important since our two functions \( u \) and \( v \)
in the ODE system are packed together in one array inside the Odespy solver.
The solution of the ODE system
is returned as a two-dimensional array where the first
column (<code>sol[:,0]</code>) stores \( u \) and the second (<code>sol[:,1]</code>) stores \( v \).
Plotting \( u \) and \( v \) is a matter of running <code>plot(t, u, t, v)</code>.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark.</b>
In the right-hand side function we write <code>f(sol, t, omega)</code> instead
of <code>f(u, t, omega)</code> to indicate that the solution sent to <code>f</code>
is a solution at time <code>t</code> where the values of \( u \) and \( v \) are
packed together: <code>sol = [u, v]</code>. We might well use <code>u</code> as argument:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #ffffff"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(u, t, omega<span style="color: #666666">=2</span>):
    u, v <span style="color: #666666">=</span> u
    <span style="color: #008000; font-weight: bold">return</span> [v, <span style="color: #666666">-</span>omega<span style="color: #666666">**2*</span>u]
</pre></div>
<p>
This just means that we redefine the name <code>u</code> inside the function
to mean the solution at time <code>t</code> for the first component of
the ODE system.
</div>


<p>
To switch to another numerical method, just substitute <code>RK2</code> by
the proper name of the desired method.
Typing <code>pydoc odespy</code> in the terminal window brings up a list
of all the implemented methods.
This very simple way of choosing a method suggests an obvious extension
of the code above: we can define a list of methods, run all
methods, and compare their \( u \) curves in a plot.
As Odespy also contains the Euler-Cromer scheme, we rewrite
the system with \( v'=-\omega^2u \) as the first ODE and \( u'=v \)
as the second ODE, because this is the standard choice when
using the Euler-Cromer method (also in Odespy):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(u, t, omega<span style="color: #666666">=2</span>):
    v, u <span style="color: #666666">=</span> u
    <span style="color: #008000; font-weight: bold">return</span> [<span style="color: #666666">-</span>omega<span style="color: #666666">**2*</span>u, v]
</pre></div>
<p>
This change of equations also affects the initial condition:
the first component is zero and second is <code>X_0</code> so we need
to pass the list <code>[0, X_0]</code> to <code>solver.set_initial_condition</code>.

<p>
The code
<a href="https://github.com/hplgit/prog4comp/src/py/ode_odespy.py" target="_self"><tt>ode_odespy.py</tt></a>
contains the details:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">compare</span>(odespy_methods,
            omega,
            X_0,
            number_of_periods,
            time_intervals_per_period<span style="color: #666666">=20</span>):

    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> pi, linspace, cos
    P <span style="color: #666666">=</span> <span style="color: #666666">2*</span>pi<span style="color: #666666">/</span>omega                      <span style="color: #408080; font-style: italic"># length of one period</span>
    dt <span style="color: #666666">=</span> P<span style="color: #666666">/</span>time_intervals_per_period
    T <span style="color: #666666">=</span> number_of_periods<span style="color: #666666">*</span>P

    <span style="color: #408080; font-style: italic"># If odespy_methods is not a list, but just the name of</span>
    <span style="color: #408080; font-style: italic"># a single Odespy solver, we wrap that name in a list</span>
    <span style="color: #408080; font-style: italic"># so we always have odespy_methods as a list</span>
    <span style="color: #008000; font-weight: bold">if</span> <span style="color: #008000">type</span>(odespy_methods) <span style="color: #666666">!=</span> <span style="color: #008000">type</span>([]):
        odespy_methods <span style="color: #666666">=</span> [odespy_methods]

    <span style="color: #408080; font-style: italic"># Make a list of solver objects</span>
    solvers <span style="color: #666666">=</span> [method(f, f_args<span style="color: #666666">=</span>[omega]) <span style="color: #008000; font-weight: bold">for</span> method <span style="color: #AA22FF; font-weight: bold">in</span>
               odespy_methods]
    <span style="color: #008000; font-weight: bold">for</span> solver <span style="color: #AA22FF; font-weight: bold">in</span> solvers:
        solver<span style="color: #666666">.</span>set_initial_condition([<span style="color: #666666">0</span>, X_0])

    <span style="color: #408080; font-style: italic"># Compute the time points where we want the solution</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)  <span style="color: #408080; font-style: italic"># avoid integer division</span>
    N_t <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    time_points <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, N_t<span style="color: #666666">*</span>dt, N_t<span style="color: #666666">+1</span>)

    legends <span style="color: #666666">=</span> []
    <span style="color: #008000; font-weight: bold">for</span> solver <span style="color: #AA22FF; font-weight: bold">in</span> solvers:
        sol, t <span style="color: #666666">=</span> solver<span style="color: #666666">.</span>solve(time_points)
        v <span style="color: #666666">=</span> sol[:,<span style="color: #666666">0</span>]
        u <span style="color: #666666">=</span> sol[:,<span style="color: #666666">1</span>]

        <span style="color: #408080; font-style: italic"># Plot only the last p periods</span>
        p <span style="color: #666666">=</span> <span style="color: #666666">6</span>
        m <span style="color: #666666">=</span> p<span style="color: #666666">*</span>time_intervals_per_period  <span style="color: #408080; font-style: italic"># no time steps to plot</span>
        plot(t[<span style="color: #666666">-</span>m:], u[<span style="color: #666666">-</span>m:])
        hold(<span style="color: #BA2121">&#39;on&#39;</span>)
        legends<span style="color: #666666">.</span>append(solver<span style="color: #666666">.</span>name())
        xlabel(<span style="color: #BA2121">&#39;t&#39;</span>)
    <span style="color: #408080; font-style: italic"># Plot exact solution too</span>
    plot(t[<span style="color: #666666">-</span>m:], X_0<span style="color: #666666">*</span>cos(omega<span style="color: #666666">*</span>t)[<span style="color: #666666">-</span>m:], <span style="color: #BA2121">&#39;k--&#39;</span>)
    legends<span style="color: #666666">.</span>append(<span style="color: #BA2121">&#39;exact&#39;</span>)
    legend(legends, loc<span style="color: #666666">=</span><span style="color: #BA2121">&#39;lower left&#39;</span>)
    axis([t[<span style="color: #666666">-</span>m], t[<span style="color: #666666">-1</span>], <span style="color: #666666">-2*</span>X_0, <span style="color: #666666">2*</span>X_0])
    title(<span style="color: #BA2121">&#39;Simulation of </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> periods with </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> intervals per period&#39;</span>
          <span style="color: #666666">%</span> (number_of_periods, time_intervals_per_period))
    savefig(<span style="color: #BA2121">&#39;tmp.pdf&#39;</span>); savefig(<span style="color: #BA2121">&#39;tmp.png&#39;</span>)
    show()
</pre></div>
<p>
A new feature in this code is the ability to plot only the last <code>p</code>
periods, which allows us to perform long time simulations and
watch the end results without a cluttered plot with too many
periods. The syntax <code>t[-m:]</code> plots the last <code>m</code> elements in <code>t</code> (a
negative index in Python arrays/lists counts from the end).

<p>
We may compare Heun's method (or equivalently the RK2
method) with the Euler-Cromer scheme:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">compare(odespy_methods<span style="color: #666666">=</span>[odespy<span style="color: #666666">.</span>Heun, odespy<span style="color: #666666">.</span>EulerCromer],
        omega<span style="color: #666666">=2</span>, X_0<span style="color: #666666">=2</span>, number_of_periods<span style="color: #666666">=20</span>,
        time_intervals_per_period<span style="color: #666666">=20</span>)
</pre></div>
<p>
Figure <a href="#sec:de:osc:fig:Heun:vs:EC">41</a> shows how Heun's method
(the blue line with small disks)
has considerable error in both amplitude and phase already
after 14-20 periods (upper left), but using three times as
many time steps makes the curves almost equal (upper right).
However, after 194-200 periods the errors have grown (lower left),
but can be sufficiently reduced by halving the time step (lower right).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 41:  Illustration of the impact of resolution (time steps per period) and length of simulation. <div id="sec:de:osc:fig:Heun:vs:EC"></div> </p></center>
<p><img src="figs/osc_odespy_Heun_vs_EC.png" align="bottom" width=800></p>
</center>

<p>
With all the methods in Odespy at hand, it is now easy to start
exploring other methods, such as backward differences
instead of the forward differences used in the Forward Euler scheme.
<a href="._p4c-bootstrap-Python021.html#sec:de:exer:osc:BE">Exercise 60: Set up a Backward Euler scheme for oscillations</a> addresses that problem.

<p>
Odespy contains quite sophisticated adaptive methods where the user is
&quot;guaranteed&quot; to get a solution with prescribed accuracy. There is
no mathematical guarantee, but the error will for most cases not
deviate significantly from the user's tolerance that reflects the
accuracy. A very popular method of this type is the Runge-Kutta-Fehlberg method,
which runs a 4th-order Runge-Kutta method and uses a 5th-order
Runge-Kutta method to estimate the error so that \( \Delta t \) can
be adjusted to keep the error below a tolerance. This method is
also widely known as <code>ode45</code>, because that is the name of the function
implementing the method in Matlab.
We can easily test the Runge-Kutta-Fehlberg method as soon as we
know the corresponding Odespy name, which is <code>RKFehlberg</code>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">compare(odespy_methods<span style="color: #666666">=</span>[odespy<span style="color: #666666">.</span>EulerCromer, odespy<span style="color: #666666">.</span>RKFehlberg],
        omega<span style="color: #666666">=2</span>, X_0<span style="color: #666666">=2</span>, number_of_periods<span style="color: #666666">=200</span>,
        time_intervals_per_period<span style="color: #666666">=40</span>)
</pre></div>
<p>
Note that the <code>time_intervals_per_period</code> argument refers to the
time points where we want the solution. These points are also the ones
used for numerical computations in the
<code>odespy.EulerCromer</code> solver,
while the <code>odespy.RKFehlberg</code> solver will use an unknown set of
time points since the time intervals are adjusted as the method runs.
One can easily look at the points actually used by the method
as these are available as an array <code>solver.t_all</code> (but plotting or
examining the points requires modifications inside the <code>compare</code> method).

<p>
Figure <a href="#sec:de:osc:fig:RKF:vs:EC">42</a> shows a computational example
where the Runge-Kutta-Fehlberg method is clearly superior to the
Euler-Cromer scheme in long time simulations, but the comparison is
not really fair because the Runge-Kutta-Fehlberg method applies about
twice as many time steps in this computation and performs much more
work per time step. It is quite a complicated task to compare two so
different methods in a fair way so that the computational work versus
accuracy is scientifically well reported.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 42:  Comparison of the Runge-Kutta-Fehlberg adaptive method against the Euler-Cromer scheme for a long time simulation (200 periods). <div id="sec:de:osc:fig:RKF:vs:EC"></div> </p></center>
<p><img src="figs/osc_odespy_RKF_vs_EC.png" align="bottom" width=600></p>
</center>

<h2 id="___sec162">The 4th-order Runge-Kutta method </h2>

<p>
The 4th-order Runge-Kutta method (RK4) is clearly the most widely used method
to solve ODEs. Its power comes from high accuracy even with not so small
time steps.

<h3 id="___sec163">The algorithm </h3>

<p>
We first just state the four-stage algorithm:

$$
\begin{equation}
u^{n+1} = u^n +
\frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\frac{1}{2}}
+ 2\tilde{f}^{n+\frac{1}{2}} + \bar{f}^{n+1}\right),
\end{equation}
$$

where

$$
\begin{align}
\hat{f}^{n+\frac{1}{2}} &=
f(u^n + \frac{1}{2}{\Delta t} f^n, t_{n+\frac{1}{2}}),\\ 
\tilde{f}^{n+\frac{1}{2}} &=
f(u^n + \frac{1}{2}\Delta t\hat{f}^{n+\frac{1}{2}}, t_{n+\frac{1}{2}}),\\ 
\bar{f}^{n+1} &=
f(u^n + \Delta t \hat{f}^{n+\frac{1}{2}}, t_{n+1})\thinspace .
\end{align}
$$

<h3 id="___sec164">Application </h3>

<p>
We can run the same simulation as in Figures <a href="#sec:de:osc:fig1">35</a>,
<a href="#sec:de:osc:fig3">37</a>, and <a href="#sec:de:osc:fig:Heun">40</a>,
for 40 periods. The 10 last periods are shown in Figure <a href="#sec:de:osc:fig:RK4">43</a>. The results look as impressive as those of the Euler-Cromer method.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 43:  The last 10 of 40 periods of oscillations by the 4th-order Runge-Kutta method. <div id="sec:de:osc:fig:RK4"></div> </p></center>
<p><img src="figs/osc_RK4b.png" align="bottom" width=600></p>
</center>

<h3 id="___sec165">Implementation </h3>

<p>
The stages in the 4th-order Runge-Kutta method can easily be implemented
as a modification of the <code>osc_Heun.py</code> code.
Alternatively, one can use the <code>osc_odespy.py</code> code by just providing
the argument <code>odespy_methods=[odespy.RK4]</code> to the <code>compare</code> function.

<h3 id="___sec166">Derivation </h3>

<p>
The derivation of the 4th-order Runge-Kutta method can be presented in
a pedagogical way that brings many fundamental elements of
numerical discretization techniques together and that illustrates
many aspects of &quot;numerical thinking&quot; when constructing approximate
solution methods.

<p>
We start with integrating the general ODE
\( u'=f(u,t) \) over a time step, from \( t_n \) to \( t_{n+1} \),

$$ u(t_{n+1}) - u(t_n) = \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt\thinspace . $$

The goal of the computation is \( u(t_{n+1}) \) (\( u^{n+1} \)),
while \( u(t_n) \) (\( u^n \)) is the
most recently known value of \( u \).
The challenge with the integral is that the
integrand involves the unknown \( u \) between \( t_n \) and \( t_{n+1} \).

<p>
The integral can be approximated by the famous
<a href="http://en.wikipedia.org/wiki/Simpson's_rule" target="_self">Simpson's rule</a>:

$$ \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 4f^{n+\frac{1}{2}} + f^{n+1}\right)\thinspace .$$

The problem with this formula
is that we do not know \( f^{n+\frac{1}{2}}=f(u^{n+\frac{1}{2}},t_{n+\frac{1}{2}}) \)
and \( f^{n+1}=(u^{n+1},t_{n+1}) \) as only \( u^n \) is available and
only \( f^n \) can then readily be computed.

<p>
To proceed, the idea is to use various approximations for \( f^{n+\frac{1}{2}} \) and
\( f^{n+1} \) based on using well-known schemes for the ODE in the
intervals \( [t_n,t_{n+\frac{1}{2}}] \) and \( [t_n, t_{n+1}] \).
Let us split the integral into four terms:

$$ \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\frac{1}{2}}
+ 2\tilde{f}^{n+\frac{1}{2}} + \bar{f}^{n+1}\right),$$

where \( \hat{f}^{n+\frac{1}{2}} \), \( \tilde{f}^{n+\frac{1}{2}} \), and \( \bar{f}^{n+1} \)
are approximations to \( f^{n+\frac{1}{2}} \) and
\( f^{n+1} \) that can utilize already computed quantities.
For \( \hat{f}^{n+\frac{1}{2}} \) we can simply apply
an approximation to \( u^{n+\frac{1}{2}} \) based on a Forward Euler
step of size \( \frac{1}{2}\Delta t \):

$$
\begin{equation}
\hat{f}^{n+\frac{1}{2}} = f(u^n + \frac{1}{2}{\Delta t} f^n, t_{n+\frac{1}{2}})
\tag{62}
\end{equation}
$$

This formula provides a prediction of \( f^{n+\frac{1}{2}} \), so we can for
\( \tilde{f}^{n+\frac{1}{2}} \) try a Backward Euler method to approximate \( u^{n+\frac{1}{2}} \):

$$
\begin{equation}
\tilde{f}^{n+\frac{1}{2}} = f(u^n + \frac{1}{2}\Delta t\hat{f}^{n+\frac{1}{2}}, t_{n+\frac{1}{2}})\thinspace .
\tag{63}
\end{equation}
$$

With \( \tilde{f}^{n+\frac{1}{2}} \) as an approximation to
\( f^{n+\frac{1}{2}} \), we can for the final term \( \bar{f}^{n+1} \) use
a midpoint method (or central difference, also called
a Crank-Nicolson method) to approximate \( u^{n+1} \):

$$
\begin{equation}
\bar{f}^{n+1} = f(u^n + \Delta t \hat{f}^{n+\frac{1}{2}}, t_{n+1})\thinspace .
\tag{64}
\end{equation}
$$

We have now used the Forward and Backward Euler methods as well as the
centered difference approximation in the context of Simpson's rule. The hope is
that the combination of these methods yields an overall time-stepping
scheme from \( t_n \) to \( t_n{+1} \) that is much more accurate than the
\( \mathcal{O}(\Delta t) \) and \( \mathcal{O}(\Delta t^2) \) of the individual steps.
This is indeed true: the numerical error goes like
\( C\Delta t^4 \) for a constant \( C \), which means that the error
goes very quickly to zero as we reduce the time step size,
compared to the Forward Euler method (error \( \sim\Delta t^2 \)),
the Euler-Cromer method (error \( \sim\Delta t^2 \)) or
the 2nd-order Runge-Kutta, or Heun's, method (error \( \sim\Delta t^2 \)).

<p>
Note that the 4th-order Runge-Kutta method is fully explicit so there
is never any need to solve linear or nonlinear algebraic equations,
regardless of what \( f \) looks like.  However, the stability is
conditional and depends on \( f \).  There is a large family of <em>implicit</em>
Runge-Kutta methods that are unconditionally stable, but require
solution of algebraic equations involving \( f \) at each time step.
The Odespy package has support for a lot of sophisticated <em>explicit</em>
Runge-Kutta methods, but not yet implicit Runge-Kutta methods.

<h2 id="___sec167">More effects: damping, nonlinearity, and external forces </h2>

<p>
Our model problem \( u''+\omega^2u=0 \) is the simplest possible mathematical model
for oscillating systems. Nevertheless, this model makes strong demands
to numerical methods, as we have seen, and is very useful as a benchmark
for evaluating the performance of numerical methods.

<p>
Real-life applications involve more physical effects, which lead to a
differential equation with more terms and also more complicated
terms. Typically, one has a
damping force \( f(u') \) and a spring
force \( s(u) \). Both these forces may depend nonlinearly on their
argument, \( u' \) or \( u \). In addition, environmental forces \( F(t) \) may
act on the system. For example, the classical pendulum has
a nonlinear &quot;spring&quot; or restoring force \( s(u)\sim \sin(u) \), and
air resistance on the pendulum leads to a damping force
\( f(u')\sim |u'|u' \). Examples on environmental forces include
shaking of the ground (e.g., due to an earthquake) as well as forces
from waves and wind.

<p>
With three types of forces on the system: \( F \), \( f \), and \( s \),
the sum of forces is written \( F(t) - f(u') - s(u) \). Note
the minus sign in
front of \( f \) and \( s \), which indicates that these functions are defined such that
they represent forces acting <em>against</em> the motion.  For example,
springs attached to the wheels in a car are combined with effective
dampers, each providing a damping force \( f(u')=bu' \) that acts against the spring
velocity \( u' \). The corresponding physical force is then \( -f \):
\( -bu' \) points downwards when the spring is being stretched and \( u' \) points
upwards, and \( -f \) acts upwards when the spring is being compressed and
\( u' \) points downwards.

<p>
Figure <a href="#sec:de:ode2:fig1">44</a> shows an example of a mass \( m \) attached to
a potentially nonlinear spring and dashpot, and subject to an environmental
force \( F(t) \). Nevertheless, our general model can equally well be
a pendulum as in Figure <a href="#sec:de:ode2:fig2">45</a> with \( s(u)=mg\sin\theta \) and
\( f(\dot u) =\frac{1}{2}C_D A\varrho \dot\theta |\dot\theta| \) (where
\( C_D=0.4 \), \( A \) is the cross sectional area of the body, and \( \varrho \) is
the density of air).

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 44:  General oscillating system. <div id="sec:de:ode2:fig1"></div> </p></center>
<p><img src="figs/oscillator_general.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 45:  A pendulum with forces. <div id="sec:de:ode2:fig2"></div> </p></center>
<p><img src="figs/pendulum_body_diagram3.png" align="bottom" width=300></p>
</center>

<p>
Newton's second law for the system can be written with the mass times
acceleration on the left-hand side and the forces on the right-hand side:

$$ mu'' = F(t) - f(u') - s(u)\thinspace .$$

This equation is, however, more commonly reordered to

$$
\begin{equation}
mu'' + f(u') + s(u) = F(t)\thinspace .
\tag{65}
\end{equation}
$$

Because the differential equation is of second order, due to the term \( u'' \),
we need two initial conditions:

$$
\begin{equation}
u(0)=U_0,\quad u'(0)=V_0\thinspace .
\end{equation}
$$

Note that with the choices \( f(u')=0 \), \( s(u)=ku \), and \( F(t)=0 \)
we recover the original
ODE \( u'' +\omega^2u=0 \) with \( \omega=\sqrt{k/m} \).

<p>
How can we solve <a href="#mjx-eqn-65">(65)</a>?
As for the simple ODE \( u''+\omega^2u=0 \), we
start by rewriting the second-order ODE as a system of two
first-order ODEs:

$$
\begin{align}
v' &= \frac{1}{m}\left(F(t) - s(u) - f(v)\right),
\tag{66}\\ 
u' &= v\thinspace .
\tag{67}
\end{align}
$$

The initial conditions become \( u(0)=U_0 \) and \( v(0)=V_0 \).

<p>
Any method for a system of first-order ODEs can be used to solve for
\( u(t) \) and \( v(t) \).

<h3 id="___sec168">The Euler-Cromer scheme </h3>

<p>
An attractive choice from an implementational, accuracy, and
efficiency point of view is the Euler-Cromer scheme where we
take a forward difference in <a href="#mjx-eqn-66">(66)</a> and
a backward difference in <a href="#mjx-eqn-67">(67)</a>:

$$
\begin{align}
\frac{v^{n+1}-v^n}{\Delta t} &= \frac{1}{m}\left(F(t_n) - s(u^n) - f(v^n)\right),
\tag{68}\\ 
\frac{u^{n+1}-u^n}{\Delta t} &= v^{n+1},
\tag{69}
\end{align}
$$

We can easily solve for the new unknowns \( v^{n+1} \) and \( u^{n+1} \):

$$
\begin{align}
v^{n+1} &= v^n + \frac{\Delta t}{m}\left(F(t_n) - s(u^n) - f(v^n)\right),
\tag{70}\\ 
u^{n+1} &= u^n + \Delta t v^{n+1}\thinspace .
\tag{71}
\end{align}
$$

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark on the ordering of the ODEs.</b>
The ordering of the ODEs in the ODE system is important for the
extended model <a href="#mjx-eqn-66">(66)</a>-<a href="#mjx-eqn-67">(67)</a>.
Imagine that we write the equation for \( u' \) first and
then the one for \( v' \). The Euler-Cromer method would then
first use a forward difference for \( u^{n+1} \)
and then a backward difference for \( v^{n+1} \). The latter would
lead to a <em>nonlinear</em> algebraic equation for \( v^{n+1} \),

$$ v^{n+1} + \frac{\Delta t}{m}f(v^{n+1})
= v^n + \frac{\Delta t}{m}\left(F(t_{n+1}) - s(u^{n+1})\right),
$$

if \( f(v) \) is a nonlinear function of \( v \). This would require a
numerical method for nonlinear algebraic equations to find
\( v^{n+1} \), while updating \( v^{n+1} \) through a forward
difference gives an equation for \( v^{n+1} \) that is linear and
trivial to solve by hand.
</div>


<p>
The file
<a href="https://github.com/hplgit/prog4comp/src/py/osc_EC_general.py" target="_self"><tt>osc_EC_general.py</tt></a>
has a function <code>EulerCromer</code>
that implements this method:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">EulerCromer</span>(f, s, F, m, T, U_0, V_0, dt):
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> zeros, linspace
    N_t <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;N_t:&#39;</span>, N_t
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, N_t<span style="color: #666666">*</span>dt, N_t<span style="color: #666666">+1</span>)

    u <span style="color: #666666">=</span> zeros(N_t<span style="color: #666666">+1</span>)
    v <span style="color: #666666">=</span> zeros(N_t<span style="color: #666666">+1</span>)

    <span style="color: #408080; font-style: italic"># Initial condition</span>
    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> U_0
    v[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> V_0

    <span style="color: #408080; font-style: italic"># Step equations forward in time</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(N_t):
        v[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> v[n] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>(<span style="color: #666666">1./</span>m)<span style="color: #666666">*</span>(F(t[n]) <span style="color: #666666">-</span> f(v[n]) <span style="color: #666666">-</span> s(u[n]))
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> u[n] <span style="color: #666666">+</span> dt<span style="color: #666666">*</span>v[n<span style="color: #666666">+1</span>]
    <span style="color: #008000; font-weight: bold">return</span> u, v, t
</pre></div>

<h3 id="___sec169">The 4-th order Runge-Kutta method </h3>

<p>
The RK4 method just evaluates the right-hand side of the ODE
system,

$$ (\frac{1}{m}\left(F(t) - s(u) - f(v)\right), v)
$$

for known values of \( u \), \( v \), and \( t \), so the method is
very simple to use regardless of how the functions \( s(u) \) and
\( f(v) \) are chosen.

<h2 id="___sec170">Illustration of linear damping </h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 46:  Sketch of a one-dimensional, oscillating dynamic system subject to spring and viscous forces. <div id="sec:de:vib:ode2:fig2"></div> </p></center>
<p><img src="figs/oscillator.png" align="bottom" width=600></p>
</center>

<p>
We consider an engineering system with a linear spring,
\( s(u)=kx \), and a viscous damper, where the damping force is
proportional to \( u' \), \( f(u')=bu' \), for some constant \( b>0 \).
This choice may model the spring system in a car.
However, engineers often like to illustrate such a system by
a moving mass as depicted in Figure <a href="#sec:de:vib:ode2:fig2">46</a>.
We may choose simple values for the constants to illustrate
basic effects of damping (and later excitations). Choosing
the oscillations to be the simple
\( u(t)=\cos t \) function in the undamped case, we
may set \( m=1 \), \( k=1 \), \( b=0.3 \), \( U_0=1 \),
\( V_0=0 \). The following function implements this case:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">linear_damping</span>():
    b <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
    f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> v: b<span style="color: #666666">*</span>v
    s <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> u: k<span style="color: #666666">*</span>u
    F <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">0</span>

    m <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    k <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    U_0 <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    V_0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    T <span style="color: #666666">=</span> <span style="color: #666666">12*</span>pi
    dt <span style="color: #666666">=</span> T<span style="color: #666666">/5000.</span>

    u, v, t <span style="color: #666666">=</span> EulerCromer(f<span style="color: #666666">=</span>f, s<span style="color: #666666">=</span>s, F<span style="color: #666666">=</span>F, m<span style="color: #666666">=</span>m, T<span style="color: #666666">=</span>T,
                          U_0<span style="color: #666666">=</span>U_0, V_0<span style="color: #666666">=</span>V_0, dt<span style="color: #666666">=</span>dt)
    plot_u(u, t)
</pre></div>
<p>
The <code>plot_u</code> function is a collection of plot statements for
plotting \( u(t) \), or a part of it. Figure <a href="#sec:de:vib:ode2:fig:linear:damping">47</a>
shows the effect of the \( bu' \) term: we have oscillations with
(an approximate) period \( 2\pi \), as expected, but the amplitude is
efficiently damped.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 47:  Effect of linear damping. <div id="sec:de:vib:ode2:fig:linear:damping"></div> </p></center>
<p><img src="figs/osc_EC_linear_damping0.png" align="bottom" width=600></p>
</center>

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark about working with a scaled problem.</b>
Instead of setting \( b=0.3 \) and \( m=k=U_0=1 \) as fairly &quot;unlikely&quot;
physical values,
it would be better to <em>scale</em> the equation \( u'' +bu' + ku = 0 \).
This means that we introduce dimensionless independent and dependent
variables:

$$ \bar t = \frac{t}{t_c},\quad \bar u = \frac{u}{u_c},$$

where \( t_c \) and \( u_c \) are characteristic sizes of time and displacement,
respectively, such that \( \bar t \) and \( \bar u \) have their typical size
around unity. In the present problem, we can choose \( u_c=U_0 \) and
\( t_c = \sqrt{m/k} \). This gives the following scaled (or dimensionless)
problem for the dimensionless quantity \( \bar u(\bar t) \):

$$ \frac{d^2\bar u}{d\bar t^2} + \beta\frac{d\bar u}{d\bar t} +
\bar u = 0,\quad \bar u(0)=1,\ \bar u'(0)=0,\quad \beta = \frac{b}{\sqrt{mk}}
\thinspace .$$

The striking fact is that there is only <em>one</em> physical parameter in this
problem: the dimensionless number \( \beta \). Solving this problem corresponds
to solving the original problem (with dimensions) with the parameters
\( m=k=U_0=1 \) and \( b=\beta \). However, solving the dimensionless
problem is more general: if we have a solution \( \bar u(\bar t;\beta) \),
we can find the physical solution of a range of problems since

$$ u(t) = U_0\bar u(t\sqrt{k/m}; \beta)\thinspace .$$

As long as \( \beta \) is fixed, we can find \( u \) for any \( U_0 \), \( k \), and \( m \)
from the above formula! In this way, a time consuming simulation can be done only once,
but still provide many solutions. This demonstrates the power of working with
scaled or dimensionless problems.
</div>


<h2 id="___sec171">Illustration of linear damping with sinusoidal excitation </h2>

<p>
We now extend the previous example to also involve some external
oscillating force on the system: \( F(t)=A\sin (wt) \). Driving a
car on a road with sinusoidal bumps might give such an external
excitation on the spring system in the car (\( w \) is related to
the velocity of the car).

<p>
With \( A=0.5 \) and
\( w=3 \),

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> pi, sin
w <span style="color: #666666">=</span> <span style="color: #666666">3</span>
A <span style="color: #666666">=</span> <span style="color: #666666">0.5</span>
F <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: A<span style="color: #666666">*</span>sin(w<span style="color: #666666">*</span>t)
</pre></div>
<p>
we get the graph in Figure <a href="#sec:de:vib:ode2:fig:linear:damping:sinwt">48</a>.
The striking difference from Figure <a href="#sec:de:vib:ode2:fig:linear:damping">47</a>
is that the oscillations start out as a damped \( \cos t \) signal
without much influence of the external force, but then the free oscillations
of the undamped system (\( \cos t \)) \( u'' + u = 0 \) die out and
the external force \( 0.5\sin(3t) \) induces oscillations with a shorter period
\( 2\pi/3 \). You are encouraged to play around with a larger \( A \) and switch
from a sine to a cosine in \( F \) and observe the effects. If you look this up in
a physics book, you can find exact analytical solutions to the differential
equation problem in these cases.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 48:  Effect of linear damping in combination with a sinusoidal external force. <div id="sec:de:vib:ode2:fig:linear:damping:sinwt"></div> </p></center>
<p><img src="figs/osc_EC_linear_damping1.png" align="bottom" width=600></p>
</center>

<p>
A particularly interesting case arises when the excitation force has
the same frequency as the free oscillations of the undamped system, i.e.,
\( F(t)=A\sin t \). With the same amplitude \( A=0.5 \), but a smaller damping
\( b=0.1 \), the oscillations in
Figure <a href="#sec:de:vib:ode2:fig:linear:damping:sinwt">48</a> becomes qualitatively
very different as the amplitude grows significantly larger over
some periods. This phenomenon is called resonance and is exemplified
in Figure <a href="#sec:de:vib:ode2:fig:linear:damping:sint">49</a>. Removing the
damping results in an amplitude that grows linearly in time.

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 49:  Excitation force that causes resonance. <div id="sec:de:vib:ode2:fig:linear:damping:sint"></div> </p></center>
<p><img src="figs/osc_EC_linear_damping2.png" align="bottom" width=600></p>
</center>

<h2 id="sec:de:vib:ode2:sliding:friction">Spring-mass system with sliding friction</h2>

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 50:  Sketch of a one-dimensional, oscillating dynamic system subject to sliding friction and a spring force. <div id="sec:de:vib:ode2:fig3"></div> </p></center>
<p><img src="figs/oscillator_sliding.png" align="bottom" width=600></p>
</center>

<p>
A body with mass \( m \) is attached to a spring with stiffness \( k \) while sliding
on a plane surface. The body is also subject
to a friction force \( f(u') \) due to the contact between the body and
the plane. Figure <a href="#sec:de:vib:ode2:fig3">50</a> depicts the situation.
The friction force \( f(u') \) can be
modeled by Coulomb friction:

$$ f(u') = \left\lbrace\begin{array}{ll}
-\mu mg,& u' < 0,\\ 
\mu mg, & u' > 0,\\ 
0,      & u'=0
\end{array}\right.$$

where \( \mu \) is the friction coefficient, and \( mg \) is the normal force
on the surface where the body slides. This formula can also be
written as \( f(u')=mg\,\mbox{sign}(u') \), provided the signum function
\( \mbox{sign}(x) \) is defined to be zero for \( x=0 \)
(<code>numpy.sign</code> has
this property). To check that the signs in the definition of
\( f \) are right, recall that the actual
physical force is \( -f \) and this is positive (i.e., \( f < 0 \)) when it
works against the body moving with velocity \( u' < 0 \).

<p>
The nonlinear spring force is taken as

$$ s(u) = -k\alpha^{-1}\tanh (\alpha u),$$

which is approximately \( -ku \) for small \( u \), but stabilizes at \( \pm k/\alpha \)
for large \( \pm \alpha u \). Here is a plot with \( k=1000 \) and \( u\in [-0.1,0.1] \)
for three \( \alpha \) values:

<p>
<center><p><img src="figs/spring_tanh.png" align="bottom" width=600></p></center>

<p>
If there are no external
forces acting on the body, we have the equation of motion

$$ mu'' + \mu mg\,\mbox{sign}(u') + k\tanh u = 0\thinspace .$$

<p>
Let us simulate a situation where a body of mass 1 kg slides on a surface
with \( \mu =0.4 \), while attached to a spring with stiffness
\( k=1000 \) $\hbox{kg}/\hbox{s}^2$. The initial displacement of the
body is 10 cm, and the \( \alpha \) parameter in \( s(u) \) is set to 60 1/m.
Using the <code>EulerCromer</code> function from the <code>osc_EC_general</code> code, we can write a function <code>sliding_friction</code> for solving this problem:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">sliding_friction</span>():
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> tanh, sign

    f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> v: mu<span style="color: #666666">*</span>m<span style="color: #666666">*</span>g<span style="color: #666666">*</span>sign(v)
    alpha <span style="color: #666666">=</span> <span style="color: #666666">60.0</span>
    s <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> u: k<span style="color: #666666">/</span>alpha<span style="color: #666666">*</span>tanh(alpha<span style="color: #666666">*</span>u)
    s <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> u: k<span style="color: #666666">*</span>u
    F <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">0</span>

    g <span style="color: #666666">=</span> <span style="color: #666666">9.81</span>
    mu <span style="color: #666666">=</span> <span style="color: #666666">0.4</span>
    m <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    k <span style="color: #666666">=</span> <span style="color: #666666">1000</span>

    U_0 <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
    V_0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>

    T <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    dt <span style="color: #666666">=</span> T<span style="color: #666666">/5000.</span>

    u, v, t <span style="color: #666666">=</span> EulerCromer(f<span style="color: #666666">=</span>f, s<span style="color: #666666">=</span>s, F<span style="color: #666666">=</span>F, m<span style="color: #666666">=</span>m, T<span style="color: #666666">=</span>T,
                          U_0<span style="color: #666666">=</span>U_0, V_0<span style="color: #666666">=</span>V_0, dt<span style="color: #666666">=</span>dt)
    plot_u(u, t)
</pre></div>
<p>
Running the <code>sliding_friction</code> function gives us the
results in Figure <a href="#sec:de:vib:ode2:fig:friction">51</a>
with \( s(u)=k\alpha^{-1}\tanh (\alpha u) \) (left) and
the linearized version \( s(u)=ku \) (right):

<p>
<center> <!-- figure -->
<hr class="figure">
<center><p class="caption">Figure 51:  Effect of nonlinear (left) and linear (right) spring on sliding friction. <div id="sec:de:vib:ode2:fig:friction"></div> </p></center>
<p><img src="figs/sliding_friction.png" align="bottom" width=800></p>
</center>

<h2 id="sec:de:vib:2nd">A finite difference method; undamped, linear case</h2>

<p>
We shall now address numerical methods for the second-order ODE

$$
u'' + \omega^2u = 0,\quad u(0)=U_0,\ u'(0)=0,\ t\in (0,T],
$$

<em>without</em> rewriting the ODE as a system of first-order ODEs. The primary
motivation for &quot;yet another solution method&quot; is that the
discretization principles result in a very good scheme, and more
importantly, the thinking around the discretization can be reused when
solving partial differential equations.

<p>
The main idea of this numerical method
is to approximate the second-order derivative \( u'' \)
by a finite difference. While there are several choices of difference
approximations to
first-order derivatives, there is one dominating formula for
the second-order derivative:

$$
\begin{equation}
u''(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
\thinspace .
\tag{72}
\end{equation}
$$

The accuracy of this approximation is \( \Oof{\Delta t^2} \).
Letting the ODE be valid at some arbitrary time point \( t_n \),

$$ u''(t_n) + \omega^2 u(t_n) = 0,$$

we just insert the approximation <a href="#mjx-eqn-72">(72)</a> to get

$$
\begin{equation}
\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
\thinspace .
\end{equation}
$$

<p>
We now assume that \( u^{n-1} \) and \( u^n \) are already computed and
that \( u^{n+1} \) is the new unknown. Solving with respect to
\( u^{n+1} \) gives

$$
\begin{equation}
u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
\thinspace .
\tag{73}
\end{equation}
$$

<p>
A major problem arises when we want to start the scheme.
We know that \( u^0=U_0 \), but applying <a href="#mjx-eqn-73">(73)</a> for
\( n=0 \) to compute \( u^1 \) leads to

$$
\begin{equation}
u^1 = 2u^0 - u^{-1} - \Delta t^2\omega^2 u^0,
\tag{74}
\end{equation}
$$

where we do not know \( u^{-1} \). The initial condition \( u'(0)=0 \) can help
us to eliminate \( u^{-1} \) -
and this condition must anyway be incorporated in some way.
To this end, we discretize \( u'(0)=0 \) by a <em>centered difference</em>,

$$ u'(0) \approx \frac{u^1 - u^{-1}}{2\Delta t} = 0\thinspace .$$

It follows that \( u^{-1}=u^1 \), and we can use this relation to
eliminate \( u^{-1} \) in <a href="#mjx-eqn-74">(74)</a>:

$$
\begin{equation}
u^1 = u^0 - \frac{1}{2}\Delta t^2\omega^2 u^0\thinspace .
\tag{75}
\end{equation}
$$

With \( u^0=U_0 \) and \( u^1 \) computed from <a href="#mjx-eqn-75">(75)</a>,
we can compute \( u^2 \), \( u^3 \), and so forth from <a href="#mjx-eqn-73">(73)</a>.
<a href="._p4c-bootstrap-Python021.html#sec:de:exer:osc:2nd:V0ic">Exercise 62: Discretize an initial condition</a> asks you to explore how the
steps above are modified in case we have a nonzero initial condition
\( u'(0)=V_0 \).

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark on a simpler method for computing \( u^1 \).</b>
We could approximate the initial condition \( u'(0) \) by a forward difference:

$$ u'(0) \approx \frac{u^1-u^0}{\Delta t} = 0,$$

leading to \( u^1=u^0 \). Then we can use <a href="#mjx-eqn-73">(73)</a> for
the coming time steps. However, this forward difference has accuracy
\( \Oof{\Delta t} \), while the centered difference we used has
accuracy \( \Oof{\Delta t^2} \), which is compatible with the
accuracy \( \Oof{\Delta t^2} \) used in the discretization of the
differential equation.
</div>


<p>
The method for the second-order
ODE described above goes under the name
Stormer's
method or <a href="http://en.wikipedia.org/wiki/Verlet_integration" target="_self">Verlet integration</a>.
It turns out that this method
is mathematically equivalent with the Euler-Cromer scheme (!).
Or more precisely, the general formula <a href="#mjx-eqn-73">(73)</a>
is equivalent with the Euler-Cromer formula, but the scheme for
the first time level <a href="#mjx-eqn-75">(75)</a>
implements the initial condition \( u'(0) \) slightly more accurately
than what is naturally done in the Euler-Cromer scheme. The latter
will do

$$ v^1 = v^0 - \Delta t\omega^2 u^0,\quad u^1 = u^0 + \Delta t v^1
= u^0 - \Delta t^2\omega^2 u^0,$$

which differs from \( u^1 \) in <a href="#mjx-eqn-75">(75)</a> by
an amount \( \frac{1}{2}\Delta t^2\omega^2 u^0 \).

<p>
Because of the equivalence of <a href="#mjx-eqn-73">(73)</a> with
the Euler-Cromer scheme, the numerical results will have the same
nice properties such as a constant amplitude. There will be a phase
error as in the Euler-Cromer scheme, but this error is effectively
reduced by reducing \( \Delta t \), as already demonstrated.

<p>
Another implication of the equivalence between <a href="#mjx-eqn-73">(73)</a>
and the Euler-Cromer scheme, is that the latter must also have
accuracy of order \( \Delta t^2 \). One would intuitively think that
using a forward and a backward difference in the Euler-Cromer
scheme implies an \( \Oof{\Delta t} \) scheme, but the differences are
used in a symmetric way so together they form an
\( \Oof{\Delta t^2} \) scheme.

<p>
The implementation of <a href="#mjx-eqn-75">(75)</a> and
<a href="#mjx-eqn-73">(73)</a> is straightforward in a function
(file <a href="https://github.com/hplgit/prog4comp/src/py/osc_2nd_order.py" target="_self"><tt>osc_2nd_order.py</tt></a>):

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> zeros, linspace

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">osc_2nd_order</span>(U_0, omega, dt, T):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Solve u&#39;&#39; + omega**2*u = 0 for t in (0,T], u(0)=U_0 and u&#39;(0)=0,</span>
<span style="color: #BA2121; font-style: italic">    by a central finite difference method with time step dt.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    dt <span style="color: #666666">=</span> <span style="color: #008000">float</span>(dt)
    Nt <span style="color: #666666">=</span> <span style="color: #008000">int</span>(<span style="color: #008000">round</span>(T<span style="color: #666666">/</span>dt))
    u <span style="color: #666666">=</span> zeros(Nt<span style="color: #666666">+1</span>)
    t <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, Nt<span style="color: #666666">*</span>dt, Nt<span style="color: #666666">+1</span>)

    u[<span style="color: #666666">0</span>] <span style="color: #666666">=</span> U_0
    u[<span style="color: #666666">1</span>] <span style="color: #666666">=</span> u[<span style="color: #666666">0</span>] <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>dt<span style="color: #666666">**2*</span>omega<span style="color: #666666">**2*</span>u[<span style="color: #666666">0</span>]
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, Nt):
        u[n<span style="color: #666666">+1</span>] <span style="color: #666666">=</span> <span style="color: #666666">2*</span>u[n] <span style="color: #666666">-</span> u[n<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> dt<span style="color: #666666">**2*</span>omega<span style="color: #666666">**2*</span>u[n]
    <span style="color: #008000; font-weight: bold">return</span> u, t
</pre></div>

<h2 id="sec:de:vib:2nd:damped1">A finite difference method; linear damping</h2>

<p>
A key issue is how to generalize the scheme from the section <a href="#sec:de:vib:2nd">A finite difference method; undamped, linear case</a>
to a differential equation with more terms. We start with
the case of a linear damping term \( f(u')=bu' \), a possibly nonlinear
spring force \( s(u) \), and an excitation force \( F(t) \):

$$
\begin{equation}
mu'' + bu' + s(u) = F(t),\quad u(0)=U_0,\ u'(0)=0,\ t\in (0,T]
\thinspace .
\end{equation}
$$

We need to find the appropriate difference approximation to \( u' \)
in the \( bu' \) term.
A good choice is the <em>centered difference</em>

$$
\begin{equation}
u'(t_n) \approx \frac{u^{n+1}-u^{n-1}}{2\Delta t}\thinspace .
\tag{76}
\end{equation}
$$

Sampling the equation at a time point \( t_n \),

$$ mu''(t_n) + bu'(t_n) + s(u^n) = F(t_n),$$

and inserting the finite difference approximations to \( u'' \) and \( u' \)
results in

$$
\begin{equation}
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + s(u^n) = F^n,
\tag{77}
\end{equation}
$$

where \( F^n \) is a short notation for \( F(t_n) \).
Equation <a href="#mjx-eqn-77">(77)</a> is linear in the unknown \( u^{n+1} \),
so we can easily solve for this quantity:

$$
\begin{equation}
u^{n+1} = (2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
\Delta t^2(F^n - s(u^n)))(m + \frac{b}{2}\Delta t)^{-1}
\tag{78}
\thinspace .
\end{equation}
$$

<p>
As in the case without damping, we need to derive a special
formula for \( u^1 \). The initial condition \( u'(0)=0 \) implies
also now that \( u^{-1}=u^1 \), and with <a href="#mjx-eqn-78">(78)</a> for
\( n=0 \), we get

$$
\begin{equation}
u^1 = u^0 + \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
\thinspace .
\tag{79}
\end{equation}
$$

<p>
In the more general case with a nonlinear damping term \( f(u') \),

$$
mu'' + f(u') + s(u) = F(t),
$$

we get

$$
m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n,
$$

which is a <em>nonlinear algebraic equation</em> for \( u^{n+1} \) that
must be solved by numerical methods. A much more convenient
scheme arises from using a backward difference for \( u' \),

$$ u'(t_n)\approx \frac{u^n-u^{n-1}}{\Delta t},$$

because the damping term will then be known,
involving only \( u^n \) and \( u^{n-1} \), and we can easily solve
for \( u^{n+1} \).

<p>
The downside of the backward difference compared to the centered
difference <a href="#mjx-eqn-76">(76)</a> is that it reduces the accuracy in
the overall scheme from \( \Oof{\Delta t^2} \) to \( \Oof{\Delta t} \).  In
fact, the Euler-Cromer scheme evaluates a nonlinear damping term as
\( f(v^n) \) when computing \( v^{n+1} \), and this is equivalent to
using the backward difference above. Consequently, the convenience of
the Euler-Cromer scheme for nonlinear damping comes at a cost of
lowering the overall accuracy of the scheme from second to first
order in \( \Delta t \). Using the same trick in the finite difference scheme for
the second-order differential equation, i.e., using the backward
difference in \( f(u') \), makes this scheme
equally convenient and accurate as the Euler-Cromer scheme
in the general nonlinear case \( mu''+f(u')+s(u)=F \).

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._p4c-bootstrap-Python019.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._p4c-bootstrap-Python021.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

