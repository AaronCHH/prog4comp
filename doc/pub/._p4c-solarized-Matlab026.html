<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Programming for Computations - A Gentle Introduction to Numerical Simulations with MATLAB/Octave">
<meta name="keywords" content="DocOnce,computer program,programming,language programming,language computer,MATLAB,Octave,Fortran,C,C++,Python,Maple,Mathematica,syntax,bug,debugging,script (and scripting),algorithm,execute (a program),implement (a program),bug,debugging,simulation,model mathematical,print,program run,program execute,code,comment,instruction,program statement,variable,assignment,semi-colon (easy print),calculator,text editor,Emacs,Vim,Gedit,Notepad++,TextWrangler,prompt,program typing,program run,program execute,m-file,function,function call,atan,function input parameter,function output parameter,function return,function take a parameter,plot,linspace,xlabel,ylabel,plot,array,interactive use (of Matlab),keyboard arrow up/down,prompt,operator Arithmetic,parentheses,rounding error,variable type,variable name,float,integer,string,type conversion,reserved words,variable integer,variable float,variable string,variable assignment,default,single (precision),double (precision),printing formatted,printf formatting,default,array,array element,zeros,allocate,array index,indexing zero based,indexing one based,Matlab one-based indexing,array slice of,copy,graph,hold (on/off),plot figure,title (plot),legend (plot),axis (plot),hardcopy (plot),format png,matrix vector product,linear algebra,matrix,vector,error message,debugging,debugger,try-catch,exception handling,program crash,program testing,testing,program verification,verification,validation,program input,program output,input,symbolic computations,symbolic operations,symbolic simplifications,Symbolic Toolbox,WolframAlpha,Mathematica,Sage (symbolic package),variable delete,Matlab documentation,Matlab licence,long lines (splitting of),fast code,Matlab indent,commenting code,if,elseif,else,end,boolean,boolean expression,true (1),false (0),boolean true (1),boolean false (0),pseudo code,random walk,rand (function),operator Logical,function,function definition,return,argument,parameter input,parameter output,main program,return value,function nargin,function nargout,variable local,variable global,doc string,function handle,function local,function global,function nested,anonymous function,function anonymous,loop for,for loop,loop iteration,loop index,loop double,loop multiple,loop nested,linear algebra,while loop,loop while,loop infinite,loop iteration,loop index,stop program (Ctrl+c),read (from file),write (to file),array sorting,Leibniz pi,Euler pi,programming game,linear interpolation,least squares method,Fourier series,integral analytically,integral exact,integral numerically,integral approximately,Trapezoidal rule,composite trapezoidal rule,integration points,implementation specific,implementation general,code re-use,flat program,program flat,error function (erf),Midpoint method,composite midpoint method,Simpson's rule,Gauss quadrature,bug,unit tests,testing procedures,convergence rate,rate of convergence,error asymptotic,finite precision (of float),floating point number (float),error rounding,error tolerance,difference absolute,difference relative,assert (function),function assert,test function,vectorization,computational speed (measuring),domain,double integral midpoint,double sum,code re-use,triple integral midpoint,domain,domain complex,domain,Monte Carlo integration,seed (random generators),dynamical system,scheme,differential equation first-order,model mathematical,model differential equation,model computational,exp math notation,finite difference method,mesh,mesh uniform,mesh points,forward difference approximation,difference forward,Forward Euler scheme,Euler's method,numerical scheme,demo function,logistic model carrying capacity,SIR model,compartment model,mathematical modeling,scalar ODE,ODE scalar,vector ODE,ODE vector,system of ODEs,discontinuous coefficient,spring oscillations,spring damping of,differential equation second-order,simple pendulum,second-order ODE rewritten as two first-order ODEs,difference forward,difference backward,Heun's method,Runge-Kutta, 2nd-order method,2nd-order Runge-Kutta method,RK2,difference centered,nonlinear algebraic equation,ode45,ode23s,Runge-Kutta-Fehlberg,Crank-Nicolson method,spring damping of,spring nonlinear,spring linear,scaling,resonance,Verlet integration,Crank-Nicolson method,Taylor series,PDE,heat equation,diffusion equation,source term,domain,initial conditions,boundary conditions,MOL forward Euler,method of lines,MOL,mesh points,cell,method of lines,unstable solutions,instability,stability criterion,scaling,vectorization,tridiagonal matrix,matrix tridiagonal,theta rule,Poisson equation,Laplace equation,root finding,brute force method,code robust,divergence,code exception,code try-catch,Newton starting value,return None,rate of convergence">

<title>Programming for Computations - A Gentle Introduction to Numerical Simulations with MATLAB/Octave</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Let pre tags for code blocks have the same color as the surroundings */
pre { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Why learn programming?', 3, None, '___sec1'),
              (u'Target audience and background knowledge',
               3,
               None,
               '___sec2'),
              (u'Numerical methods', 3, None, '___sec3'),
              (u'The computer language: Matlab', 3, None, '___sec4'),
              (u'How this book is different', 3, None, '___sec5'),
              (u'Supplementary materials', 3, None, '___sec6'),
              (u'Acknowledgments', 3, None, '___sec7'),
              (u'The first few steps',
               0,
               u'1st:TheFirstFewSteps',
               u'1st:TheFirstFewSteps'),
              (u'What is a program? And what is programming?',
               1,
               None,
               '___sec9'),
              (u'A Matlab program with variables', 1, u'1st:ex1', u'1st:ex1'),
              (u'The program', 2, None, '___sec11'),
              (u'Dissection of the program', 2, None, '___sec12'),
              (u'Why not just use a pocket calculator?', 2, None, '___sec13'),
              (u'Why you must use a text editor to write programs',
               2,
               None,
               '___sec14'),
              (u'Write and run your first program', 2, None, '___sec15'),
              (u'Write and run a program in Matlab', 3, None, '___sec16'),
              (u'Write a program in a text editor and run it in Octave',
               3,
               None,
               '___sec17'),
              (u'A Matlab program with a library function',
               1,
               u'1st:ex2',
               u'1st:ex2'),
              (u'A Matlab program with vectorization and plotting',
               1,
               u'1st:ex3',
               u'1st:ex3'),
              (u'More basic concepts', 1, None, '___sec20'),
              (u'Using Matlab interactively', 2, None, '___sec21'),
              (u'Arithmetics, parentheses and rounding errors',
               2,
               None,
               '___sec22'),
              (u'Variables', 2, None, '___sec23'),
              (u'Formatting text and numbers', 2, None, '___sec24'),
              (u'Arrays', 2, None, '___sec25'),
              (u'Plotting', 2, None, '___sec26'),
              (u'Error messages and warnings', 2, None, '___sec27'),
              (u'Input data', 2, None, '___sec28'),
              (u'Symbolic computations', 2, None, '___sec29'),
              (u'Concluding remarks', 2, None, '___sec30'),
              (u'Exercises', 1, None, '___sec31'),
              (u'Exercise 1: Error messages',
               2,
               u'1st:exer:ErrorMessages',
               u'1st:exer:ErrorMessages'),
              (u'Exercise 2: Volume of a cube',
               2,
               u'1st:exer:cubeVolume',
               u'1st:exer:cubeVolume'),
              (u'Exercise 3: Area and circumference of a circle',
               2,
               u'1st:exer:areaCircle',
               u'1st:exer:areaCircle'),
              (u'Exercise 4: Volumes of three cubes',
               2,
               u'1st:exer:volumes3cubes',
               u'1st:exer:volumes3cubes'),
              (u'Exercise 5: Average of integers',
               2,
               u'1st:exer:averageOf5Integers',
               u'1st:exer:averageOf5Integers'),
              (u'Exercise 6: Interactive computing of volume and area',
               2,
               u'1st:exer:cubeVolInteractively',
               u'1st:exer:cubeVolInteractively'),
              (u'Exercise 7: Update variable at command prompt',
               2,
               u'1st:exer:updateVarInteractively',
               u'1st:exer:updateVarInteractively'),
              (u'Exercise 8: Formatted print to screen',
               2,
               u'1st:exer:printfScreen',
               u'1st:exer:printfScreen'),
              (u'Exercise 9: Matlab documentation and random numbers',
               2,
               u'1st:exer:PythonDocRandom',
               u'1st:exer:PythonDocRandom'),
              (u'Basic constructions',
               0,
               u'2nd:BasicConstructins',
               u'2nd:BasicConstructins'),
              (u'If tests', 1, None, '___sec42'),
              (u'Functions', 1, u'sec:functions', u'sec:functions'),
              (u'For loops', 1, u'sec:for:loops', u'sec:for:loops'),
              (u'While loops', 1, u'sec:while:loops', u'sec:while:loops'),
              (u'Reading from and writing to files',
               1,
               u'sec:file:reading:writing',
               u'sec:file:reading:writing'),
              (u'Exercises', 1, None, '___sec47'),
              (u'Exercise 10: Introducing errors',
               2,
               u'2nd:exer:IntroducingErrors',
               u'2nd:exer:IntroducingErrors'),
              (u'Exercise 11: Compare integers a and b',
               2,
               u'2nd:exer:compInt',
               u'2nd:exer:compInt'),
              (u'Exercise 12: Functions for circumference and area of a circle',
               2,
               u'2nd:exer:funcCircArea',
               u'2nd:exer:funcCircArea'),
              (u'Exercise 13: Function for area of a rectangle',
               2,
               u'2nd:exer:funcAreaRectangle',
               u'2nd:exer:funcAreaRectangle'),
              (u'Exercise 14: Area of a polygon',
               2,
               u'2nd:exer:area:polygon',
               u'2nd:exer:area:polygon'),
              (u'Exercise 15: Average of integers',
               2,
               u'2nd:exer:avNInt',
               u'2nd:exer:avNInt'),
              (u'Exercise 16: While loop with errors',
               2,
               u'2nd:exer:whileLoopErrors',
               u'2nd:exer:whileLoopErrors'),
              (u'Exercise 17: Area of rectangle versus circle',
               2,
               u'2nd:exer:areaRectCircle',
               u'2nd:exer:areaRectCircle'),
              (u'Exercise 18: Find crossing points of two graphs',
               2,
               u'2nd:exer:Cross2Graphs',
               u'2nd:exer:Cross2Graphs'),
              (u'Exercise 19: Sort array with numbers',
               2,
               u'2nd:exer:sortNumbers',
               u'2nd:exer:sortNumbers'),
              (u'Exercise 20: Compute $\\pi$',
               2,
               u'2nd:exer:computingPi',
               u'2nd:exer:computingPi'),
              (u'Exercise 21: Compute combinations of sets',
               2,
               u'2nd:exer:combinatorics1',
               u'2nd:exer:combinatorics1'),
              (u'Exercise 22: Frequency of random numbers',
               2,
               u'2nd:exer:numberOccurrence',
               u'2nd:exer:numberOccurrence'),
              (u'Remarks', 3, None, '___sec61'),
              (u'Exercise 23: Game 21',
               2,
               u'2nd:exer:Game21',
               u'2nd:exer:Game21'),
              (u'Exercise 24: Linear interpolation',
               2,
               u'2nd:exer:linearInterpol',
               u'2nd:exer:linearInterpol'),
              (u'Exercise 25: Test straight line requirement',
               2,
               u'2nd:exer:testStraightLine',
               u'2nd:exer:testStraightLine'),
              (u'Exercise 26: Fit straight line to data',
               2,
               u'2nd:exer:fitLine',
               u'2nd:exer:fitLine'),
              (u'Remarks', 3, None, '___sec66'),
              (u'Exercise 27: Fit sines to straight line',
               2,
               u'2nd:exer:fitSines',
               u'2nd:exer:fitSines'),
              (u'Remarks', 3, None, '___sec68'),
              (u'Exercise 28: Count occurrences of a string in a string',
               2,
               u'2nd:exer:countTextString',
               u'2nd:exer:countTextString'),
              (u'Computing integrals', 0, u'sec:integrals', u'sec:integrals'),
              (u'Basic ideas of numerical integration',
               1,
               u'sec:integrals:basic',
               u'sec:integrals:basic'),
              (u'Computational example', 3, None, '___sec72'),
              (u'The composite trapezoidal rule',
               1,
               u'sec:integrals:trap',
               u'sec:integrals:trap'),
              (u'The general formula',
               2,
               u'sec:integrals:formula',
               u'sec:integrals:formula'),
              (u'Implementation',
               2,
               u'sec:integrals:trap:impl',
               u'sec:integrals:trap:impl'),
              (u'Specific or general implementation?', 3, None, '___sec76'),
              (u'Implementation with functions', 3, None, '___sec77'),
              (u'Solving our specific problem in a session',
               3,
               None,
               '___sec78'),
              (u'Solving our specific problem in a program',
               3,
               None,
               '___sec79'),
              (u'Alternative flat special-purpose implementation',
               2,
               None,
               '___sec80'),
              (u'The composite midpoint method',
               1,
               u'sec:integrals:Midpoint',
               u'sec:integrals:Midpoint'),
              (u'The idea', 3, None, '___sec82'),
              (u'The general formula', 2, None, '___sec83'),
              (u'Implementation',
               2,
               u'sec:midpoint:code',
               u'sec:midpoint:code'),
              (u'Comparing the trapezoidal and the midpoint methods',
               2,
               None,
               '___sec85'),
              (u'Testing', 1, None, '___sec86'),
              (u'Problems with brief testing procedures',
               2,
               None,
               '___sec87'),
              (u'Proper test procedures',
               2,
               u'sec:integrals:testprocs',
               u'sec:integrals:testprocs'),
              (u'Hand-computed results', 3, None, '___sec89'),
              (u'Solving a problem without numerical errors',
               3,
               None,
               '___sec90'),
              (u'Demonstrating correct convergence rates',
               3,
               None,
               '___sec91'),
              (u'Finite precision of floating-point numbers',
               2,
               u'sec:integrals:finite_prec',
               u'sec:integrals:finite_prec'),
              (u'Constructing unit tests and writing test functions',
               2,
               u'sec:integrals:test:functions',
               u'sec:integrals:test:functions'),
              (u'Hand-computed numerical results', 3, None, '___sec94'),
              (u'Solving a problem without numerical errors',
               3,
               None,
               '___sec95'),
              (u'Demonstrating correct convergence rates',
               3,
               None,
               '___sec96'),
              (u'Vectorization', 1, None, '___sec97'),
              (u'Vectorizing the midpoint rule', 3, None, '___sec98'),
              (u'Vectorizing the trapezoidal rule', 3, None, '___sec99'),
              (u'Measuring computational speed', 1, None, '___sec100'),
              (u'Double and triple integrals',
               1,
               u'sec:int:double',
               u'sec:int:double'),
              (u'The midpoint rule for a double integral',
               2,
               u'sec:int:double:midpoint',
               u'sec:int:double:midpoint'),
              (u'Derivation via one-dimensional integrals',
               3,
               None,
               '___sec103'),
              (u'Direct derivation', 3, None, '___sec104'),
              (u'Programming a double sum', 3, None, '___sec105'),
              (u'Reusing code for one-dimensional integrals',
               3,
               None,
               '___sec106'),
              (u'Verification via test functions', 3, None, '___sec107'),
              (u'The midpoint rule for a triple integral',
               2,
               None,
               '___sec108'),
              (u'Theory', 3, None, '___sec109'),
              (u'Implementation', 3, None, '___sec110'),
              (u'Monte Carlo integration for complex-shaped domains',
               2,
               u'sec:int:complex:domain',
               u'sec:int:complex:domain'),
              (u'The Monte Carlo integration algorithm',
               3,
               None,
               '___sec112'),
              (u'Implementation', 3, None, '___sec113'),
              (u'Verification', 3, None, '___sec114'),
              (u'Test function for function with random numbers',
               3,
               None,
               '___sec115'),
              (u'Integral over a circle', 3, None, '___sec116'),
              (u'Exercises', 1, None, '___sec117'),
              (u'Exercise 29: Hand calculations for the trapezoidal method',
               2,
               u'sec:exer:trap:hand',
               u'sec:exer:trap:hand'),
              (u'Exercise 30: Hand calculations for the midpoint method',
               2,
               u'sec:exer:midpt:hand',
               u'sec:exer:midpt:hand'),
              (u'Exercise 31: Compute a simple integral',
               2,
               u'sec:exer:trap:mid:parabola',
               u'sec:exer:trap:mid:parabola'),
              (u'Exercise 32: Hand-calculations with sine integrals',
               2,
               u'sec:exer:hand:sine',
               u'sec:exer:hand:sine'),
              (u'Exercise 33: Make test functions for the midpoint method',
               2,
               u'sec:exer:test:midpoint',
               u'sec:exer:test:midpoint'),
              (u'Exercise 34: Explore rounding errors with large numbers',
               2,
               u'sec:exer:test:roundoff',
               u'sec:exer:test:roundoff'),
              (u'Exercise 35: Write test functions for $\\int_0^4\\sqrt{x}dx$',
               2,
               u'sec:exer:test:convrates:sqrt',
               u'sec:exer:test:convrates:sqrt'),
              (u'Remarks', 3, None, '___sec125'),
              (u'Exercise 36: Rectangle methods',
               2,
               u'sec:exer:rectangleMethod',
               u'sec:exer:rectangleMethod'),
              (u'Exercise 37: Adaptive integration',
               2,
               u'sec:exer:adaptive:int',
               u'sec:exer:adaptive:int'),
              (u'Remarks', 3, None, '___sec128'),
              (u'Exercise 38: Integrating x raised to x',
               2,
               u'sec:exer:integrate:x2x',
               u'sec:exer:integrate:x2x'),
              (u'Exercise 39: Integrate products of sine functions',
               2,
               u'sec:exer:sine:products',
               u'sec:exer:sine:products'),
              (u'Exercise 40: Revisit fit of sines to a function',
               2,
               u'sec:exer:revisitFitSines',
               u'sec:exer:revisitFitSines'),
              (u'Exercise 41: Derive the trapezoidal rule for a double integral',
               2,
               u'sec:exer:trapezoidal:2D',
               u'sec:exer:trapezoidal:2D'),
              (u'Exercise 42: Compute the area of a triangle by Monte Carlo integration',
               2,
               u'sec:exer:MC:ellipse',
               u'sec:exer:MC:ellipse'),
              (u'Solving ordinary differential equations',
               0,
               u'5th:SolvODEs',
               u'5th:SolvODEs'),
              (u'Population growth', 1, u'sec:de:pg', u'sec:de:pg'),
              (u'Derivation of the model',
               2,
               u'sec:de:pg:model',
               u'sec:de:pg:model'),
              (u'Numerical solution',
               2,
               u'sec:de:pg:numerics',
               u'sec:de:pg:numerics'),
              (u'Programming the Forward Euler scheme; the special case',
               2,
               u'sec:de:pg:prog1',
               u'sec:de:pg:prog1'),
              (u'Understanding the Forward Euler method',
               2,
               u'sec:de:pg:geom',
               u'sec:de:pg:geom'),
              (u'Programming the Forward Euler scheme; the general case',
               2,
               u'sec:de:FE:gen',
               u'sec:de:FE:gen'),
              (u'Making the population growth model more realistic',
               2,
               None,
               '___sec141'),
              (u'Verification: exact linear solution of the discrete equations',
               2,
               u'sec:de:growth:test:linear',
               u'sec:de:growth:test:linear'),
              (u'Spreading of diseases', 1, None, '___sec143'),
              (u'Spreading of a flu', 2, u'sec:de:flu', u'sec:de:flu'),
              (u'A Forward Euler method for the differential equation system',
               2,
               u'sec:de:flu:FE',
               u'sec:de:flu:FE'),
              (u'Programming the numerical method; the special case',
               2,
               u'sec:de:flu:prog:spec',
               u'sec:de:flu:prog:spec'),
              (u'Outbreak or not', 2, None, '___sec147'),
              (u'Abstract problem and notation',
               2,
               u'sec:de:flu:generic',
               u'sec:de:flu:generic'),
              (u'Programming the numerical method; the general case',
               2,
               u'sec:de:flu:prog:generic',
               u'sec:de:flu:prog:generic'),
              (u'Time-restricted immunity', 2, None, '___sec150'),
              (u'Incorporating vaccination',
               2,
               u'sec:de:flu:vaccine',
               u'sec:de:flu:vaccine'),
              (u'Discontinuous coefficients: a vaccination campaign',
               2,
               u'sec:de:flu:vaccine:discont',
               u'sec:de:flu:vaccine:discont'),
              (u'Oscillating one-dimensional systems',
               1,
               u'sec:de:vib',
               u'sec:de:vib'),
              (u'Derivation of a simple model', 2, None, '___sec154'),
              (u'Numerical solution', 2, None, '___sec155'),
              (u'Programming the numerical method; the special case',
               2,
               u'sec:de:vib:special',
               u'sec:de:vib:special'),
              (u'A magic fix of the numerical method', 2, None, '___sec157'),
              (u"The 2nd-order Runge-Kutta method (or Heun's method)",
               2,
               u'sec:de:osc:Heun',
               u'sec:de:osc:Heun'),
              (u'Software for solving ODEs',
               2,
               u'sec:de:osc:odespy',
               u'sec:de:osc:odespy'),
              (u'The 4th-order Runge-Kutta method', 2, None, '___sec160'),
              (u'The algorithm', 3, None, '___sec161'),
              (u'Application', 3, None, '___sec162'),
              (u'Implementation', 3, None, '___sec163'),
              (u'Derivation', 3, None, '___sec164'),
              (u'More effects: damping, nonlinearity, and external forces',
               2,
               None,
               '___sec165'),
              (u'The Euler-Cromer scheme', 3, None, '___sec166'),
              (u'The 4-th order Runge-Kutta method', 3, None, '___sec167'),
              (u'Illustration of linear damping', 2, None, '___sec168'),
              (u'Illustration of linear damping with sinusoidal excitation',
               2,
               None,
               '___sec169'),
              (u'Spring-mass system with sliding friction',
               2,
               u'sec:de:vib:ode2:sliding:friction',
               u'sec:de:vib:ode2:sliding:friction'),
              (u'A finite difference method; undamped, linear case',
               2,
               u'sec:de:vib:2nd',
               u'sec:de:vib:2nd'),
              (u'A finite difference method; linear damping',
               2,
               u'sec:de:vib:2nd:damped1',
               u'sec:de:vib:2nd:damped1'),
              (u'Exercises', 1, None, '___sec173'),
              (u'Exercise 43: Geometric construction of the Forward Euler method',
               2,
               u'sec:de:exer:geom',
               u'sec:de:exer:geom'),
              (u'Exercise 44: Make test functions for the Forward Euler method',
               2,
               u'sec:de:exer:FE:test1',
               u'sec:de:exer:FE:test1'),
              (u"Exercise 45: Implement and evaluate Heun's method",
               2,
               u'sec:de:exer:Heun:pg',
               u'sec:de:exer:Heun:pg'),
              (u'Exercise 46: Find an appropriate time step; logistic model',
               2,
               u'sec:de:exer:logistic:dtopt',
               u'sec:de:exer:logistic:dtopt'),
              (u'Exercise 47: Find an appropriate time step; SIR model',
               2,
               u'sec:de:exer:SIR:dtopt',
               u'sec:de:exer:SIR:dtopt'),
              (u'Exercise 48: Model an adaptive vaccination campaign',
               2,
               u'sec:de:exer:SIRV:padapt',
               u'sec:de:exer:SIRV:padapt'),
              (u'Exercise 49: Make a SIRV model with time-limited effect of vaccination',
               2,
               u'sec:de:exer:SIRV:padapt_time_limited',
               u'sec:de:exer:SIRV:padapt_time_limited'),
              (u'Exercise 50: Refactor a flat program',
               2,
               u'sec:de:exer:vib:FE:func',
               u'sec:de:exer:vib:FE:func'),
              (u'Exercise 51: Simulate oscillations by a general ODE solver',
               2,
               u'sec:de:exer:vib:ode_FE',
               u'sec:de:exer:vib:ode_FE'),
              (u'Exercise 52: Compute the energy in oscillations',
               2,
               u'sec:de:exer:vib:energy',
               u'sec:de:exer:vib:energy'),
              (u'Exercise 53: Use a Backward Euler scheme for population growth',
               2,
               u'sec:de:exer:pg:BE',
               u'sec:de:exer:pg:BE'),
              (u'Exercise 54: Use a Crank-Nicolson scheme for population growth',
               2,
               u'sec:de:exer:pg:CN',
               u'sec:de:exer:pg:CN'),
              (u'Exercise 55: Understand finite differences via Taylor series',
               2,
               u'sec:de:exer:fd:Taylor',
               u'sec:de:exer:fd:Taylor'),
              (u'Exercise 56: Use a Backward Euler scheme for oscillations',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u'Remarks', 3, None, '___sec188'),
              (u"Exercise 57: Use Heun's method for the SIR model",
               2,
               u'sec:de:exer:SIR:Heun',
               u'sec:de:exer:SIR:Heun'),
              (u'Exercise 58: Use Odespy to solve a simple ODE',
               2,
               u'sec:de:exer:odespy:decay',
               u'sec:de:exer:odespy:decay'),
              (u'Exercise 59: Set up a Backward Euler scheme for oscillations',
               2,
               u'sec:de:exer:osc:BE',
               u'sec:de:exer:osc:BE'),
              (u'Exercise 60: Set up a Forward Euler scheme for nonlinear and damped oscillations',
               2,
               u'sec:de:exer:osc:FE:general',
               u'sec:de:exer:osc:FE:general'),
              (u'Exercise 61: Discretize an initial condition',
               2,
               u'sec:de:exer:osc:2nd:V0ic',
               u'sec:de:exer:osc:2nd:V0ic'),
              (u'Solving partial differential equations',
               0,
               u'6th:SolvPDEs',
               u'6th:SolvPDEs'),
              (u'Finite difference methods',
               1,
               u'6th:SolvPDEs:MOLandFE',
               u'6th:SolvPDEs:MOLandFE'),
              (u'Reduction of a PDE to a system of ODEs',
               2,
               u'sec:pde:diff1D:reduce',
               u'sec:pde:diff1D:reduce'),
              (u'Construction of a test problem with known discrete solution',
               2,
               u'sec:pde:diff1D:testproblem',
               u'sec:pde:diff1D:testproblem'),
              (u'Implementation: Forward Euler method', 2, None, '___sec198'),
              (u'Application: heat conduction in a rod',
               2,
               u'sec:pde:diff1D:rod',
               u'sec:pde:diff1D:rod'),
              (u'Vectorization', 2, None, '___sec200'),
              (u'Using Odespy to solve the system of ODEs',
               2,
               None,
               '___sec201'),
              (u'Implicit methods', 2, None, '___sec202'),
              (u'Exercises', 1, None, '___sec203'),
              (u'Exercise 62: Simulate a diffusion equation by hand',
               2,
               u'sec:pde:diff1D:exer:handFE',
               u'sec:pde:diff1D:exer:handFE'),
              (u'Exercise 63: Compute temperature variations in the ground',
               2,
               u'sec:pde:diff1D:exer:groundtemp',
               u'sec:pde:diff1D:exer:groundtemp'),
              (u'Exercise 64: Compare implicit methods',
               2,
               u'sec:pde:diff1D:exer:compare:implicit',
               u'sec:pde:diff1D:exer:compare:implicit'),
              (u'Exercise 65: Explore adaptive and implicit methods',
               2,
               u'sec:pde:diff1D:exer:groundtemp:adapt',
               u'sec:pde:diff1D:exer:groundtemp:adapt'),
              (u'Exercise 66: Investigate the $\\theta$ rule',
               2,
               u'sec:pde:diff1D:exer:CN',
               u'sec:pde:diff1D:exer:CN'),
              (u'Remarks', 3, None, '___sec209'),
              (u'Exercise 67: Compute the diffusion of a Gaussian peak',
               2,
               u'sec:pde:diff1D:exer:Gaussian',
               u'sec:pde:diff1D:exer:Gaussian'),
              (u'Remarks', 3, None, '___sec211'),
              (u'Exercise 68: Vectorize a function for computing the area of a polygon',
               2,
               u'2nd:exer:area:polygon2',
               u'2nd:exer:area:polygon2'),
              (u'Exercise 69: Explore symmetry',
               2,
               u'sec:pde:diff1D:exer:Gaussian:symm',
               u'sec:pde:diff1D:exer:Gaussian:symm'),
              (u'Remarks', 3, None, '___sec214'),
              (u'Exercise 70: Compute solutions as $t\\rightarrow\\infty$',
               2,
               u'sec:pde:diff1D:exer:stationary',
               u'sec:pde:diff1D:exer:stationary'),
              (u'Remarks', 3, None, '___sec216'),
              (u'Exercise 71: Solve a two-point boundary value problem',
               2,
               u'sec:pde:diff1D:exer:stationary2',
               u'sec:pde:diff1D:exer:stationary2'),
              (u'Solving nonlinear algebraic equations',
               0,
               u'4th:NonlinAlgEq',
               u'4th:NonlinAlgEq'),
              (u'Brute force methods',
               1,
               u'4th:bruteforce',
               u'4th:bruteforce'),
              (u'Brute force root finding', 2, None, '___sec220'),
              (u'Numerical algorithm', 3, None, '___sec221'),
              (u'Implementation', 3, None, '___sec222'),
              (u'Brute force optimization', 2, None, '___sec223'),
              (u'Numerical algorithm', 3, None, '___sec224'),
              (u'Implementation', 3, None, '___sec225'),
              (u'Model problem for algebraic equations',
               2,
               None,
               '___sec226'),
              (u"Newton's method",
               1,
               u'4th:NonlinAlgEq:Newt',
               u'4th:NonlinAlgEq:Newt'),
              (u"Deriving and implementing Newton's method",
               2,
               None,
               '___sec228'),
              (u'Making a more efficient and robust implementation',
               2,
               u'4th:Newton:robust',
               u'4th:Newton:robust'),
              (u'The secant method',
               1,
               u'4th:NonlinAlgEq:Secant',
               u'4th:NonlinAlgEq:Secant'),
              (u'The bisection method',
               1,
               u'4th:NonlinAlgEq:Bisect',
               u'4th:NonlinAlgEq:Bisect'),
              (u'Rate of convergence',
               1,
               u'4th:NonlinAlgEq:RateConv',
               u'4th:NonlinAlgEq:RateConv'),
              (u'Solving multiple nonlinear algebraic equations',
               1,
               u'nonlin:Newton:systems',
               u'nonlin:Newton:systems'),
              (u'Abstract notation',
               2,
               u'nonlin:Newton:systems:notation',
               u'nonlin:Newton:systems:notation'),
              (u'Taylor expansions for multi-variable functions',
               2,
               None,
               '___sec235'),
              (u"Newton's method", 2, None, '___sec236'),
              (u'Implementation', 2, None, '___sec237'),
              (u'Exercises', 1, None, '___sec238'),
              (u"Exercise 72: Understand why Newton's method can fail",
               2,
               u'4th:exer:Newton:failure',
               u'4th:exer:Newton:failure'),
              (u'Exercise 73: See if the secant method fails',
               2,
               u'4th:exer:Secant:failure',
               u'4th:exer:Secant:failure'),
              (u'Exercise 74: Understand why the bisection method cannot fail',
               2,
               u'4th:exer:Bisection:failure',
               u'4th:exer:Bisection:failure'),
              (u"Exercise 75: Combine the bisection method with Newton's method",
               2,
               u'4th:exer:Bisection:Newton',
               u'4th:exer:Bisection:Newton'),
              (u"Exercise 76: Write a test function for Newton's method",
               2,
               u'4th:exer:NewtonHand',
               u'4th:exer:NewtonHand'),
              (u'Exercise 77: Solve nonlinear equation for a vibrating beam',
               2,
               u'4th:exer:beam:vib',
               u'4th:exer:beam:vib'),
              (u'References', 0, None, '___sec245')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\J}{\boldsymbol{J}}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\c}{\boldsymbol{c}}
$$




    
<a name="part0026"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._p4c-solarized-Matlab025.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._p4c-solarized-Matlab027.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="4th:NonlinAlgEq:Newt">Newton's method</h1>

<p>
<em>Newton's method</em>, also known as <em>Newton-Raphson's method</em>, is a very
famous and widely used method for solving nonlinear algebraic
equations. Compared to the other methods we will consider, it is
generally the fastest one (usually by far). It does not guarantee
that an existing solution will be found, however.

<p>
A fundamental idea of numerical methods for nonlinear
equations is to construct a series of linear equations (since we
know how to solve linear equations) and hope that
the solutions of these linear equations bring
us closer and closer to the solution of the nonlinear equation.
The idea will be clearer when we present Newton's method and the secant method.

<h2 id="___sec228">Deriving and implementing Newton's method </h2>

<p>
Figure <a href="#fig:illustrNewton">62</a> shows the \( f(x) \) function in
our model equation \( x^2-9=0 \). Numerical methods for algebraic equations
require us to guess at a solution first. Here, this guess is called
\( x_0 \). The fundamental idea of Newton's method is to approximate
the original function \( f(x) \) by a straight line, i.e., a linear
function, since it is straightforward to solve linear equations.
There are infinitely many choices of how to approximate \( f(x) \) by
a straight line. Newton's method applies the tangent of \( f(x) \) at
\( x_0 \), see the rightmost tangent in Figure <a href="#fig:illustrNewton">62</a>.
This linear tangent function crosses the \( x \) axis at a point we
call \( x_1 \). This is (hopefully) a better approximation to the solution
of \( f(x)=0 \) than \( x_0 \). The next fundamental idea is to repeat
this process. We find the tangent of \( f \) at \( x_1 \), compute where it
crosses the \( x \) axis, at a point called \( x_2 \), and repeat the process
again. Figure <a href="#fig:illustrNewton">62</a> shows that the process brings
us closer and closer to the left. It remains, however, to see if
we hit \( x=3 \) or come sufficiently close to this solution.

<p>
<center> <!-- figure label: --> <div id="fig:illustrNewton"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 62:  Illustrates the idea of Newton's method with \( f(x) = x^2 - 9 \), repeatedly solving for crossing of tangent lines with the \( x \) axis.  <!-- caption label: fig:illustrNewton --> </p></center>
<p><img src="figs/fig4_4.png" align="bottom" width=400></p>
</center>

<p>
How do we compute the tangent of a function \( f(x) \) at a point \( x_0 \)?
The tangent function, here called \( \tilde f(x) \), is linear and has two
properties:

<ol>
<li> the slope equals to \( f'(x_0) \)</li>
<li> the tangent touches the \( f(x) \) curve at \( x_0 \)</li>
</ol>

So, if we write the tangent function as \( \tilde f(x)=ax+b \), we must
require \( \tilde f'(x_0)=f'(x_0) \) and \( \tilde f(x_0)=f(x_0) \), resulting in

$$ \tilde f(x) = f(x_0) + f'(x_0)(x - x_0)\thinspace . $$

<p>
The key step in Newton's method is to find where the tangent crosses
the \( x \) axis, which means solving \( \tilde f(x)=0 \):

$$ \tilde f(x)=0\quad\Rightarrow\quad x = x_0 - \frac{f(x_0)}{f'(x_0)}
\thinspace .$$

This is our new candidate point, which we call \( x_1 \):

$$ x_1 = x_0 - \frac{f(x_0)}{f'(x_0)}\thinspace . $$

With \( x_0 = 1000 \), we get \( x_1 \approx 500 \), which is in accordance
with the graph in Figure <a href="#fig:illustrNewton">62</a>. Repeating the
process, we get

$$ x_2 = x_1 - \frac{f(x_1)}{f'(x_1)}\approx 250\thinspace . $$

<p>
The general scheme of Newton's method may be written as

$$
\begin{equation}
x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)},\quad n=0,1,2,\ldots
\tag{162}
\end{equation}
$$

The computation in <a href="#mjx-eqn-162">(162)</a> is repeated until
\( f\left(x_n\right) \) is close enough to zero. More precisely,
we test if \( |f(x_n)| < \epsilon  \), with \( \epsilon \) being a small
number.

<p>
We moved from 1000 to 250 in two iterations, so it is exciting to see
how fast we can approach the solution \( x=3 \).
A computer program can automate the calculations. Our first
try at implementing Newton's method is in a function <code>naive_Newton</code>:
<!-- begin verbatim block  mcod-->
<pre><code>function result = naive_Newton(f,dfdx,starting_value,eps)
    x = starting_value;
    while abs(f(x)) &gt; eps
        x = x - f(x)/dfdx(x);
    end
    result = x;
end
</code></pre>
<!-- end verbatim block -->
The argument <code>x</code> is the starting value, called \( x_0 \) in our previous
description.
To solve the problem \( x^2=9 \) we also need to implement

<p>
<!-- begin verbatim block  mcod-->
<pre><code>function result = f(x)
    result = x^2 - 9;
end

function result = dfdx(x)
    result = 2*x;
end
</code></pre>
<!-- end verbatim block -->

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>Why not use an array for the \( x \) approximations?</b>
<p>
Newton's method is normally formulated with an <em>iteration index</em> \( n \),

$$ x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}\thinspace .$$

Seeing such an index, many would implement this as

<p>
<!-- begin verbatim block  mcod-->
<pre><code>x(n+1) = x(x) - f(x(n))/dfdx(x(n));
</code></pre>
<!-- end verbatim block -->
Such an array is fine, but requires storage of all the approximations.
In large industrial applications, where Newton's method solves
millions of equations at once, one cannot afford to store all the
intermediate approximations in memory, so then it is important to
understand that the algorithm in Newton's method has no more need
for \( x_n \) when \( x_{n+1} \) is computed. Therefore, we can work with
one variable <code>x</code> and overwrite the previous value:

<p>
<!-- begin verbatim block  cod-->
<pre><code>x = x - f(x)/dfdx(x)
</code></pre>
<!-- end verbatim block -->
</div>


<p>
Running <code>naive_Newton(f, dfdx, 1000, eps=0.001)</code> results in the approximate
solution 3.000027639. A smaller value of <code>eps</code> will produce a more
accurate solution. Unfortunately, the plain <code>naive_Newton</code> function
does not return how many iterations it used, nor does it print out
all the approximations \( x_0,x_1,x_2,\ldots \), which would indeed be a nice
feature. If we insert such a printout, a rerun results in

<p>
<!-- begin verbatim block  dat-->
<pre><code>500.0045
250.011249919
125.02362415
62.5478052723
31.3458476066
15.816483488
8.1927550496
4.64564330569
3.2914711388
3.01290538807
3.00002763928
</code></pre>
<!-- end verbatim block -->
We clearly see that the iterations approach the solution quickly.
This speed of the search for the solution is the primary strength of
Newton's method compared to other methods.

<h2 id="4th:Newton:robust">Making a more efficient and robust implementation</h2>

<p>
The <code>naive_Newton</code> function works fine for the example we are considering
here. However, for more general use, there are some pitfalls that
should be fixed in an improved version of the code. An example
may illustrate what the problem is: let us solve \( \tanh(x)=0 \), which
has solution \( x=0 \). With \( |x_0|\leq 1.08 \) everything works fine. For
example, \( x_0 \) leads to six iterations if \( \epsilon=0.001 \):

<p>
<!-- begin verbatim block  dat-->
<pre><code>-1.05895313436
0.989404207298
-0.784566773086
0.36399816111
-0.0330146961372
2.3995252668e-05
</code></pre>
<!-- end verbatim block -->
Adjusting \( x_0 \) slightly to 1.09 gives division by zero! The
approximations computed by Newton's method become

<p>
<!-- begin verbatim block  dat-->
<pre><code>-1.09331618202
1.10490354324
-1.14615550788
1.30303261823
-2.06492300238
13.4731428006
-1.26055913647e+11
</code></pre>
<!-- end verbatim block -->
The division by zero is caused by \( x_7=-1.26055913647\cdot 10^{11} \),
because \( \tanh(x_7) \) is 1.0 to machine precision, and then
\( f'(x)=1 - \tanh(x)^2 \) becomes zero in the denominator in Newton's
method.

<p>
The underlying problem, leading to the division by zero in the above
example, is that Newton's method <em>diverges</em>: the approximations move
further and further away from \( x=0 \). If it had not been for the
division by zero, the condition in the <code>while</code> loop would always
be true and the loop would run forever. Divergence of Newton's method
occasionally happens, and the remedy
is to abort the method when a maximum number of iterations is reached.

<p>
Another disadvantage of the <code>naive_Newton</code> function is that it
calls the \( f(x) \) function twice as many times as necessary. This extra
work is of no concern when \( f(x) \) is fast to evaluate, but in
large-scale industrial software, one call to \( f(x) \) might take hours or days, and then removing unnecessary calls is important. The solution
in our function is to store the call <code>f(x)</code> in a variable (<code>f_value</code>)
and reuse the value instead of making a new call <code>f(x)</code>.

<p>
To summarize, we want to write an improved function for implementing
Newton's method where we

<ul>
 <li> avoid division by zero</li>
 <li> allow a maximum number of iterations</li>
 <li> avoid the extra evaluation to \( f(x) \)</li>
</ul>

A more robust and efficient version of the function, inserted in a
complete program
<a href="https://github.com/hplgit/prog4comp/tree/master/src/m/Newtons_method.m" target="_self"><tt>Newtons_method.m</tt></a>
for solving \( x^2 - 9 = 0 \),
is listed below.

<p>
<!-- begin verbatim block  mpro-->
<pre><code>function Newtons_method()
    f = @(x) x^2 - 9;
    dfdx = @(x) 2*x;
    eps = 1e-6;
    x0 = 1000;
    [solution,no_iterations] = Newton(f, dfdx, x0, eps);
    if no_iterations &gt; 0   % Solution found
        fprintf('Number of function calls: %d\n', 1 + 2*no_iterations);
        fprintf('A solution is: %f\n', solution)
    else
        fprintf('Abort execution.\n')
    end
end

function [solution, no_iterations] = Newton(f, dfdx, x0, eps)
    x = x0;
    f_value = f(x);
    iteration_counter = 0;
    while abs(f_value) &gt; eps &amp;&amp; iteration_counter &lt; 100
        try
            x = x - (f_value)/dfdx(x);
        catch
            fprintf('Error! - derivative zero for x = \n', x)
            exit(1)
        end
        f_value = f(x);
        iteration_counter = iteration_counter + 1;
    end
    % Here, either a solution is found, or too many iterations
    if abs(f_value) &gt; eps
        iteration_counter = -1;
    end
    solution = x;
    no_iterations = iteration_counter;
end
</code></pre>
<!-- end verbatim block -->

<p>
Handling of the potential division by zero is done by a
<code>try-catch</code> construction, which works as follows. First, Matlab tries to execute the code in the <code>try</code> block, but if something goes wrong there, the <code>catch</code> block is executed instead and the execution is terminated by <code>exit</code>.

<p>
The division by zero will always be detected and the program will be
stopped. The main purpose of our way of treating the division by zero is
to give the user a more informative error message and stop the program
in a gentler way.

<p>
Calling
<code>exit</code>
with an argument different from zero (here <code>1</code>)
signifies that the program stopped because of an error.
It is a good habit to supply the value <code>1</code>, because tools in
the operating system can then be used by other programs to detect
that our program failed.

<p>
To prevent an infinite loop because of divergent iterations, we have
introduced the integer variable <code>iteration_counter</code> to count the
number of iterations in Newton's method.
With <code>iteration_counter</code> we can easily extend the condition in the
<code>while</code> such that no more iterations take place when the number of
iterations reaches 100. We could easily let this limit be an argument
to the function rather than a fixed constant.

<p>
The <code>Newton</code> function returns the approximate solution and the number
of iterations. The latter equals \( -1 \) if the convergence criterion
\( |f(x)| < \epsilon \) was not reached within the maximum number of
iterations. In the calling code, we print out the solution and
the number of function calls. The main cost of a method for
solving \( f(x)=0 \) equations is usually the evaluation of \( f(x) \) and \( f'(x) \),
so the total number of calls to these functions is an interesting
measure of the computational work. Note that in function <code>Newton</code>
there is an initial call to \( f(x) \) and then one call to \( f \) and one
to \( f' \) in each iteration.

<p>
Running <code>Newtons_method.m</code>, we get the following printout on the screen:
<!-- begin verbatim block  dat-->
<pre><code>Number of function calls: 25
A solution is: 3.000000
</code></pre>
<!-- end verbatim block -->
As we did with the integration methods in the chapter <a href="._p4c-solarized-Matlab014.html#sec:integrals">Computing integrals</a>, we will
place our solvers for nonlinear algebraic equations in separate files for easy use by other programs. So, we place <code>Newton</code> in the file <code>Newton.m</code>

<p>
The Newton scheme will work better if the starting value is close to
the solution. A good starting value may often make the difference as
to whether the code actually <em>finds</em> a solution or not.  Because of
its speed, Newton's method is often the method of first choice for
solving nonlinear algebraic equations, even if the scheme is not
guaranteed to work. In cases where the initial guess may be far from
the solution, a good strategy is to run a few iterations with the
bisection method (see the chapter <a href="._p4c-solarized-Matlab028.html#4th:NonlinAlgEq:Bisect">The bisection method</a>) to narrow
down the region where \( f \) is close to zero and then switch to Newton's
method for fast convergence to the solution.

<p>
Newton's method requires the analytical expression for the
derivative \( f'(x) \). Derivation of \( f'(x) \) is not always a reliable
process by hand if \( f(x) \) is a complicated function.
However, Matlab has the Symbolic Math Toolbox, which we may use
to create the required <code>dfdx</code> function (Octave does not (yet) offer
the same possibilities for symbolic computations as Matlab. However,
there is work in progress, e.g. on using SymPy (from Python) from
Octave). In our sample problem, the recipe goes as follows:

<p>
<!-- begin verbatim block  mcod-->
<pre><code>syms x;                   % define x as a mathematical symbol
f_expr = x^2 - 9;         % symbolic expression for f(x)
dfdx_expr = diff(f_expr)  % compute f'(x) symbolically
% Turn f_expr and dfdx_expr into plain Matlab functions
f = matlabFunction(f_expr);
dfdx = matlabFunction(dfdx_expr);
dfdx(5)                   % will print 10
</code></pre>
<!-- end verbatim block -->
The nice feature of this code snippet is that <code>dfdx_expr</code> is the
exact analytical expression for the derivative, <code>2*x</code>, if you
print it out. This is a symbolic expression so we cannot do
numerical computing with it, but the <code>matlabFunction</code>
turns symbolic expressions into callable Matlab functions.

<p>
The next method is the secant method, which is usually slower than
Newton's method, but it does not require an expression for
\( f'(x) \), and it has only one function call per iteration.

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._p4c-solarized-Matlab025.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._p4c-solarized-Matlab027.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

