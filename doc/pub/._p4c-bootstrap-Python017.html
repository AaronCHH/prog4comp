<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Programming for Computations - A Gentle Introduction to Numerical Simulations with Python">
<meta name="keywords" content="DocOnce,computer program,programming,language programming,language computer,MATLAB,Octave,Fortran,C,C++,Python,Maple,Mathematica,syntax,bug,debugging,script (and scripting),algorithm,execute (a program),implement (a program),bug,debugging,simulation,model mathematical,print,program run,program execute,code,comment,instruction,program statement,variable,assignment,calculator,text editor,Emacs,Vim,Gedit,Notepad++,TextWrangler,Spyder,Python  installation,IPython,prompt,program typing,program run,program execute,function,function call,atan,function input parameter,function output parameter,function return,function take a parameter,library,library function,from,module,package,NameError,WARNING,import  math,math,plot,numpy,import numpy,matplotlib.pyplot,import matplotlib.pyplot,linspace,xlabel,ylabel,plot,array,interactive use (of Python),keyboard arrow up/down,prompt,Python shell,IPython,import,operator Arithmetic,parentheses,rounding error,variable type,variable name,object,float,int,str,type conversion,reserved words,variable int,variable float,variable str,variable assignment,type conversion automatic,integer division,rounding error,printing formatted,printf formatting,default,array,array element,zeros,allocate,array index,indexing zero based,indexing one based,Python zero-based indexing,array slice of,copy,graph,hold (on/off),plot figure,title (plot),legend (plot),axis (plot),hardcopy (plot),format png,matrix mat,transpose (of matrix),matrix vector product,linear algebra,matrix,vector,error message,debugging,debugger,try-exception,exception handling,program crash,program testing,testing,program verification,verification,validation,list,tuple,raw input,program input,program output,input,symbolic computations,symbolic operations,symbolic simplifications,SymPy,library SymPy,WolframAlpha,Mathematica,Sage (symbolic package),variable delete,Python documentation,garbage collection,long lines (splitting of),fast code,commenting code,if,elif,else,colon,indent,boolean,boolean expression,True,False,boolean True,boolean False,pseudo code,random walk,random (function),import random (function),operator Logical,def,function,function definition,return,argument,parameter input,parameter output,main program,return value,variable local,variable global,argument keyword,argument named,argument ordinary,argument positional,doc string,function handle,function local,function global,function nested,lambda function,range,loop for,for loop,loop iteration,loop index,loop double,loop multiple,loop nested,linear algebra,while loop,loop while,loop infinite,loop iteration,loop index,stop program (Ctrl+c),list,list append,list convert to array,list delete,list create,tuple,list comprehension,read (from file),write (to file),loadtxt,savetxt,array sorting,Leibniz pi,Euler pi,programming game,linear interpolation,least squares method,Fourier series,integral analytically,integral exact,integral numerically,integral approximately,Trapezoidal rule,composite trapezoidal rule,integration points,implementation specific,implementation general,import module,module,test block,code re-use,flat program,program flat,error function (erf),Midpoint method,composite midpoint method,Simpson's rule,Gauss quadrature,bug,unit tests,testing procedures,convergence rate,rate of convergence,error asymptotic,finite precision (of float),floating point number (float),error rounding,error tolerance,difference absolute,difference relative,assert (function),function assert,nose (testing),py.test,test function,vectorization,computational speed (measuring),domain,double integral midpoint,double sum,code re-use,triple integral midpoint,domain,domain complex,domain,Monte Carlo integration,seed (random generators),dynamical system,scheme,differential equation first-order,model mathematical,model differential equation,model computational,exp math notation,finite difference method,mesh,mesh uniform,mesh points,forward difference approximation,difference forward,Forward Euler scheme,Euler's method,numerical scheme,demo function,logistic model carrying capacity,SIR model,compartment model,mathematical modeling,scalar ODE,ODE scalar,vector ODE,ODE vector,system of ODEs,asarray (function),function asarray,discontinuous coefficient,spring oscillations,spring damping of,differential equation second-order,simple pendulum,second-order ODE rewritten as two first-order ODEs,difference forward,difference backward,Heun's method,Runge-Kutta, 2nd-order method,2nd-order Runge-Kutta method,RK2,difference centered,nonlinear algebraic equation,Runge-Kutta-Fehlberg,Crank-Nicolson method,spring damping of,spring nonlinear,spring linear,scaling,resonance,Verlet integration,Crank-Nicolson method,Taylor series,PDE,heat equation,diffusion equation,source term,domain,initial conditions,boundary conditions,MOL forward Euler,method of lines,MOL,mesh points,cell,method of lines,class,closure,unstable solutions,instability,stability criterion,scaling,vectorization,tridiagonal matrix,matrix tridiagonal,theta rule,Poisson equation,Laplace equation,root finding,brute force method,code robust,divergence,code exception,code try-except,Newton starting value,sys.exit,exit (sys),return None,rate of convergence,Idle,Emacs,Vim,Gedit,TextWrangler,Notepad++">

<title>Programming for Computations - A Gentle Introduction to Numerical Simulations with Python</title>

<!-- Bootstrap style: bootswatch_journal -->
<link href="http://netdna.bootstrapcdn.com/bootswatch/3.1.1/journal/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="http://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Let pre tags for code blocks have the same color as the surroundings */
pre { color: inherit; background-color: transparent; }

/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Why learn programming?', 3, None, '___sec1'),
              (u'Target audience and background knowledge',
               3,
               None,
               '___sec2'),
              (u'Numerical methods', 3, None, '___sec3'),
              (u'The computer language: Python', 3, None, '___sec4'),
              (u'How this book is different', 3, None, '___sec5'),
              (u'Supplementary materials', 3, None, '___sec6'),
              (u'Acknowledgments', 3, None, '___sec7'),
              (u'The first few steps',
               0,
               u'1st:TheFirstFewSteps',
               u'1st:TheFirstFewSteps'),
              (u'What is a program? And what is programming?',
               1,
               None,
               '___sec9'),
              (u'A Python program with variables', 1, u'1st:ex1', u'1st:ex1'),
              (u'The program', 2, None, '___sec11'),
              (u'Dissection of the program', 2, None, '___sec12'),
              (u'Why not just use a pocket calculator?', 2, None, '___sec13'),
              (u'Why you must use a text editor to write programs',
               2,
               None,
               '___sec14'),
              (u'Installation of Python', 2, None, '___sec15'),
              (u'Write and run your first program', 2, None, '___sec16'),
              (u'A Python program with a library function',
               1,
               u'1st:ex2',
               u'1st:ex2'),
              (u'A Python program with vectorization and plotting',
               1,
               u'1st:ex3',
               u'1st:ex3'),
              (u'More basic concepts', 1, None, '___sec19'),
              (u'Using Python interactively', 2, None, '___sec20'),
              (u'Arithmetics, parentheses and rounding errors',
               2,
               None,
               '___sec21'),
              (u'Variables and objects', 2, None, '___sec22'),
              (u'Integer division', 2, None, '___sec23'),
              (u'Formatting text and numbers', 2, None, '___sec24'),
              (u'Arrays', 2, None, '___sec25'),
              (u'Plotting', 2, None, '___sec26'),
              (u'Error messages and warnings', 2, None, '___sec27'),
              (u'Input data', 2, None, '___sec28'),
              (u'Symbolic computations', 2, None, '___sec29'),
              (u'Concluding remarks', 2, None, '___sec30'),
              (u'Exercises', 1, None, '___sec31'),
              (u'Exercise 1: Error messages',
               2,
               u'1st:exer:ErrorMessages',
               u'1st:exer:ErrorMessages'),
              (u'Exercise 2: Volume of a cube',
               2,
               u'1st:exer:cubeVolume',
               u'1st:exer:cubeVolume'),
              (u'Exercise 3: Area and circumference of a circle',
               2,
               u'1st:exer:areaCircle',
               u'1st:exer:areaCircle'),
              (u'Exercise 4: Volumes of three cubes',
               2,
               u'1st:exer:volumes3cubes',
               u'1st:exer:volumes3cubes'),
              (u'Exercise 5: Average of integers',
               2,
               u'1st:exer:averageOf5Integers',
               u'1st:exer:averageOf5Integers'),
              (u'Exercise 6: Interactive computing of volume and area',
               2,
               u'1st:exer:cubeVolInteractively',
               u'1st:exer:cubeVolInteractively'),
              (u'Exercise 7: Peculiar results from division',
               2,
               u'1st:exer:intDivInteractively',
               u'1st:exer:intDivInteractively'),
              (u'Exercise 8: Update variable at command prompt',
               2,
               u'1st:exer:updateVarInteractively',
               u'1st:exer:updateVarInteractively'),
              (u'Exercise 9: Formatted print to screen',
               2,
               u'1st:exer:printfScreen',
               u'1st:exer:printfScreen'),
              (u'Exercise 10: Python documentation and random numbers',
               2,
               u'1st:exer:PythonDocRandom',
               u'1st:exer:PythonDocRandom'),
              (u'Basic constructions',
               0,
               u'2nd:BasicConstructins',
               u'2nd:BasicConstructins'),
              (u'If tests, colon and indentation', 1, None, '___sec43'),
              (u'Functions', 1, u'sec:functions', u'sec:functions'),
              (u'For loops', 1, u'sec:for:loops', u'sec:for:loops'),
              (u'While loops', 1, u'sec:while:loops', u'sec:while:loops'),
              (u'Lists and tuples - alternatives to arrays',
               1,
               u'sec:lists',
               u'sec:lists'),
              (u'Reading from and writing to files',
               1,
               u'sec:file:reading:writing',
               u'sec:file:reading:writing'),
              (u'Exercises', 1, None, '___sec49'),
              (u'Exercise 11: Errors with colon, indent, etc.',
               2,
               u'2nd:exer:ErrorsColonIndent',
               u'2nd:exer:ErrorsColonIndent'),
              (u'Exercise 12: Compare integers a and b',
               2,
               u'2nd:exer:compInt',
               u'2nd:exer:compInt'),
              (u'Exercise 13: Functions for circumference and area of a circle',
               2,
               u'2nd:exer:funcCircArea',
               u'2nd:exer:funcCircArea'),
              (u'Exercise 14: Function for area of a rectangle',
               2,
               u'2nd:exer:funcAreaRectangle',
               u'2nd:exer:funcAreaRectangle'),
              (u'Exercise 15: Area of a polygon',
               2,
               u'2nd:exer:area:polygon',
               u'2nd:exer:area:polygon'),
              (u'Exercise 16: Average of integers',
               2,
               u'2nd:exer:avNInt',
               u'2nd:exer:avNInt'),
              (u'Exercise 17: While loop with errors',
               2,
               u'2nd:exer:whileLoopErrors',
               u'2nd:exer:whileLoopErrors'),
              (u'Exercise 18: Area of rectangle versus circle',
               2,
               u'2nd:exer:areaRectCircle',
               u'2nd:exer:areaRectCircle'),
              (u'Exercise 19: Find crossing points of two graphs',
               2,
               u'2nd:exer:Cross2Graphs',
               u'2nd:exer:Cross2Graphs'),
              (u'Exercise 20: Sort array with numbers',
               2,
               u'2nd:exer:sortNumbers',
               u'2nd:exer:sortNumbers'),
              (u'Exercise 21: Compute $\\pi$',
               2,
               u'2nd:exer:computingPi',
               u'2nd:exer:computingPi'),
              (u'Exercise 22: Compute combinations of sets',
               2,
               u'2nd:exer:combinatorics1',
               u'2nd:exer:combinatorics1'),
              (u'Exercise 23: Frequency of random numbers',
               2,
               u'2nd:exer:numberOccurrence',
               u'2nd:exer:numberOccurrence'),
              (u'Remarks', 3, None, '___sec63'),
              (u'Exercise 24: Game 21',
               2,
               u'2nd:exer:Game21',
               u'2nd:exer:Game21'),
              (u'Exercise 25: Linear interpolation',
               2,
               u'2nd:exer:linearInterpol',
               u'2nd:exer:linearInterpol'),
              (u'Exercise 26: Test straight line requirement',
               2,
               u'2nd:exer:testStraightLine',
               u'2nd:exer:testStraightLine'),
              (u'Exercise 27: Fit straight line to data',
               2,
               u'2nd:exer:fitLine',
               u'2nd:exer:fitLine'),
              (u'Remarks', 3, None, '___sec68'),
              (u'Exercise 28: Fit sines to straight line',
               2,
               u'2nd:exer:fitSines',
               u'2nd:exer:fitSines'),
              (u'Remarks', 3, None, '___sec70'),
              (u'Exercise 29: Count occurrences of a string in a string',
               2,
               u'2nd:exer:countTextString',
               u'2nd:exer:countTextString'),
              (u'Remarks', 3, None, '___sec72'),
              (u'Computing integrals', 0, u'sec:integrals', u'sec:integrals'),
              (u'Basic ideas of numerical integration',
               1,
               u'sec:integrals:basic',
               u'sec:integrals:basic'),
              (u'Computational example', 3, None, '___sec75'),
              (u'The composite trapezoidal rule',
               1,
               u'sec:integrals:trap',
               u'sec:integrals:trap'),
              (u'The general formula',
               2,
               u'sec:integrals:formula',
               u'sec:integrals:formula'),
              (u'Implementation',
               2,
               u'sec:integrals:trap:impl',
               u'sec:integrals:trap:impl'),
              (u'Specific or general implementation?', 3, None, '___sec79'),
              (u'Implementation with functions', 3, None, '___sec80'),
              (u'Solving our specific problem in a session',
               3,
               None,
               '___sec81'),
              (u'Solving our specific problem in a program',
               3,
               None,
               '___sec82'),
              (u'Making a module', 2, None, '___sec83'),
              (u'Alternative flat special-purpose implementation',
               2,
               None,
               '___sec84'),
              (u'The composite midpoint method',
               1,
               u'sec:integrals:Midpoint',
               u'sec:integrals:Midpoint'),
              (u'The idea', 3, None, '___sec86'),
              (u'The general formula', 2, None, '___sec87'),
              (u'Implementation',
               2,
               u'sec:midpoint:code',
               u'sec:midpoint:code'),
              (u'Comparing the trapezoidal and the midpoint methods',
               2,
               None,
               '___sec89'),
              (u'Testing', 1, None, '___sec90'),
              (u'Problems with brief testing procedures',
               2,
               None,
               '___sec91'),
              (u'Proper test procedures',
               2,
               u'sec:integrals:testprocs',
               u'sec:integrals:testprocs'),
              (u'Hand-computed results', 3, None, '___sec93'),
              (u'Solving a problem without numerical errors',
               3,
               None,
               '___sec94'),
              (u'Demonstrating correct convergence rates',
               3,
               None,
               '___sec95'),
              (u'Finite precision of floating-point numbers',
               2,
               u'sec:integrals:finite_prec',
               u'sec:integrals:finite_prec'),
              (u'Constructing unit tests and writing test functions',
               2,
               u'sec:integrals:test:functions',
               u'sec:integrals:test:functions'),
              (u'Hand-computed numerical results', 3, None, '___sec98'),
              (u'Solving a problem without numerical errors',
               3,
               None,
               '___sec99'),
              (u'Demonstrating correct convergence rates',
               3,
               None,
               '___sec100'),
              (u'Vectorization', 1, None, '___sec101'),
              (u'Vectorizing the midpoint rule', 3, None, '___sec102'),
              (u'Vectorizing the trapezoidal rule', 3, None, '___sec103'),
              (u'Measuring computational speed', 1, None, '___sec104'),
              (u'Double and triple integrals',
               1,
               u'sec:int:double',
               u'sec:int:double'),
              (u'The midpoint rule for a double integral',
               2,
               u'sec:int:double:midpoint',
               u'sec:int:double:midpoint'),
              (u'Derivation via one-dimensional integrals',
               3,
               None,
               '___sec107'),
              (u'Direct derivation', 3, None, '___sec108'),
              (u'Programming a double sum', 3, None, '___sec109'),
              (u'Reusing code for one-dimensional integrals',
               3,
               None,
               '___sec110'),
              (u'Verification via test functions', 3, None, '___sec111'),
              (u'The midpoint rule for a triple integral',
               2,
               None,
               '___sec112'),
              (u'Theory', 3, None, '___sec113'),
              (u'Implementation', 3, None, '___sec114'),
              (u'Monte Carlo integration for complex-shaped domains',
               2,
               u'sec:int:complex:domain',
               u'sec:int:complex:domain'),
              (u'The Monte Carlo integration algorithm',
               3,
               None,
               '___sec116'),
              (u'Implementation', 3, None, '___sec117'),
              (u'Verification', 3, None, '___sec118'),
              (u'Test function for function with random numbers',
               3,
               None,
               '___sec119'),
              (u'Integral over a circle', 3, None, '___sec120'),
              (u'Exercises', 1, None, '___sec121'),
              (u'Exercise 30: Hand calculations for the trapezoidal method',
               2,
               u'sec:exer:trap:hand',
               u'sec:exer:trap:hand'),
              (u'Exercise 31: Hand calculations for the midpoint method',
               2,
               u'sec:exer:midpt:hand',
               u'sec:exer:midpt:hand'),
              (u'Exercise 32: Compute a simple integral',
               2,
               u'sec:exer:trap:mid:parabola',
               u'sec:exer:trap:mid:parabola'),
              (u'Exercise 33: Hand-calculations with sine integrals',
               2,
               u'sec:exer:hand:sine',
               u'sec:exer:hand:sine'),
              (u'Exercise 34: Make test functions for the midpoint method',
               2,
               u'sec:exer:test:midpoint',
               u'sec:exer:test:midpoint'),
              (u'Exercise 35: Explore rounding errors with large numbers',
               2,
               u'sec:exer:test:roundoff',
               u'sec:exer:test:roundoff'),
              (u'Exercise 36: Write test functions for $\\int_0^4\\sqrt{x}dx$',
               2,
               u'sec:exer:test:convrates:sqrt',
               u'sec:exer:test:convrates:sqrt'),
              (u'Remarks', 3, None, '___sec129'),
              (u'Exercise 37: Rectangle methods',
               2,
               u'sec:exer:rectangleMethod',
               u'sec:exer:rectangleMethod'),
              (u'Exercise 38: Adaptive integration',
               2,
               u'sec:exer:adaptive:int',
               u'sec:exer:adaptive:int'),
              (u'Remarks', 3, None, '___sec132'),
              (u'Exercise 39: Integrating x raised to x',
               2,
               u'sec:exer:integrate:x2x',
               u'sec:exer:integrate:x2x'),
              (u'Exercise 40: Integrate products of sine functions',
               2,
               u'sec:exer:sine:products',
               u'sec:exer:sine:products'),
              (u'Exercise 41: Revisit fit of sines to a function',
               2,
               u'sec:exer:revisitFitSines',
               u'sec:exer:revisitFitSines'),
              (u'Exercise 42: Derive the trapezoidal rule for a double integral',
               2,
               u'sec:exer:trapezoidal:2D',
               u'sec:exer:trapezoidal:2D'),
              (u'Exercise 43: Compute the area of a triangle by Monte Carlo integration',
               2,
               u'sec:exer:MC:ellipse',
               u'sec:exer:MC:ellipse'),
              (u'Solving ordinary differential equations',
               0,
               u'5th:SolvODEs',
               u'5th:SolvODEs'),
              (u'Population growth', 1, u'sec:de:pg', u'sec:de:pg'),
              (u'Derivation of the model',
               2,
               u'sec:de:pg:model',
               u'sec:de:pg:model'),
              (u'Numerical solution',
               2,
               u'sec:de:pg:numerics',
               u'sec:de:pg:numerics'),
              (u'Programming the Forward Euler scheme; the special case',
               2,
               u'sec:de:pg:prog1',
               u'sec:de:pg:prog1'),
              (u'Understanding the Forward Euler method',
               2,
               u'sec:de:pg:geom',
               u'sec:de:pg:geom'),
              (u'Programming the Forward Euler scheme; the general case',
               2,
               u'sec:de:FE:gen',
               u'sec:de:FE:gen'),
              (u'Making the population growth model more realistic',
               2,
               None,
               '___sec145'),
              (u'Verification: exact linear solution of the discrete equations',
               2,
               u'sec:de:growth:test:linear',
               u'sec:de:growth:test:linear'),
              (u'Spreading of diseases', 1, None, '___sec147'),
              (u'Spreading of a flu', 2, u'sec:de:flu', u'sec:de:flu'),
              (u'A Forward Euler method for the differential equation system',
               2,
               u'sec:de:flu:FE',
               u'sec:de:flu:FE'),
              (u'Programming the numerical method; the special case',
               2,
               u'sec:de:flu:prog:spec',
               u'sec:de:flu:prog:spec'),
              (u'Outbreak or not', 2, None, '___sec151'),
              (u'Abstract problem and notation',
               2,
               u'sec:de:flu:generic',
               u'sec:de:flu:generic'),
              (u'Programming the numerical method; the general case',
               2,
               u'sec:de:flu:prog:generic',
               u'sec:de:flu:prog:generic'),
              (u'Time-restricted immunity', 2, None, '___sec154'),
              (u'Incorporating vaccination',
               2,
               u'sec:de:flu:vaccine',
               u'sec:de:flu:vaccine'),
              (u'Discontinuous coefficients: a vaccination campaign',
               2,
               u'sec:de:flu:vaccine:discont',
               u'sec:de:flu:vaccine:discont'),
              (u'Oscillating one-dimensional systems',
               1,
               u'sec:de:vib',
               u'sec:de:vib'),
              (u'Derivation of a simple model', 2, None, '___sec158'),
              (u'Numerical solution', 2, None, '___sec159'),
              (u'Programming the numerical method; the special case',
               2,
               u'sec:de:vib:special',
               u'sec:de:vib:special'),
              (u'A magic fix of the numerical method', 2, None, '___sec161'),
              (u"The 2nd-order Runge-Kutta method (or Heun's method)",
               2,
               u'sec:de:osc:Heun',
               u'sec:de:osc:Heun'),
              (u'Software for solving ODEs',
               2,
               u'sec:de:osc:odespy',
               u'sec:de:osc:odespy'),
              (u'The 4th-order Runge-Kutta method', 2, None, '___sec164'),
              (u'The algorithm', 3, None, '___sec165'),
              (u'Application', 3, None, '___sec166'),
              (u'Implementation', 3, None, '___sec167'),
              (u'Derivation', 3, None, '___sec168'),
              (u'More effects: damping, nonlinearity, and external forces',
               2,
               None,
               '___sec169'),
              (u'The Euler-Cromer scheme', 3, None, '___sec170'),
              (u'The 4-th order Runge-Kutta method', 3, None, '___sec171'),
              (u'Illustration of linear damping', 2, None, '___sec172'),
              (u'Illustration of linear damping with sinusoidal excitation',
               2,
               None,
               '___sec173'),
              (u'Spring-mass system with sliding friction',
               2,
               u'sec:de:vib:ode2:sliding:friction',
               u'sec:de:vib:ode2:sliding:friction'),
              (u'A finite difference method; undamped, linear case',
               2,
               u'sec:de:vib:2nd',
               u'sec:de:vib:2nd'),
              (u'A finite difference method; linear damping',
               2,
               u'sec:de:vib:2nd:damped1',
               u'sec:de:vib:2nd:damped1'),
              (u'Exercises', 1, None, '___sec177'),
              (u'Exercise 44: Geometric construction of the Forward Euler method',
               2,
               u'sec:de:exer:geom',
               u'sec:de:exer:geom'),
              (u'Exercise 45: Make test functions for the Forward Euler method',
               2,
               u'sec:de:exer:FE:test1',
               u'sec:de:exer:FE:test1'),
              (u"Exercise 46: Implement and evaluate Heun's method",
               2,
               u'sec:de:exer:Heun:pg',
               u'sec:de:exer:Heun:pg'),
              (u'Exercise 47: Find an appropriate time step; logistic model',
               2,
               u'sec:de:exer:logistic:dtopt',
               u'sec:de:exer:logistic:dtopt'),
              (u'Exercise 48: Find an appropriate time step; SIR model',
               2,
               u'sec:de:exer:SIR:dtopt',
               u'sec:de:exer:SIR:dtopt'),
              (u'Exercise 49: Model an adaptive vaccination campaign',
               2,
               u'sec:de:exer:SIRV:padapt',
               u'sec:de:exer:SIRV:padapt'),
              (u'Exercise 50: Make a SIRV model with time-limited effect of vaccination',
               2,
               u'sec:de:exer:SIRV:padapt_time_limited',
               u'sec:de:exer:SIRV:padapt_time_limited'),
              (u'Exercise 51: Refactor a flat program',
               2,
               u'sec:de:exer:vib:FE:func',
               u'sec:de:exer:vib:FE:func'),
              (u'Exercise 52: Simulate oscillations by a general ODE solver',
               2,
               u'sec:de:exer:vib:ode_FE',
               u'sec:de:exer:vib:ode_FE'),
              (u'Exercise 53: Compute the energy in oscillations',
               2,
               u'sec:de:exer:vib:energy',
               u'sec:de:exer:vib:energy'),
              (u'Exercise 54: Use a Backward Euler scheme for population growth',
               2,
               u'sec:de:exer:pg:BE',
               u'sec:de:exer:pg:BE'),
              (u'Exercise 55: Use a Crank-Nicolson scheme for population growth',
               2,
               u'sec:de:exer:pg:CN',
               u'sec:de:exer:pg:CN'),
              (u'Exercise 56: Understand finite differences via Taylor series',
               2,
               u'sec:de:exer:fd:Taylor',
               u'sec:de:exer:fd:Taylor'),
              (u'Exercise 57: Use a Backward Euler scheme for oscillations',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u'Remarks', 3, None, '___sec192'),
              (u"Exercise 58: Use Heun's method for the SIR model",
               2,
               u'sec:de:exer:SIR:Heun',
               u'sec:de:exer:SIR:Heun'),
              (u'Exercise 59: Use Odespy to solve a simple ODE',
               2,
               u'sec:de:exer:odespy:decay',
               u'sec:de:exer:odespy:decay'),
              (u'Exercise 60: Set up a Backward Euler scheme for oscillations',
               2,
               u'sec:de:exer:osc:BE',
               u'sec:de:exer:osc:BE'),
              (u'Exercise 61: Set up a Forward Euler scheme for nonlinear and damped oscillations',
               2,
               u'sec:de:exer:osc:FE:general',
               u'sec:de:exer:osc:FE:general'),
              (u'Exercise 62: Discretize an initial condition',
               2,
               u'sec:de:exer:osc:2nd:V0ic',
               u'sec:de:exer:osc:2nd:V0ic'),
              (u'Solving partial differential equations',
               0,
               u'6th:SolvPDEs',
               u'6th:SolvPDEs'),
              (u'Finite difference methods',
               1,
               u'6th:SolvPDEs:MOLandFE',
               u'6th:SolvPDEs:MOLandFE'),
              (u'Reduction of a PDE to a system of ODEs',
               2,
               u'sec:pde:diff1D:reduce',
               u'sec:pde:diff1D:reduce'),
              (u'Construction of a test problem with known discrete solution',
               2,
               u'sec:pde:diff1D:testproblem',
               u'sec:pde:diff1D:testproblem'),
              (u'Implementation: Forward Euler method', 2, None, '___sec202'),
              (u'Application: heat conduction in a rod',
               2,
               u'sec:pde:diff1D:rod',
               u'sec:pde:diff1D:rod'),
              (u'Vectorization', 2, None, '___sec204'),
              (u'Using Odespy to solve the system of ODEs',
               2,
               None,
               '___sec205'),
              (u'Implicit methods', 2, None, '___sec206'),
              (u'Exercises', 1, None, '___sec207'),
              (u'Exercise 63: Simulate a diffusion equation by hand',
               2,
               u'sec:pde:diff1D:exer:handFE',
               u'sec:pde:diff1D:exer:handFE'),
              (u'Exercise 64: Compute temperature variations in the ground',
               2,
               u'sec:pde:diff1D:exer:groundtemp',
               u'sec:pde:diff1D:exer:groundtemp'),
              (u'Exercise 65: Compare implicit methods',
               2,
               u'sec:pde:diff1D:exer:compare:implicit',
               u'sec:pde:diff1D:exer:compare:implicit'),
              (u'Exercise 66: Explore adaptive and implicit methods',
               2,
               u'sec:pde:diff1D:exer:groundtemp:adapt',
               u'sec:pde:diff1D:exer:groundtemp:adapt'),
              (u'Exercise 67: Investigate the $\\theta$ rule',
               2,
               u'sec:pde:diff1D:exer:CN',
               u'sec:pde:diff1D:exer:CN'),
              (u'Remarks', 3, None, '___sec213'),
              (u'Exercise 68: Compute the diffusion of a Gaussian peak',
               2,
               u'sec:pde:diff1D:exer:Gaussian',
               u'sec:pde:diff1D:exer:Gaussian'),
              (u'Remarks', 3, None, '___sec215'),
              (u'Exercise 69: Vectorize a function for computing the area of a polygon',
               2,
               u'2nd:exer:area:polygon2',
               u'2nd:exer:area:polygon2'),
              (u'Exercise 70: Explore symmetry',
               2,
               u'sec:pde:diff1D:exer:Gaussian:symm',
               u'sec:pde:diff1D:exer:Gaussian:symm'),
              (u'Remarks', 3, None, '___sec218'),
              (u'Exercise 71: Compute solutions as $t\\rightarrow\\infty$',
               2,
               u'sec:pde:diff1D:exer:stationary',
               u'sec:pde:diff1D:exer:stationary'),
              (u'Remarks', 3, None, '___sec220'),
              (u'Exercise 72: Solve a two-point boundary value problem',
               2,
               u'sec:pde:diff1D:exer:stationary2',
               u'sec:pde:diff1D:exer:stationary2'),
              (u'Solving nonlinear algebraic equations',
               0,
               u'4th:NonlinAlgEq',
               u'4th:NonlinAlgEq'),
              (u'Brute force methods',
               1,
               u'4th:bruteforce',
               u'4th:bruteforce'),
              (u'Brute force root finding', 2, None, '___sec224'),
              (u'Numerical algorithm', 3, None, '___sec225'),
              (u'Implementation', 3, None, '___sec226'),
              (u'Brute force optimization', 2, None, '___sec227'),
              (u'Numerical algorithm', 3, None, '___sec228'),
              (u'Implementation', 3, None, '___sec229'),
              (u'Model problem for algebraic equations',
               2,
               None,
               '___sec230'),
              (u"Newton's method",
               1,
               u'4th:NonlinAlgEq:Newt',
               u'4th:NonlinAlgEq:Newt'),
              (u"Deriving and implementing Newton's method",
               2,
               None,
               '___sec232'),
              (u'Making a more efficient and robust implementation',
               2,
               u'4th:Newton:robust',
               u'4th:Newton:robust'),
              (u'The secant method',
               1,
               u'4th:NonlinAlgEq:Secant',
               u'4th:NonlinAlgEq:Secant'),
              (u'The bisection method',
               1,
               u'4th:NonlinAlgEq:Bisect',
               u'4th:NonlinAlgEq:Bisect'),
              (u'Rate of convergence',
               1,
               u'4th:NonlinAlgEq:RateConv',
               u'4th:NonlinAlgEq:RateConv'),
              (u'Solving multiple nonlinear algebraic equations',
               1,
               u'nonlin:Newton:systems',
               u'nonlin:Newton:systems'),
              (u'Abstract notation',
               2,
               u'nonlin:Newton:systems:notation',
               u'nonlin:Newton:systems:notation'),
              (u'Taylor expansions for multi-variable functions',
               2,
               None,
               '___sec239'),
              (u"Newton's method", 2, None, '___sec240'),
              (u'Implementation', 2, None, '___sec241'),
              (u'Exercises', 1, None, '___sec242'),
              (u"Exercise 73: Understand why Newton's method can fail",
               2,
               u'4th:exer:Newton:failure',
               u'4th:exer:Newton:failure'),
              (u'Exercise 74: See if the secant method fails',
               2,
               u'4th:exer:Secant:failure',
               u'4th:exer:Secant:failure'),
              (u'Exercise 75: Understand why the bisection method cannot fail',
               2,
               u'4th:exer:Bisection:failure',
               u'4th:exer:Bisection:failure'),
              (u"Exercise 76: Combine the bisection method with Newton's method",
               2,
               u'4th:exer:Bisection:Newton',
               u'4th:exer:Bisection:Newton'),
              (u"Exercise 77: Write a test function for Newton's method",
               2,
               u'4th:exer:NewtonHand',
               u'4th:exer:NewtonHand'),
              (u'Exercise 78: Solve nonlinear equation for a vibrating beam',
               2,
               u'4th:exer:beam:vib',
               u'4th:exer:beam:vib'),
              (u'Appendix: Getting access to Python',
               0,
               u'app:accesspy',
               u'app:accesspy'),
              (u'Required software',
               1,
               u'sec:accesspy:softwarelist',
               u'sec:accesspy:softwarelist'),
              (u'Anaconda and Spyder',
               1,
               u'sec:accesspy:anaconda',
               u'sec:accesspy:anaconda'),
              (u'Spyder on Mac', 2, None, '___sec252'),
              (u'Installation of additional packages', 2, None, '___sec253'),
              (u'How to write and run a Python program',
               1,
               u'sec:accesspy:writerun',
               u'sec:accesspy:writerun'),
              (u'The need for a text editor', 2, None, '___sec255'),
              (u'Text editors', 2, None, '___sec256'),
              (u'Terminal windows', 2, None, '___sec257'),
              (u'Using a plain text editor and a terminal window',
               2,
               None,
               '___sec258'),
              (u'Spyder', 2, None, '___sec259'),
              (u'The SageMathCloud and Wakari web services',
               1,
               u'sec:accesspy:sagemath:wakari',
               u'sec:accesspy:sagemath:wakari'),
              (u'Basic intro to SageMathCloud', 2, None, '___sec261'),
              (u'Basic intro to Wakari', 2, None, '___sec262'),
              (u'Installing your own Python packages', 2, None, '___sec263'),
              (u'Writing IPython notebooks',
               1,
               u'sec:accesspy:ipynb',
               u'sec:accesspy:ipynb'),
              (u'A simple program in the notebook', 2, None, '___sec265'),
              (u'Mixing text, mathematics, code, and graphics',
               2,
               None,
               '___sec266'),
              (u'References', 0, None, '___sec267')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\J}{\boldsymbol{J}}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\c}{\boldsymbol{c}}
$$




    
<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="p4c-bootstrap-Python.html">Programming for Computations - A Gentle Introduction to Numerical Simulations with Python</a>
  </div>

  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#___sec0" style="font-size: 80%;"><b>Preface</b></a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#___sec1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Why learn programming?</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#___sec2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Target audience and background knowledge</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#___sec3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical methods</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#___sec4" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The computer language: Python</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#___sec5" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How this book is different</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#___sec6" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Supplementary materials</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python001.html#___sec7" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Acknowledgments</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python003.html#1st:TheFirstFewSteps" style="font-size: 80%;"><b>The first few steps</b></a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python003.html#___sec9" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;What is a program? And what is programming?</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python004.html#1st:ex1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A Python program with variables</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python004.html#___sec11" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The program</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python004.html#___sec12" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dissection of the program</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python004.html#___sec13" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Why not just use a pocket calculator?</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python004.html#___sec14" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Why you must use a text editor to write programs</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python004.html#___sec15" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation of Python</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python004.html#___sec16" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Write and run your first program</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python005.html#1st:ex2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A Python program with a library function</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python006.html#1st:ex3" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;A Python program with vectorization and plotting</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec19" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;More basic concepts</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec20" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using Python interactively</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arithmetics, parentheses and rounding errors</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec22" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Variables and objects</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec23" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integer division</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec24" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Formatting text and numbers</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec25" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrays</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec26" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plotting</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec27" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Error messages and warnings</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec28" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Input data</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec29" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symbolic computations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python007.html#___sec30" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Concluding remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#___sec31" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:ErrorMessages" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 1: Error messages</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:cubeVolume" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 2: Volume of a cube</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:areaCircle" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 3: Area and circumference of a circle</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:volumes3cubes" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 4: Volumes of three cubes</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:averageOf5Integers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 5: Average of integers</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:cubeVolInteractively" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 6: Interactive computing of volume and area</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:intDivInteractively" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 7: Peculiar results from division</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:updateVarInteractively" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 8: Update variable at command prompt</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:printfScreen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 9: Formatted print to screen</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python008.html#1st:exer:PythonDocRandom" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 10: Python documentation and random numbers</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python009.html#2nd:BasicConstructins" style="font-size: 80%;"><b>Basic constructions</b></a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python009.html#___sec43" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;If tests, colon and indentation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python010.html#sec:functions" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Functions</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python011.html#sec:for:loops" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;For loops</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python012.html#sec:while:loops" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;While loops</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python013.html#sec:lists" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Lists and tuples - alternatives to arrays</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python013.html#sec:file:reading:writing" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Reading from and writing to files</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#___sec49" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:ErrorsColonIndent" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 11: Errors with colon, indent, etc.</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:compInt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 12: Compare integers a and b</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:funcCircArea" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 13: Functions for circumference and area of a circle</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:funcAreaRectangle" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 14: Function for area of a rectangle</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:area:polygon" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 15: Area of a polygon</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:avNInt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 16: Average of integers</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:whileLoopErrors" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 17: While loop with errors</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:areaRectCircle" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 18: Area of rectangle versus circle</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:Cross2Graphs" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 19: Find crossing points of two graphs</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:sortNumbers" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 20: Sort array with numbers</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:computingPi" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 21: Compute \( \pi \)</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:combinatorics1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 22: Compute combinations of sets</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:numberOccurrence" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 23: Frequency of random numbers</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#___sec63" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:Game21" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 24: Game 21</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:linearInterpol" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 25: Linear interpolation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:testStraightLine" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 26: Test straight line requirement</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:fitLine" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 27: Fit straight line to data</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#___sec68" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:fitSines" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 28: Fit sines to straight line</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#___sec70" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#2nd:exer:countTextString" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 29: Count occurrences of a string in a string</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python014.html#___sec72" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python015.html#sec:integrals" style="font-size: 80%;"><b>Computing integrals</b></a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python015.html#sec:integrals:basic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Basic ideas of numerical integration</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python015.html#___sec75" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computational example</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#sec:integrals:trap" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The composite trapezoidal rule</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#sec:integrals:formula" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The general formula</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#sec:integrals:trap:impl" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#___sec79" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specific or general implementation?</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#___sec80" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation with functions</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#___sec81" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving our specific problem in a session</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#___sec82" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving our specific problem in a program</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#___sec83" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making a module</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python016.html#___sec84" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Alternative flat special-purpose implementation</a></li>
     <!-- navigation toc: --> <li><a href="#sec:integrals:Midpoint" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The composite midpoint method</a></li>
     <!-- navigation toc: --> <li><a href="#___sec86" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The idea</a></li>
     <!-- navigation toc: --> <li><a href="#___sec87" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The general formula</a></li>
     <!-- navigation toc: --> <li><a href="#sec:midpoint:code" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec89" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparing the trapezoidal and the midpoint methods</a></li>
     <!-- navigation toc: --> <li><a href="#___sec90" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Testing</a></li>
     <!-- navigation toc: --> <li><a href="#___sec91" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Problems with brief testing procedures</a></li>
     <!-- navigation toc: --> <li><a href="#sec:integrals:testprocs" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Proper test procedures</a></li>
     <!-- navigation toc: --> <li><a href="#___sec93" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hand-computed results</a></li>
     <!-- navigation toc: --> <li><a href="#___sec94" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving a problem without numerical errors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec95" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Demonstrating correct convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="#sec:integrals:finite_prec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finite precision of floating-point numbers</a></li>
     <!-- navigation toc: --> <li><a href="#sec:integrals:test:functions" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructing unit tests and writing test functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec98" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hand-computed numerical results</a></li>
     <!-- navigation toc: --> <li><a href="#___sec99" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Solving a problem without numerical errors</a></li>
     <!-- navigation toc: --> <li><a href="#___sec100" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Demonstrating correct convergence rates</a></li>
     <!-- navigation toc: --> <li><a href="#___sec101" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Vectorization</a></li>
     <!-- navigation toc: --> <li><a href="#___sec102" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorizing the midpoint rule</a></li>
     <!-- navigation toc: --> <li><a href="#___sec103" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorizing the trapezoidal rule</a></li>
     <!-- navigation toc: --> <li><a href="#___sec104" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Measuring computational speed</a></li>
     <!-- navigation toc: --> <li><a href="#sec:int:double" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Double and triple integrals</a></li>
     <!-- navigation toc: --> <li><a href="#sec:int:double:midpoint" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The midpoint rule for a double integral</a></li>
     <!-- navigation toc: --> <li><a href="#___sec107" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation via one-dimensional integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec108" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Direct derivation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec109" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming a double sum</a></li>
     <!-- navigation toc: --> <li><a href="#___sec110" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reusing code for one-dimensional integrals</a></li>
     <!-- navigation toc: --> <li><a href="#___sec111" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification via test functions</a></li>
     <!-- navigation toc: --> <li><a href="#___sec112" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The midpoint rule for a triple integral</a></li>
     <!-- navigation toc: --> <li><a href="#___sec113" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Theory</a></li>
     <!-- navigation toc: --> <li><a href="#___sec114" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#sec:int:complex:domain" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Monte Carlo integration for complex-shaped domains</a></li>
     <!-- navigation toc: --> <li><a href="#___sec116" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Monte Carlo integration algorithm</a></li>
     <!-- navigation toc: --> <li><a href="#___sec117" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="#___sec118" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification</a></li>
     <!-- navigation toc: --> <li><a href="#___sec119" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Test function for function with random numbers</a></li>
     <!-- navigation toc: --> <li><a href="#___sec120" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Integral over a circle</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#___sec121" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:trap:hand" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 30: Hand calculations for the trapezoidal method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:midpt:hand" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 31: Hand calculations for the midpoint method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:trap:mid:parabola" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 32: Compute a simple integral</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:hand:sine" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 33: Hand-calculations with sine integrals</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:test:midpoint" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 34: Make test functions for the midpoint method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:test:roundoff" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 35: Explore rounding errors with large numbers</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:test:convrates:sqrt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 36: Write test functions for \( \int_0^4\sqrt{x}dx \)</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#___sec129" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:rectangleMethod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 37: Rectangle methods</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:adaptive:int" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 38: Adaptive integration</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#___sec132" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:integrate:x2x" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 39: Integrating x raised to x</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:sine:products" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 40: Integrate products of sine functions</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:revisitFitSines" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 41: Revisit fit of sines to a function</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:trapezoidal:2D" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 42: Derive the trapezoidal rule for a double integral</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python018.html#sec:exer:MC:ellipse" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 43: Compute the area of a triangle by Monte Carlo integration</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python019.html#5th:SolvODEs" style="font-size: 80%;"><b>Solving ordinary differential equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python020.html#sec:de:pg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Population growth</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python020.html#sec:de:pg:model" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation of the model</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python020.html#sec:de:pg:numerics" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical solution</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python020.html#sec:de:pg:prog1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming the Forward Euler scheme; the special case</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python020.html#sec:de:pg:geom" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Understanding the Forward Euler method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python020.html#sec:de:FE:gen" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming the Forward Euler scheme; the general case</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python020.html#___sec145" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making the population growth model more realistic</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python020.html#sec:de:growth:test:linear" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification: exact linear solution of the discrete equations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#___sec147" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Spreading of diseases</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#sec:de:flu" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spreading of a flu</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#sec:de:flu:FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A Forward Euler method for the differential equation system</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#sec:de:flu:prog:spec" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming the numerical method; the special case</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#___sec151" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Outbreak or not</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#sec:de:flu:generic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract problem and notation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#sec:de:flu:prog:generic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming the numerical method; the general case</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#___sec154" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time-restricted immunity</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#sec:de:flu:vaccine" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Incorporating vaccination</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python021.html#sec:de:flu:vaccine:discont" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Discontinuous coefficients: a vaccination campaign</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#sec:de:vib" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Oscillating one-dimensional systems</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec158" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation of a simple model</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec159" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical solution</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#sec:de:vib:special" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Programming the numerical method; the special case</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec161" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A magic fix of the numerical method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#sec:de:osc:Heun" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 2nd-order Runge-Kutta method (or Heun's method)</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#sec:de:osc:odespy" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Software for solving ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec164" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 4th-order Runge-Kutta method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec165" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec166" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec167" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec168" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Derivation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec169" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;More effects: damping, nonlinearity, and external forces</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec170" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The Euler-Cromer scheme</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec171" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The 4-th order Runge-Kutta method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec172" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Illustration of linear damping</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#___sec173" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Illustration of linear damping with sinusoidal excitation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#sec:de:vib:ode2:sliding:friction" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spring-mass system with sliding friction</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#sec:de:vib:2nd" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A finite difference method; undamped, linear case</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python022.html#sec:de:vib:2nd:damped1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A finite difference method; linear damping</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#___sec177" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:geom" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 44: Geometric construction of the Forward Euler method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:FE:test1" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 45: Make test functions for the Forward Euler method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:Heun:pg" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 46: Implement and evaluate Heun's method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:logistic:dtopt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 47: Find an appropriate time step; logistic model</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:SIR:dtopt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 48: Find an appropriate time step; SIR model</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:SIRV:padapt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 49: Model an adaptive vaccination campaign</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:SIRV:padapt_time_limited" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 50: Make a SIRV model with time-limited effect of vaccination</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:vib:FE:func" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 51: Refactor a flat program</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:vib:ode_FE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 52: Simulate oscillations by a general ODE solver</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:vib:energy" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 53: Compute the energy in oscillations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:pg:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 54: Use a Backward Euler scheme for population growth</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:pg:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 55: Use a Crank-Nicolson scheme for population growth</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:fd:Taylor" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 56: Understand finite differences via Taylor series</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:vib:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 57: Use a Backward Euler scheme for oscillations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#___sec192" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:SIR:Heun" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 58: Use Heun's method for the SIR model</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:odespy:decay" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 59: Use Odespy to solve a simple ODE</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:osc:BE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 60: Set up a Backward Euler scheme for oscillations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:osc:FE:general" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 61: Set up a Forward Euler scheme for nonlinear and damped oscillations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python023.html#sec:de:exer:osc:2nd:V0ic" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 62: Discretize an initial condition</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python024.html#6th:SolvPDEs" style="font-size: 80%;"><b>Solving partial differential equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#6th:SolvPDEs:MOLandFE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Finite difference methods</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:reduce" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reduction of a PDE to a system of ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:testproblem" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construction of a test problem with known discrete solution</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec202" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation: Forward Euler method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:rod" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Application: heat conduction in a rod</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec204" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Vectorization</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec205" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using Odespy to solve the system of ODEs</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec206" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implicit methods</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec207" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:handFE" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 63: Simulate a diffusion equation by hand</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:groundtemp" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 64: Compute temperature variations in the ground</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:compare:implicit" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 65: Compare implicit methods</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:groundtemp:adapt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 66: Explore adaptive and implicit methods</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:CN" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 67: Investigate the \( \theta \) rule</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec213" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:Gaussian" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 68: Compute the diffusion of a Gaussian peak</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec215" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#2nd:exer:area:polygon2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 69: Vectorize a function for computing the area of a polygon</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:Gaussian:symm" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 70: Explore symmetry</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec218" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:stationary" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 71: Compute solutions as \( t\rightarrow\infty \)</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#___sec220" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remarks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python025.html#sec:pde:diff1D:exer:stationary2" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 72: Solve a two-point boundary value problem</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#4th:NonlinAlgEq" style="font-size: 80%;"><b>Solving nonlinear algebraic equations</b></a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#4th:bruteforce" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Brute force methods</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#___sec224" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Brute force root finding</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#___sec225" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#___sec226" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#___sec227" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Brute force optimization</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#___sec228" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Numerical algorithm</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#___sec229" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python026.html#___sec230" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Model problem for algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python027.html#4th:NonlinAlgEq:Newt" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python027.html#___sec232" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deriving and implementing Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python027.html#4th:Newton:robust" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Making a more efficient and robust implementation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python028.html#4th:NonlinAlgEq:Secant" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The secant method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python029.html#4th:NonlinAlgEq:Bisect" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The bisection method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python030.html#4th:NonlinAlgEq:RateConv" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Rate of convergence</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python031.html#nonlin:Newton:systems" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Solving multiple nonlinear algebraic equations</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python031.html#nonlin:Newton:systems:notation" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract notation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python031.html#___sec239" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Taylor expansions for multi-variable functions</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python031.html#___sec240" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python031.html#___sec241" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Implementation</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python032.html#___sec242" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Exercises</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python032.html#4th:exer:Newton:failure" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 73: Understand why Newton's method can fail</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python032.html#4th:exer:Secant:failure" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 74: See if the secant method fails</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python032.html#4th:exer:Bisection:failure" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 75: Understand why the bisection method cannot fail</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python032.html#4th:exer:Bisection:Newton" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 76: Combine the bisection method with Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python032.html#4th:exer:NewtonHand" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 77: Write a test function for Newton's method</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python032.html#4th:exer:beam:vib" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exercise 78: Solve nonlinear equation for a vibrating beam</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python033.html#app:accesspy" style="font-size: 80%;"><b>Appendix: Getting access to Python</b></a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python034.html#sec:accesspy:softwarelist" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Required software</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python035.html#sec:accesspy:anaconda" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Anaconda and Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python035.html#___sec252" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder on Mac</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python035.html#___sec253" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installation of additional packages</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python036.html#sec:accesspy:writerun" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;How to write and run a Python program</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python036.html#___sec255" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The need for a text editor</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python036.html#___sec256" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Text editors</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python036.html#___sec257" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Terminal windows</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python036.html#___sec258" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Using a plain text editor and a terminal window</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python036.html#___sec259" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Spyder</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python037.html#sec:accesspy:sagemath:wakari" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;The SageMathCloud and Wakari web services</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python037.html#___sec261" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic intro to SageMathCloud</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python037.html#___sec262" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Basic intro to Wakari</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python037.html#___sec263" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Installing your own Python packages</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python038.html#sec:accesspy:ipynb" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;Writing IPython notebooks</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python038.html#___sec265" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A simple program in the notebook</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python038.html#___sec266" style="font-size: 80%;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mixing text, mathematics, code, and graphics</a></li>
     <!-- navigation toc: --> <li><a href="._p4c-bootstrap-Python039.html#___sec267" style="font-size: 80%;"><b>References</b></a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->

<div class="container">

<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->

<a name="part0017"></a>
<!-- !split -->

<h1 id="sec:integrals:Midpoint">The composite midpoint method</h1>

<h3 id="___sec86">The idea </h3>

<p>
Rather than approximating the area under a curve by trapezoids, we can
use plain rectangles. It may sound less accurate to use horizontal lines
and not skew lines following the function to be integrated, but
an integration method based on rectangles (the <em>midpoint method</em>) is in fact slightly more
accurate than the one based on trapezoids!

<p>
In the midpoint method, we construct a rectangle for every sub-interval
where the height equals \( f \) at the midpoint of the sub-interval.
Let us do this for four rectangles, using the same sub-intervals as we
had for hand calculations with the trapezoidal method:
\( [0,0.2) \), \( [0.2,0.6) \), \( [0.6,0.8) \), and \( [0.8,1.0] \). We get

$$
\begin{align}
\int_0^1 f(t)dt &\approx
   h_1 f\left(\frac{0 + 0.2}{2}\right) +
   h_2 f\left(\frac{0.2 + 0.6}{2}\right) \nonumber  \\ 
&+ h_3 f\left(\frac{0.6 + 0.8}{2}\right) +
   h_4 f\left(\frac{0.8 + 1.0}{2}\right),
\tag{3.18}
\end{align}
$$

where \( h_1 \), \( h_2 \), \( h_3 \), and \( h_4 \) are the widths of the sub-intervals,
used previously with the trapezoidal method and defined in
<a href="._p4c-bootstrap-Python016.html#mjx-eqn-3.10">(3.10)</a>-<a href="._p4c-bootstrap-Python016.html#mjx-eqn-3.13">(3.13)</a>.

<p>
<center> <!-- figure label: --> <div id="fig:vCarMidpoint"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 9:  Computing approximately the integral of a function as the sum of the areas of the rectangles.  <!-- caption label: fig:vCarMidpoint --> </p></center>
<p><img src="figs/viz_midpoint.png" align="bottom" width=400></p>
</center>

<p>
With \( f(t) = 3t^{2}e^{t^3} \), the approximation becomes \( 1.632 \).
Compared with the true answer (\( 1.718 \)), this is about \( 5\% \) too
small, but it is better than what we got with the trapezoidal method
(\( 10\% \)) with the same sub-intervals. More rectangles give a
better approximation.

<h2 id="___sec87">The general formula </h2>

<p>
Let us derive a formula for the midpoint method based on \( n \) rectangles of equal width:

$$
\begin{align}
\int_a^b f(x)\,dx &= \int_{x_0}^{x_1} f(x)dx + \int_{x_1}^{x_2} f(x)dx +
                     \ldots + \int_{x_{n-1}}^{x_n} f(x)dx,     \nonumber \\ 
                  &\approx h f\left(\frac{x_0 + x_1}{2}\right) +
                   h f\left(\frac{x_1 + x_2}{2}\right) + \ldots +
                   h f\left(\frac{x_{n-1} + x_n}{2}\right) ,
\tag{3.19}  \\ 
                  &\approx h \left(f\left(\frac{x_0 + x_1}{2}\right) +
                  f\left(\frac{x_1 + x_2}{2}\right) + \ldots +
                  f\left(\frac{x_{n-1} + x_n}{2}\right)\right)\thinspace .
\tag{3.20}
\end{align}
$$

This sum may be written more compactly as
$$
\begin{equation}
\int_a^b f(x) dx \approx h \sum_{i=0}^{n-1}f(x_i) ,
\tag{3.21}
\end{equation}
$$

where \( x_i = \left(a + \frac{h}{2}\right) + ih \).

<h2 id="sec:midpoint:code">Implementation</h2>

<p>
We follow the advice and lessons learned from the implementation of
the trapezoidal method and make a function <code>midpoint(f, a, b, n)</code>
(in a file <a href="https://github.com/hplgit/prog4comp/tree/master/src/py/midpoint.py" target="_self"><tt>midpoint.py</tt></a>)
for implementing the general formula <a href="#mjx-eqn-3.21">(3.21)</a>:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint</span>(f, a, b, n):
    h <span style="color: #666666">=</span> <span style="color: #008000">float</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n
    result <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        result <span style="color: #666666">+=</span> f((a <span style="color: #666666">+</span> h<span style="color: #666666">/2.0</span>) <span style="color: #666666">+</span> i<span style="color: #666666">*</span>h)
    result <span style="color: #666666">*=</span> h
    <span style="color: #008000; font-weight: bold">return</span> result
</pre></div>
<p>
We can test the function as we explained for the similar <code>trapezoidal</code>
method. The error in our particular problem \( \int_0^1 3t^2e^{t^3}dt \)
with four intervals is now about 0.1 in contrast to 0.2 for the
trapezoidal rule.  This is in fact not accidental: one can show
mathematically that the error of the midpoint method is a bit smaller
than for the trapezoidal method. The differences are seldom of any
practical importance, and on a laptop we can easily use \( n=10^6 \) and
get the answer with an error about \( 10^{-12} \) in a couple of seconds.

<h2 id="___sec89">Comparing the trapezoidal and the midpoint methods </h2>

<p>
The next example shows how easy we can combine the <code>trapezoidal</code> and <code>midpoint</code>
functions to make a comparison of the two methods in the
file
<a href="https://github.com/hplgit/prog4comp/tree/master/src/py/compare_integration_methods.py" target="_self"><tt>compare_integration_methods.py</tt></a>:

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">trapezoidal</span> <span style="color: #008000; font-weight: bold">import</span> trapezoidal
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">midpoint</span> <span style="color: #008000; font-weight: bold">import</span> midpoint
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp

g <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> y: exp(<span style="color: #666666">-</span>y<span style="color: #666666">**2</span>)
a <span style="color: #666666">=</span> <span style="color: #666666">0</span>
b <span style="color: #666666">=</span> <span style="color: #666666">2</span>
<span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;    n        midpoint          trapezoidal&#39;</span>
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">1</span>, <span style="color: #666666">21</span>):
    n <span style="color: #666666">=</span> <span style="color: #666666">2**</span>i
    m <span style="color: #666666">=</span> midpoint(g, a, b, n)
    t <span style="color: #666666">=</span> trapezoidal(g, a, b, n)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%7d</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%.16f</span><span style="color: #BA2121"> </span><span style="color: #BB6688; font-weight: bold">%.16f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (n, m, t)
</pre></div>
<p>
Note the efforts put into nice formatting - the output becomes

<p>

<!-- code=text typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">    n        midpoint          trapezoidal
      2 0.8842000076332692 0.8770372606158094
      4 0.8827889485397279 0.8806186341245393
      8 0.8822686991994210 0.8817037913321336
     16 0.8821288703366458 0.8819862452657772
     32 0.8820933014203766 0.8820575578012112
     64 0.8820843709743319 0.8820754296107942
    128 0.8820821359746071 0.8820799002925637
    256 0.8820815770754198 0.8820810181335849
    512 0.8820814373412922 0.8820812976045025
   1024 0.8820814024071774 0.8820813674728968
   2048 0.8820813936736116 0.8820813849400392
   4096 0.8820813914902204 0.8820813893068272
   8192 0.8820813909443684 0.8820813903985197
  16384 0.8820813908079066 0.8820813906714446
  32768 0.8820813907737911 0.8820813907396778
  65536 0.8820813907652575 0.8820813907567422
 131072 0.8820813907631487 0.8820813907610036
 262144 0.8820813907625702 0.8820813907620528
 524288 0.8820813907624605 0.8820813907623183
1048576 0.8820813907624268 0.8820813907623890
</pre></div>
<p>
A visual inspection of the numbers shows how fast the digits
stabilize in both methods. It appears that 13 digits have stabilized
in the last two rows.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Remark.</b>
The trapezoidal and midpoint methods are just two examples in a jungle
of numerical integration rules. Other famous methods are
Simpson's rule and Gauss quadrature. They all work in the same way:

$$ \int_a^b f(x)dx \approx \sum_{i=0}^{n-1} w_if(x_i)\thinspace .$$

That is, the integral is approximated by a sum of function
evaluations, where each evaluation \( f(x_i) \) is given a weight \( w_i \).
The different methods differ in the way they construct the
evaluation points \( x_i \) and the weights \( w_i \).
We have used equally spaced points \( x_i \), but higher accuracy can be
obtained by optimizing the location of \( x_i \).
</div>


<h1 id="___sec90">Testing </h1>

<h2 id="___sec91">Problems with brief testing procedures </h2>

<p>
Testing of the programs for numerical integration has so far employed
two strategies. If we have an exact answer, we compute the error and
see that increasing \( n \) decreases the error. When the exact answer is
not available, we can (as in the comparison example in the previous
section) look at the integral values and see that they stabilize as
\( n \) grows. Unfortunately, these are very weak test procedures and not
at all satisfactory for claiming that the software we have produced is
correctly implemented.

<p>
To see this, we can introduce a bug in the
<code>application</code> function that calls <code>trapezoidal</code>: instead of
integrating \( 3t^2e^{t^3} \), we write &quot;accidentally&quot; \( 3t^3e^{t^3} \),
but keep the same anti-derivative \( V(t)e^{t^3} \) for computing the
error.  With the bug and \( n=4 \), the error is 0.1, but without the bug
the error is 0.2!  It is of course completely impossible to tell if
0.1 is the right value of the error. Fortunately, increasing \( n \) shows
that the error stays about 0.3 in the program with the bug, so
the test procedure with increasing \( n \) and checking that the error
decreases points to a problem in the code.

<p>
Let us look at another bug, this time in the mathematical algorithm:
instead of computing \( \frac{1}{2}(f(a) + f(b)) \) as we should, we
forget the second \( \frac{1}{2} \) and write <code>0.5*f(a) + f(b)</code>.  The error for
\( n=4,40,400 \) when computing
\( \int_{1.1}^{1.9} 3t^2e^{t^3}dt \) goes like \( 1400 \), \( 107 \), \( 10 \),
respectively, which looks promising.  The problem is that
the right errors should be \( 369 \), \( 4.08 \), and
\( 0.04 \). That is, the error should be reduced faster in the
correct than in the buggy code. The problem, however, is that it is
reduced in both codes, and we may stop further testing and believe
everything is correctly implemented.

<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Unit testing.</b>
A good habit is to test small pieces of a larger code individually, one at a time.
This is known as <em>unit testing</em>. One identifies a (small) unit of
the code, and then one makes a separate test for this unit. The unit test
should be stand-alone in the sense that it can be run without the
outcome of other tests. Typically, one algorithm
in scientific programs is considered as a unit. The challenge
with unit tests in numerical computing is to deal with numerical
approximation errors. A fortunate side effect of unit testing is that
the programmer is forced to use functions to modularize the code into smaller,
logical pieces.
</div>


<h2 id="sec:integrals:testprocs">Proper test procedures</h2>

<p>
There are three serious ways to test the implementation of
numerical methods via unit tests:

<ol>
<li> <em>Comparing with hand-computed results</em> in a problem with
   few arithmetic operations, i.e., small \( n \).</li>
<li> <em>Solving a problem without numerical errors</em>. We know that the trapezoidal
   rule must be exact for linear functions. The error produced
   by the program must then be zero (to machine precision).</li>
<li> <em>Demonstrating correct convergence rates</em>. A strong test when we can
   compute exact errors, is to see how fast the error goes
   to zero as \( n \) grows. In the trapezoidal and midpoint rules
   it is known that the error depends on \( n \) as \( n^{-2} \) as
   \( n\rightarrow\infty \).</li>
</ol>

<h3 id="___sec93">Hand-computed results </h3>

<p>
Let us use two trapezoids and compute the integral \( \int_0^1v(t) \),
\( v(t)=3t^2e^{t^3} \):

$$ \frac{1}{2}h(v(0) + v(0.5)) + \frac{1}{2}h(v(0.5)+v(1)) = 2.463642041244344,$$

when \( h=0.5 \) is the width of the two trapezoids. Running the program
gives exactly the same results.

<h3 id="___sec94">Solving a problem without numerical errors </h3>

<p>
The best unit tests for numerical algorithms involve mathematical
problems where we know the numerical result beforehand. Usually,
numerical results contain unknown approximation errors, so knowing the
numerical result implies that we have a problem where the
approximation errors vanish. This feature may be present in very
simple mathematical problems. For example, the trapezoidal method is
exact for integration of linear functions \( f(x)=ax+b \). We can
therefore pick some linear function and construct a test function that
checks equality between the exact analytical expression for the
integral and the number computed by the implementation of the
trapezoidal method.

<p>
A specific test case can be \( \int_{1.2}^{4.4} (6x-4)dx \). This
integral involves an &quot;arbitrary&quot; interval  \( [1.2, 4.4] \) and
an &quot;arbitrary&quot; linear function \( f(x) = 6x-4 \). By &quot;arbitrary&quot;
we mean expressions where we avoid the special numbers 0 and 1 since
these have special properties in arithmetic operations (e.g.,
forgetting to multiply is equivalent to multiplying by 1, and
forgetting to add is equivalent to adding 0).

<h3 id="___sec95">Demonstrating correct convergence rates </h3>

<p>
  Normally, unit tests must be based on problems where the numerical
approximation errors in our implementation remain unknown. However, we
often know or may assume a certain <em>asymptotic</em> behavior of the error.
We can do some experimental runs with the test problem \( \int_0^1
3t^2e^{t^3}dt \) where \( n \) is doubled in each run: \( n=4,8,16 \). The
corresponding errors are then 12%, 3% and 0.77%, respectively. These
numbers indicate that the error is roughly reduced by a factor of 4
when doubling \( n \). Thus, the error converges to zero as \( n^{-2} \) and
we say that the <em>convergence rate</em> is 2. In
fact, this result can also be shown mathematically for the trapezoidal
and midpoint method.  Numerical integration methods usually have an error
that converge to zero as \( n^{-p} \) for some \( p \) that depends on the
method. With such a result, it does not matter if we do not know what
the actual approximation error is: we know at what rate it is
<em>reduced</em>, so running the implementation for two or more different \( n \)
values will put us in a position to measure the expected rate and see if
it is achieved.

<p>
The idea of a corresponding unit test is then to run the algorithm for some \( n \) values,
compute the error (the absolute value of the difference between the
exact analytical result and the one produced by the numerical method),
and check that the error has <em>approximately</em> correct asymptotic
behavior, i.e., that the error is proportional to \( n^{-2} \) in case of
the trapezoidal and midpoint method.

<p>
Let us develop a more precise method for such unit tests based on
convergence rates.  We assume that the error \( E \) depends on \( n \)
according to

$$ E = Cn^r,$$

<p>
where \( C \) is an unknown constant and \( r \) is the convergence rate.
Consider a set of experiments with various \( n \):
\( n_0, n_1, n_2, \ldots,n_q \).
We compute the corresponding errors
\( E_0,\ldots,E_q \).
For two consecutive experiments, number \( i \) and \( i-1 \),
we have the error model

$$
\begin{align}
E_{i} &= Cn_{i}^r,
\tag{3.22}\\ 
E_{i-1} &= Cn_{i-1}^r\thinspace .
\tag{3.23}
\end{align}
$$

These are two equations for two unknowns \( C \) and \( r \).
We can easily eliminate \( C \) by dividing the equations by each other.
Then solving for \( r \) gives

$$
\begin{equation}
r_{i-1} = \frac{\ln (E_i/E_{i-1})}{\ln (n_i/n_{i-1})}\thinspace .
\tag{3.24}
\end{equation}
$$

We have introduced a subscript \( i-1 \) in \( r \)
since the estimated
value for \( r \) varies with \( i \). Hopefully,
\( r_{i-1} \) approaches
the correct convergence rate as the number of intervals increases
and \( i\rightarrow q \).

<h2 id="sec:integrals:finite_prec">Finite precision of floating-point numbers</h2>

<p>
The test procedures above lead to comparison of numbers for checking that
calculations were correct.
Such comparison is more complicated than what a newcomer might think.
Suppose we have a calculation <code>a + b</code> and want to check that the
result is what we expect. We start with 1 + 2:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> <span style="color: #666666">1</span>; b <span style="color: #666666">=</span> <span style="color: #666666">2</span>; expected <span style="color: #666666">=</span> <span style="color: #666666">3</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">+</span> b <span style="color: #666666">==</span> expected
<span style="color: #008000">True</span>
</pre></div>
<p>
Then we proceed with 0.1 + 0.2:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; b <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>; expected <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
<span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">+</span> b <span style="color: #666666">==</span> expected
<span style="color: #008000">False</span>
</pre></div>
<p>
So why is \( 0.1 + 0.2 \neq 0.3 \)? The reason is that real numbers cannot in
general be exactly represented on a computer. They must instead be
approximated by a <a href="https://en.wikipedia.org/wiki/Floating_point" target="_self">floating-point number</a> that can only store a finite amount of information, usually about
17 digits of a real number. Let us print 0.1, 0.2, 0.1 + 0.2, and 0.3
with 17 decimals:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%.17f</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BB6688; font-weight: bold">%.17f</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BB6688; font-weight: bold">%.17f</span><span style="color: #BB6622; font-weight: bold">\n</span><span style="color: #BB6688; font-weight: bold">%.17f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (<span style="color: #666666">0.1</span>, <span style="color: #666666">0.2</span>, <span style="color: #666666">0.1</span> <span style="color: #666666">+</span> <span style="color: #666666">0.2</span>, <span style="color: #666666">0.3</span>)
<span style="color: #666666">0.10000000000000001</span>
<span style="color: #666666">0.20000000000000001</span>
<span style="color: #666666">0.30000000000000004</span>
<span style="color: #666666">0.29999999999999999</span>
</pre></div>
<p>
We see that all of the numbers have an inaccurate digit in the 17th
decimal place. Because 0.1 + 0.2 evaluates to 0.30000000000000004
and 0.3 is represented as 0.29999999999999999, these two numbers
are not equal. In general, real numbers in Python have (at most)
16 correct decimals.

<p>
 When we compute with real numbers, these numbers are inaccurately
represented on the computer, and arithmetic operations with inaccurate
numbers lead to small rounding errors in the final results. Depending on
the type of numerical algorithm, the rounding errors may or may not
accumulate.

<p>
If we cannot make tests like <code>0.1 + 0.2 == 0.3</code>, what should we then do?
The answer is that we must accept some small inaccuracy and make
a test with a <em>tolerance</em>. Here is the recipe:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> a <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>; b <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>; expected <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
<span style="color: #666666">&gt;&gt;&gt;</span> computed <span style="color: #666666">=</span> a <span style="color: #666666">+</span> b
<span style="color: #666666">&gt;&gt;&gt;</span> diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
<span style="color: #666666">&gt;&gt;&gt;</span> tol <span style="color: #666666">=</span> <span style="color: #666666">1E-15</span>
<span style="color: #666666">&gt;&gt;&gt;</span> diff <span style="color: #666666">&lt;</span> tol
<span style="color: #008000">True</span>
</pre></div>
<p>
Here we have set the tolerance for comparison to \( 10^{-15} \), but
calculating <code>0.3 - (0.1 + 0.2)</code> shows that it equals
<code>-5.55e-17</code>, so a lower tolerance
could be used in this particular example. However, in other calculations
we have little idea about how accurate the answer is (there could be
accumulation of rounding errors in more complicated algorithms),
so \( 10^{-15} \) or \( 10^{-14} \) are robust values.
As we demonstrate below, these tolerances depend on the magnitude of
the numbers in the calculations.

<p>
 Doing an experiment with \( 10^k + 0.3 - (10^k + 0.1 + 0.2) \) for
\( k=1,\ldots,10 \) shows that the answer (which should be zero)
is around \( 10^{16-k} \). This means that the tolerance must be larger
if we compute with larger numbers. Setting a proper tolerance therefore
requires some experiments to see what level of accuracy one can expect.
A way out of this difficulty is to work with <em>relative</em> instead of
<em>absolute</em> differences. In a relative difference we divide by one of
the operands, e.g.,

$$ a = 10^k + 0.3,\quad b = (10^k + 0.1 + 0.2),\quad c = \frac{a - b}{a}\thinspace .$$

Computing this \( c \) for various \( k \) shows a value around \( 10^{-16} \).
A safer procedure is thus to use <em>relative differences</em>.

<h2 id="sec:integrals:test:functions">Constructing unit tests and writing test functions</h2>

<p>
Python has several frameworks for automatically running and checking a
potentially very large number of tests for parts of your software by
one command.
This is an extremely useful feature during program
development: whenever you have done some changes to one or more files,
launch the test command and make sure nothing is broken because of
your edits.

<p>
  The test frameworks <code>nose</code> and <code>py.test</code> are particularly attractive
as they are very easy to use.
Tests are placed in special <em>test functions</em>
that the frameworks can recognize and run for you. The requirements
to a test function are simple:

<ul>
 <li> the name must start with <code>test_</code></li>
 <li> the test function cannot have any arguments</li>
 <li> the tests inside test functions must be boolean expressions</li>
 <li> a boolean expression <code>b</code> must be tested with <code>assert b, msg</code>,
   where <code>msg</code> is an optional object (string or number) to be written out
   when <code>b</code> is false</li>
</ul>

Suppose we have written a function

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">add</span>(a, b):
    <span style="color: #008000; font-weight: bold">return</span> a <span style="color: #666666">+</span> b
</pre></div>
<p>
A corresponding test function can then be

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_add</span>()
    expected <span style="color: #666666">=</span> <span style="color: #666666">1</span> <span style="color: #666666">+</span> <span style="color: #666666">1</span>
    computed <span style="color: #666666">=</span> add(<span style="color: #666666">1</span>, <span style="color: #666666">1</span>)
    <span style="color: #008000; font-weight: bold">assert</span> computed <span style="color: #666666">==</span> expected, <span style="color: #BA2121">&#39;1+1=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> computed
</pre></div>
<p>
Test functions can be in any program file or in separate files,
typically with names starting with <code>test</code>. You can also collect
tests in subdirectories: running <code>py.test -s -v</code> will actually
run all tests in all <code>test*.py</code> files in all subdirectories, while
<code>nosetests -s -v</code> restricts the attention to subdirectories whose
names start with <code>test</code> or end with <code>_test</code> or <code>_tests</code>.

<p>
As long as we add integers, the equality test in the <code>test_add</code>
function is appropriate, but if we try to call <code>add(0.1, 0.2)</code>
instead, we will face the rounding error problems explained in
the section <a href="#sec:integrals:finite_prec">Finite precision of floating-point numbers</a>, and we must use a test
with tolerance instead:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_add</span>()
    expected <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
    computed <span style="color: #666666">=</span> add(<span style="color: #666666">0.1</span>, <span style="color: #666666">0.2</span>)
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    diff <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
    <span style="color: #008000; font-weight: bold">assert</span> diff <span style="color: #666666">&lt;</span> tol, <span style="color: #BA2121">&#39;diff=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> diff
</pre></div>
<p>
Below we shall write test functions for each of the three test
procedures we suggested: comparison with hand calculations,
checking problems that can be exactly solved, and checking convergence
rates. We stick to testing the trapezoidal integration code and collect all
test functions in one common file by the name <code>test_trapezoidal.py</code>.

<h3 id="___sec98">Hand-computed numerical results </h3>

<p>
Our previous hand calculations for two trapezoids can be checked against
the <code>trapezoidal</code> function inside a test function
(in a file <a href="https://github.com/hplgit/prog4comp/tree/master/src/py/test_trapezoidal.py" target="_self"><tt>test_trapezoidal.py</tt></a>):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">trapezoidal</span> <span style="color: #008000; font-weight: bold">import</span> trapezoidal

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_trapezoidal_one_exact_result</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Compare one hand-computed result.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp
    v <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">3*</span>(t<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>exp(t<span style="color: #666666">**3</span>)
    n <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    computed <span style="color: #666666">=</span> trapezoidal(v, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, n)
    expected <span style="color: #666666">=</span> <span style="color: #666666">2.463642041244344</span>
    error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    success <span style="color: #666666">=</span> error <span style="color: #666666">&lt;</span> tol
    msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;error=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121"> &gt; tol=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (errror, tol)
    <span style="color: #008000; font-weight: bold">assert</span> success, msg
</pre></div>
<p>
Note the importance of checking <code>err</code> against <code>exact</code> with a tolerance:
rounding errors from the arithmetics inside <code>trapezoidal</code> will not
make the result exactly like the hand-computed one. The size of
the tolerance is here set to \( 10^{-14} \), which is a kind of all-round
value for computations with numbers not deviating much from unity.

<h3 id="___sec99">Solving a problem without numerical errors </h3>

<p>
We know that the trapezoidal rule is exact for linear integrands.
Choosing the integral \( \int_{1.2}^{4.4} (6x-4)dx \) as test case,
the corresponding
test function for this unit test may look like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_trapezoidal_linear</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Check that linear functions are integrated exactly.&quot;&quot;&quot;</span>
    f <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: <span style="color: #666666">6*</span>x <span style="color: #666666">-</span> <span style="color: #666666">4</span>
    F <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> x: <span style="color: #666666">3*</span>x<span style="color: #666666">**2</span> <span style="color: #666666">-</span> <span style="color: #666666">4*</span>x  <span style="color: #408080; font-style: italic"># Anti-derivative</span>
    a <span style="color: #666666">=</span> <span style="color: #666666">1.2</span>; b <span style="color: #666666">=</span> <span style="color: #666666">4.4</span>
    expected <span style="color: #666666">=</span> F(b) <span style="color: #666666">-</span> F(a)
    tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
    <span style="color: #008000; font-weight: bold">for</span> n <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #666666">2</span>, <span style="color: #666666">20</span>, <span style="color: #666666">21</span>:
        computed <span style="color: #666666">=</span> trapezoidal(f, a, b, n)
        error <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
        success <span style="color: #666666">=</span> error <span style="color: #666666">&lt;</span> tol
        msg <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;n=</span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121">, err=</span><span style="color: #BB6688; font-weight: bold">%g</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (n, error)
        <span style="color: #008000; font-weight: bold">assert</span> success, msg
</pre></div>

<h3 id="___sec100">Demonstrating correct convergence rates </h3>

<p>
In the present example with integration, it is known that the
approximation errors in the trapezoidal rule are proportional to
\( n^{-2} \), \( n \) being the number of subintervals used in the composite
rule.

<p>
Computing convergence rates requires somewhat more tedious programming than
the previous tests, but can be applied to more general integrands.
The algorithm typically goes like

<ul>
 <li> for \( i=0,1,2,\ldots,q \)</li>

<ul>
   <li> \( n_i = 2^{i+1} \)</li>
   <li> Compute integral with \( n_i \) intervals</li>
   <li> Compute the error \( E_i \)</li>
   <li> Estimate \( r_i \) from <a href="#mjx-eqn-3.24">(3.24)</a>
     if \( i>0 \)</li>
</ul>

</ul>

The corresponding code may look like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">convergence_rates</span>(f, F, a, b, num_experiments<span style="color: #666666">=14</span>):
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> log
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> zeros
    expected <span style="color: #666666">=</span> F(b) <span style="color: #666666">-</span> F(a)
    n <span style="color: #666666">=</span> zeros(num_experiments, dtype<span style="color: #666666">=</span><span style="color: #008000">int</span>)
    E <span style="color: #666666">=</span> zeros(num_experiments)
    r <span style="color: #666666">=</span> zeros(num_experiments<span style="color: #666666">-1</span>)
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(num_experiments):
        n[i] <span style="color: #666666">=</span> <span style="color: #666666">2**</span>(i<span style="color: #666666">+1</span>)
        computed <span style="color: #666666">=</span> trapezoidal(f, a, b, n[i])
        E[i] <span style="color: #666666">=</span> <span style="color: #008000">abs</span>(expected <span style="color: #666666">-</span> computed)
        <span style="color: #008000; font-weight: bold">if</span> i <span style="color: #666666">&gt;</span> <span style="color: #666666">0</span>:
            r_im1 <span style="color: #666666">=</span> log(E[i]<span style="color: #666666">/</span>E[i<span style="color: #666666">-1</span>])<span style="color: #666666">/</span>log(<span style="color: #008000">float</span>(n[i])<span style="color: #666666">/</span>n[i<span style="color: #666666">-1</span>])
            r[i<span style="color: #666666">-1</span>] <span style="color: #666666">=</span> <span style="color: #008000">float</span>(<span style="color: #BA2121">&#39;</span><span style="color: #BB6688; font-weight: bold">%.2f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> r_im1) <span style="color: #408080; font-style: italic"># Truncate to two decimals</span>
    <span style="color: #008000; font-weight: bold">return</span> r
</pre></div>
<p>
Making a test function is a matter of choosing <code>f</code>, <code>F</code>, <code>a</code>, and <code>b</code>,
and then checking the value of \( r_i \) for the largest \( i \):

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_trapezoidal_conv_rate</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Check empirical convergence rates against the expected -2.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">math</span> <span style="color: #008000; font-weight: bold">import</span> exp
    v <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">3*</span>(t<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>exp(t<span style="color: #666666">**3</span>)
    V <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: exp(t<span style="color: #666666">**3</span>)
    a <span style="color: #666666">=</span> <span style="color: #666666">1.1</span>; b <span style="color: #666666">=</span> <span style="color: #666666">1.9</span>
    r <span style="color: #666666">=</span> convergence_rates(v, V, a, b, <span style="color: #666666">14</span>)
    <span style="color: #008000; font-weight: bold">print</span> r
    tol <span style="color: #666666">=</span> <span style="color: #666666">0.01</span>
    msg <span style="color: #666666">=</span> <span style="color: #008000">str</span>(r[<span style="color: #666666">-4</span>:])  <span style="color: #408080; font-style: italic"># show last 4 estimated rates</span>
    <span style="color: #008000; font-weight: bold">assert</span> (<span style="color: #008000">abs</span>(r[<span style="color: #666666">-1</span>]) <span style="color: #666666">-</span> <span style="color: #666666">2</span>) <span style="color: #666666">&lt;</span> tol, msg
</pre></div>
<p>
Running the test shows that all \( r_i \), except the first one, equal
the target limit 2 within two decimals. This observation suggest a
tolerance of \( 10^{-2} \).

<p>
<div class="alert alert-block alert-danger alert-text-normal"><b>Remark about version control of files.</b>
Having a suite of test functions for automatically checking that your
software works is considered as a fundamental requirement for reliable
computing. Equally important is a system that can keep track of
different versions of the files and the tests, known as a <em>version control
system</em>. Today's most popular version control system is <a href="https://en.wikipedia.org/wiki/Git_(software)" target="_self">Git</a>, which the
authors strongly recommend the reader to use for programming and writing
reports. The combination of Git and cloud storage such as GitHub is a
very common way of organizing scientific or engineering work.
We have a <a href="http://hplgit.github.io/teamods/bitgit/Langtangen_bitgit-bootstrap.html" target="_self">quick intro</a> to Git and GitHub that gets you up and running within
minutes.

<p>
The typical workflow with Git goes as follows.

<ol>
<li> Before you start working with files, make sure you have the latest
   version of them by running <code>git pull</code>.</li>
<li> Edit files, remove or create files (new files must be registered
   by <code>git add</code>).</li>
<li> When a natural piece of work is done, <em>commit</em> your changes by the
   <code>git commit</code> command.</li>
<li> Implement your changes also in the cloud by doing <code>git push</code>.</li>
</ol>

A nice feature of Git is that people can edit the same file at the same
time and very often Git will be able to automatically merge the changes (!).
Therefore, version control is crucial when you work with others or when
you do your work on different types of computers.
Another key feature is that anyone can at any time view the history of
a file, see who did what when, and roll back the entire file collection
to a previous commit. This feature is, of course, fundamental for
reliable work.
</div>


<h1 id="___sec101">Vectorization </h1>

<p>
The functions <code>midpoint</code> and <code>trapezoid</code> usually run fast in Python
and compute an integral to a satisfactory precision within a
fraction of a second. However, long loops in Python may run slowly in more
complicated implementations. To increase the speed, the loops
can be replaced by vectorized code. The integration functions constitute
a simple and good example to illustrate how to vectorize loops.

<p>
We have already seen simple examples on vectorization in
the section <a href="._p4c-bootstrap-Python006.html#1st:ex3">A Python program with vectorization and plotting</a> when we could evaluate a mathematical function \( f(x) \)
for a large number of \( x \) values stored in an array.
Basically, we can write

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x):
    <span style="color: #008000; font-weight: bold">return</span> exp(<span style="color: #666666">-</span>x)<span style="color: #666666">*</span>sin(x) <span style="color: #666666">+</span> <span style="color: #666666">5*</span>x

<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> exp, sin, linspace
x <span style="color: #666666">=</span> linspace(<span style="color: #666666">0</span>, <span style="color: #666666">4</span>, <span style="color: #666666">101</span>)  <span style="color: #408080; font-style: italic"># coordinates from 100 intervals on [0, 4]</span>
y <span style="color: #666666">=</span> f(x)                 <span style="color: #408080; font-style: italic"># all points evaluated at once</span>
</pre></div>
<p>
The result <code>y</code> is the array that would be computed if we ran a
<code>for</code> loop over the individual
<code>x</code> values and called <code>f</code> for each value. Vectorization essentially
eliminates this loop in Python (i.e., the looping over <code>x</code> and application
of <code>f</code> to each <code>x</code> value are instead performed
in a library with fast, compiled code).

<h3 id="___sec102">Vectorizing the midpoint rule </h3>

<p>
<!-- Vectorization of algorithms with loops is a creative process and requires -->
<!-- experience. -->
The aim of vectorizing the <code>midpoint</code> and <code>trapezoidal</code> functions is
also to remove the explicit loop in Python.
We start with vectorizing the <code>midpoint</code> function since <code>trapezoid</code>
is not equally straightforward. The fundamental ideas of the vectorized
algorithm are to

<ol>
<li> compute all the evaluation points in one array <code>x</code></li>
<li> call <code>f(x)</code> to produce an array of corresponding function values</li>
<li> use the <code>sum</code> function to sum the <code>f(x)</code> values</li>
</ol>

The evaluation points in the midpoint method are
\( x_i=a+(i+\frac{1}{2})h \), \( i=0,\ldots,n-1 \). That is, \( n \) uniformly
distributed coordinates between \( a+h/2 \) and \( b-h/2 \). Such coordinates
can be calculated by <code>x = linspace(a+h/2, b-h/2, n)</code>.
Given that the
Python implementation <code>f</code> of the mathematical function \( f \) works with
an array argument,
which is very often the case in Python,
<code>f(x)</code> will produce all the function values in an
array. The array elements are then summed up by <code>sum</code>: <code>sum(f(x))</code>. This
sum is to be multiplied by the rectangle width \( h \) to produce
the integral value. The complete function is listed below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> linspace, <span style="color: #008000">sum</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint</span>(f, a, b, n):
    h <span style="color: #666666">=</span> <span style="color: #008000">float</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n
    x <span style="color: #666666">=</span> linspace(a <span style="color: #666666">+</span> h<span style="color: #666666">/2</span>, b <span style="color: #666666">-</span> h<span style="color: #666666">/2</span>, n)
    <span style="color: #008000; font-weight: bold">return</span> h<span style="color: #666666">*</span><span style="color: #008000">sum</span>(f(x))
</pre></div>
<p>
The code is found in the
file
<a href="https://github.com/hplgit/prog4comp/tree/master/src/py/integration_methods_vec.py" target="_self"><tt>integration_methods_vec.py</tt></a>.

<p>
Let us test the code interactively in a Python shell to compute
\( \int_0^1 3t^2dt \). The file with the code above has the name
<code>integration_methods_vec.py</code> and is a valid module from which we
can import the vectorized function:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">integration_methods_vec</span> <span style="color: #008000; font-weight: bold">import</span> midpoint
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> exp
<span style="color: #666666">&gt;&gt;&gt;</span> v <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">3*</span>t<span style="color: #666666">**2*</span>exp(t<span style="color: #666666">**3</span>)
<span style="color: #666666">&gt;&gt;&gt;</span> midpoint(v, <span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">10</span>)
<span style="color: #666666">1.7014827690091872</span>
</pre></div>
<p>
Note the necessity to use <code>exp</code> from <code>numpy</code>: our <code>v</code> function will
be called with <code>x</code> as an array, and the <code>exp</code> function must be
capable of working with an array.

<p>
The vectorized code performs all loops very efficiently in compiled
code, resulting in much faster execution. Moreover, many readers of
the code will also say that the algorithm looks clearer than in the
loop-based implementation.

<h3 id="___sec103">Vectorizing the trapezoidal rule </h3>

<p>
We can use the same approach to vectorize the <code>trapezoid</code> function.
However, the trapezoidal rule performs a sum where the end points
have different weight. If we do <code>sum(f(x))</code>, we get the end points
<code>f(a)</code> and <code>f(b)</code> with weight unity instead of one half. A remedy
is to subtract the error from <code>sum(f(x))</code>: <code>sum(f(x)) - 0.5*f(a) - 0.5*f(b)</code>.
The vectorized version of the trapezoidal method then becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">trapezoidal</span>(f, a, b, n):
    h <span style="color: #666666">=</span> <span style="color: #008000">float</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n
    x <span style="color: #666666">=</span> linspace(a, b, n<span style="color: #666666">+1</span>)
    s <span style="color: #666666">=</span> <span style="color: #008000">sum</span>(f(x)) <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>f(a) <span style="color: #666666">-</span> <span style="color: #666666">0.5*</span>f(b)
    <span style="color: #008000; font-weight: bold">return</span> h<span style="color: #666666">*</span>s
</pre></div>

<h1 id="___sec104">Measuring computational speed </h1>

<p>
Now that we have created faster, vectorized versions of functions in
the previous section, it is interesting to measure how much faster
they are. The purpose of the present section is therefore to
explain how we can record the CPU time consumed by a function so
we can answer this question.
There are many techniques for measuring the CPU time in Python,
and here we shall
just explain the simplest and most convenient one: the <code>%timeit</code>
command in IPython. The following interactive session should
illustrate a competition where the vectorized versions of the
functions are supposed to win:

<p>

<!-- code=ipy (!bc ipy) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #000080; font-weight: bold">In [1]: </span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">integration_methods_vec</span> <span style="color: #008000; font-weight: bold">import</span> midpoint <span style="color: #008000; font-weight: bold">as</span> midpoint_vec

<span style="color: #000080; font-weight: bold">In [3]: </span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">midpoint</span> <span style="color: #008000; font-weight: bold">import</span> midpoint

<span style="color: #000080; font-weight: bold">In [4]: </span><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">import</span> exp

<span style="color: #000080; font-weight: bold">In [5]: </span>v <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">lambda</span> t: <span style="color: #666666">3*</span>t<span style="color: #666666">**2*</span>exp(t<span style="color: #666666">**3</span>)

<span style="color: #000080; font-weight: bold">In [6]: </span><span style="color: #666666">%</span><span style="color: #008000; font-weight: bold">timeit</span> midpoint_vec(v, 0, 1, 1000000)
<span style="color: #888888">1 loops, best of 3: 379 ms per loop</span>

<span style="color: #000080; font-weight: bold">In [7]: </span><span style="color: #666666">%</span><span style="color: #008000; font-weight: bold">timeit</span> midpoint(v, 0, 1, 1000000)
<span style="color: #888888">1 loops, best of 3: 8.17 s per loop</span>

<span style="color: #000080; font-weight: bold">In [8]: </span><span style="color: #666666">8.17/</span>(<span style="color: #666666">379*0.001</span>)    <span style="color: #408080; font-style: italic"># efficiency factor</span>
<span style="color: #000080; font-weight: bold">Out[8]: </span><span style="color: #888888">21.556728232189972</span>
</pre></div>
<p>
We see that the vectorized version is about 20 times faster: 379 ms
versus 8.17 s. The results
for the trapezoidal method are very similar, and the factor of about 20
is independent of the number of intervals.

<h1 id="sec:int:double">Double and triple integrals</h1>

<h2 id="sec:int:double:midpoint">The midpoint rule for a double integral</h2>

<p>
 Given a double integral over a rectangular domain \( [a,b]\times [c,d] \),

$$ \int_a^b \int_c^d f(x,y) dydx,$$

how can we approximate this integral by numerical methods?

<h3 id="___sec107">Derivation via one-dimensional integrals </h3>

<p>
Since we know how to
deal with integrals in one variable, a fruitful approach is to view
the double integral as two integrals, each in one variable, which
can be approximated numerically by previous one-dimensional formulas.
To this end,
we introduce
a help function \( g(x) \) and write

$$ \int_a^b \int_c^d f(x,y) dydx = \int_a^b g(x)dx,\quad
g(x) = \int_c^d f(x,y) dy\thinspace .$$

Each of the integrals

$$ \int_a^b g(x)dx,\quad
g(x) = \int_c^d f(x,y) dy$$

can be discretized by any numerical
integration rule for an integral in one variable. Let us use the
midpoint method
<a href="#mjx-eqn-3.21">(3.21)</a>
and start with \( g(x)=\int_c^d f(x,y)dy \). We introduce
\( n_y \) intervals on \( [c,d] \) with length \( h_y \). The midpoint rule
for this integral then becomes

$$ g(x) = \int_c^d f(x,y) dy \approx  h_y \sum_{j=0}^{n_y-1} f(x,y_j),
\quad y_j = c + \frac{1}{2}{h_y} + jh_y \thinspace . $$

The expression looks somewhat different from <a href="#mjx-eqn-3.21">(3.21)</a>,
but that is because of the notation: since we integrate in the \( y \) direction
and will have to work with both \( x \) and \( y \) as coordinates, we must
use \( n_y \) for \( n \), \( h_y \) for \( h \), and the counter \( i \) is more naturally
called \( j \) when integrating in \( y \). Integrals in the \( x \) direction will use
\( h_x \) and \( n_x \) for \( h \) and \( n \), and \( i \) as counter.

<p>
The double integral is \( \int_a^b g(x)dx \), which can be approximated
by the midpoint method:

$$ \int_a^b g(x)dx \approx h_x \sum_{i=0}^{n_x-1} g(x_i),\quad x_i=a + \frac{1}{2}{h_x} + ih_x\thinspace .$$

Putting the formulas together, we arrive at the <em>composite midpoint method
for a double integral</em>:

$$
\begin{align}
\int_a^b \int_c^d f(x,y) dydx &\approx
h_x \sum_{i=0}^{n_x-1} h_y \sum_{j=0}^{n_y-1} f(x_i,y_j)\nonumber\\ 
&=
h_xh_y \sum_{i=0}^{n_x-1} \sum_{j=0}^{n_y-1} f(a + \frac{h_x}{2} + ih_x, c + \frac{h_y}{2} + jh_y)\thinspace .
\tag{3.25}
\end{align}
$$

<h3 id="___sec108">Direct derivation </h3>

<p>
The formula <a href="#mjx-eqn-3.25">(3.25)</a> can also be derived directly
in the two-dimensional case by applying the idea of the midpoint
method. We divide the rectangle \( [a,b]\times [c,d] \) into
\( n_x\times n_y \) equal-sized cells. The idea of the midpoint method is
to approximate \( f \) by a constant over each cell, and evaluate the constant
at the midpoint. Cell \( (i,j) \) occupies the area

$$ [a+ih_x,a+(i+1)h_x]\times [c+jh_y, c+ (j+1)h_y],$$

and the midpoint is \( (x_i,y_j) \) with

$$ x_i=a + ih_x + \frac{1}{2}{h_x} ,\quad y_j = c + jh_y + \frac{1}{2}{h_y}
\thinspace .$$

The integral over the cell is therefore \( h_xh_y f(x_i,y_j) \), and
the total double integral is the sum over all cells, which is
nothing but formula <a href="#mjx-eqn-3.25">(3.25)</a>.

<h3 id="___sec109">Programming a double sum </h3>

<p>
The formula <a href="#mjx-eqn-3.25">(3.25)</a> involves a double sum,
which is normally implemented as a double for loop. A Python function
implementing <a href="#mjx-eqn-3.25">(3.25)</a> may look like

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint_double1</span>(f, a, b, c, d, nx, ny):
    hx <span style="color: #666666">=</span> (b <span style="color: #666666">-</span> a)<span style="color: #666666">/</span><span style="color: #008000">float</span>(nx)
    hy <span style="color: #666666">=</span> (d <span style="color: #666666">-</span> c)<span style="color: #666666">/</span><span style="color: #008000">float</span>(ny)
    I <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(nx):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(ny):
            xi <span style="color: #666666">=</span> a <span style="color: #666666">+</span> hx<span style="color: #666666">/2</span> <span style="color: #666666">+</span> i<span style="color: #666666">*</span>hx
            yj <span style="color: #666666">=</span> c <span style="color: #666666">+</span> hy<span style="color: #666666">/2</span> <span style="color: #666666">+</span> j<span style="color: #666666">*</span>hy
            I <span style="color: #666666">+=</span> hx<span style="color: #666666">*</span>hy<span style="color: #666666">*</span>f(xi, yj)
    <span style="color: #008000; font-weight: bold">return</span> I
</pre></div>
<p>
If this function is stored in a module file
<a href="https://github.com/hplgit/prog4comp/tree/master/src/py/midpoint_double.py" target="_self"><tt>midpoint_double.py</tt></a>,
we can compute some integral, e.g.,
\( \int_2^3\int_0^2 (2x + y)dxdy=9 \) in an interactive shell
and demonstrate that the function computes the right number:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">midpoint_double</span> <span style="color: #008000; font-weight: bold">import</span> midpoint_double1
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x, y):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>x <span style="color: #666666">+</span> y
<span style="color: #666666">...</span>
<span style="color: #666666">&gt;&gt;&gt;</span> midpoint_double1(f, <span style="color: #666666">0</span>, <span style="color: #666666">2</span>, <span style="color: #666666">2</span>, <span style="color: #666666">3</span>, <span style="color: #666666">5</span>, <span style="color: #666666">5</span>)
<span style="color: #666666">9.0</span>
</pre></div>

<h3 id="___sec110">Reusing code for one-dimensional integrals </h3>

<p>
It is very natural to write a two-dimensional midpoint method as we did in
function <code>midpoint_double1</code> when we have the formula <a href="#mjx-eqn-3.25">(3.25)</a>. However, we could alternatively ask, much as we did in the mathematics,
can we reuse a well-tested implementation for one-dimensional integrals
to compute double integrals? That is, can we use function <code>midpoint</code>

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint</span>(f, a, b, n):
    h <span style="color: #666666">=</span> <span style="color: #008000">float</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n
    result <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        result <span style="color: #666666">+=</span> f((a <span style="color: #666666">+</span> h<span style="color: #666666">/2.0</span>) <span style="color: #666666">+</span> i<span style="color: #666666">*</span>h)
    result <span style="color: #666666">*=</span> h
    <span style="color: #008000; font-weight: bold">return</span> result
</pre></div>
<p>
from the section <a href="#sec:midpoint:code">Implementation</a> &quot;twice&quot;?
The answer is yes, if we think as we did in the mathematics: compute
the double integral as a midpoint rule for integrating \( g(x) \) and define
\( g(x_i) \) in terms of a midpoint
rule over \( f \) in the \( y \) coordinate. The corresponding function has very
short code:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint_double2</span>(f, a, b, c, d, nx, ny):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">g</span>(x):
        <span style="color: #008000; font-weight: bold">return</span> midpoint(<span style="color: #008000; font-weight: bold">lambda</span> y: f(x, y), c, d, ny)

    <span style="color: #008000; font-weight: bold">return</span> midpoint(g, a, b, nx)
</pre></div>
<p>
The important advantage of this implementation is that we reuse a well-tested
function for the standard one-dimensional midpoint rule and that we
apply the one-dimensional rule exactly as in the mathematics.

<h3 id="___sec111">Verification via test functions </h3>

<p>
How can we test that our functions for the double integral work?
The best unit test is to find a problem where the numerical approximation
error vanishes because then we know exactly what the numerical
answer should be. The midpoint rule is exact for linear functions,
regardless of how many subinterval we use.
Also, any linear two-dimensional function \( f(x,y)=px+qy+r \) will be integrated
exactly by the two-dimensional midpoint rule. We may pick
\( f(x,y)=2x+y \) and create a proper <em>test function</em> that can automatically
verify our two alternative implementations of the two-dimensional
midpoint rule. To compute the integral of \( f(x,y) \) we take advantage of
SymPy to eliminate the possibility of errors in hand calculations.
The test function becomes

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_midpoint_double</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Test that a linear function is integrated exactly.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>(x, y):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>x <span style="color: #666666">+</span> y

    a <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  b <span style="color: #666666">=</span> <span style="color: #666666">2</span>;  c <span style="color: #666666">=</span> <span style="color: #666666">2</span>;  d <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span>
    x, y <span style="color: #666666">=</span> sympy<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x  y&#39;</span>)
    I_expected <span style="color: #666666">=</span> sympy<span style="color: #666666">.</span>integrate(f(x, y), (x, a, b), (y, c, d))
    <span style="color: #408080; font-style: italic"># Test three cases: nx &lt; ny, nx = ny, nx &gt; ny</span>
    <span style="color: #008000; font-weight: bold">for</span> nx, ny <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #666666">3</span>, <span style="color: #666666">5</span>), (<span style="color: #666666">4</span>, <span style="color: #666666">4</span>), (<span style="color: #666666">5</span>, <span style="color: #666666">3</span>):
        I_computed1 <span style="color: #666666">=</span> midpoint_double1(f, a, b, c, d, nx, ny)
        I_computed2 <span style="color: #666666">=</span> midpoint_double2(f, a, b, c, d, nx, ny)
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #408080; font-style: italic">#print I_expected, I_computed1, I_computed2</span>
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(I_computed1 <span style="color: #666666">-</span> I_expected) <span style="color: #666666">&lt;</span> tol
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(I_computed2 <span style="color: #666666">-</span> I_expected) <span style="color: #666666">&lt;</span> tol
</pre></div>
<p>
<div class="alert alert-block alert-success alert-text-normal"><b>Let test functions speak up?</b>
If we call the above <code>test_midpoint_double</code> function
and nothing happens, our implementations
are correct. However, it is somewhat annoying to have a function that
is completely silent when it works - are we sure all things are properly
computed? During development it is therefore highly recommended to insert
a print statement such that we can monitor the calculations and be
convinced that the test function does what we want. Since a test
function should not have any print statement, we simply comment it out as
we have done in the function listed above.
</div>


<p>
The trapezoidal method can be used as alternative for the midpoint
method.  The derivation of a formula for the double integral and the
implementations follow exactly the same ideas as we explained with the
midpoint method, but there are more terms to write in the
formulas. <a href="._p4c-bootstrap-Python018.html#sec:exer:trapezoidal:2D">Exercise 42: Derive the trapezoidal rule for a double integral</a> asks you to carry out
the details. That exercise is a very good test on your understanding of the
mathematical and programming ideas in the present section.

<h2 id="___sec112">The midpoint rule for a triple integral </h2>

<h3 id="___sec113">Theory </h3>

<p>
Once a method that works for a one-dimensional problem is generalized
to two dimensions, it is usually quite straightforward to extend the
method to three dimensions. This will now be demonstrated for
integrals. We have the triple integral

$$ \int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx$$

and want to approximate the integral by a midpoint rule.
Following the ideas for the double integral, we
split this integral into one-dimensional integrals:

$$
\begin{align*}
p(x,y) &= \int_e^f g(x,y,z) dz\\ 
q(x) &= \int_c^d p(x,y) dy\\ 
\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx &= \int_a^b q(x)dx
\end{align*}
$$

For each of these one-dimensional integrals we apply the midpoint rule:

$$
\begin{align*}
p(x,y) = \int_e^f g(x,y,z) dz
&\approx \sum_{k=0}^{n_z-1} g(x,y,z_k),
\\ 
q(x) = \int_c^d p(x,y) dy
&\approx \sum_{j=0}^{n_y-1} p(x,y_j),
\\ 
\int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx = \int_a^b q(x)dx
&\approx \sum_{i=0}^{n_x-1} q(x_i),
\end{align*}
$$

where

$$
z_k=e + \frac{1}{2}h_z + kh_z,\quad y_j=c + \frac{1}{2}h_y + jh_y \quad
x_i=a + \frac{1}{2}h_x + ih_x
\thinspace .
$$

Starting with the formula for \( \int_{a}^{b} \int_c^d \int_e^f g(x,y,z) dzdydx \)
and inserting the two previous formulas gives

$$
\begin{align}
& \int_{a}^{b} \int_c^d \int_e^f g(x,y,z)\, dzdydx\approx\nonumber\\ 
& h_xh_yh_z
\sum_{i=0}^{n_x-1}\sum_{j=0}^{n_y-1}\sum_{k=0}^{n_z-1}
g(a + \frac{1}{2}h_x + ih_x,
c + \frac{1}{2}h_y + jh_y,
e + \frac{1}{2}h_z + kh_z)\thinspace .
\tag{3.26}
\end{align}
$$

Note that we may apply the ideas under <em>Direct derivation</em> at
the end of the section <a href="#sec:int:double:midpoint">The midpoint rule for a double integral</a> to arrive
at <a href="#mjx-eqn-3.26">(3.26)</a> directly: divide
the domain into \( n_x\times n_y\times n_z \) cells of volumes
\( h_xh_yh_z \); approximate \( g \)
by a constant, evaluated at the midpoint \( (x_i,y_j,z_k) \),
in each cell; and
sum the cell integrals \( h_xh_yh_zg(x_i,y_j,z_k) \).

<h3 id="___sec114">Implementation </h3>

<p>
We follow the ideas for the implementations of the midpoint rule
for a double integral. The corresponding functions are shown below
and found in the file
<a href="https://github.com/hplgit/prog4comp/tree/master/src/py/midpoint_triple.py" target="_self"><tt>midpoint_triple.py</tt></a>.

<p>

<!-- code=python (!bc pypro) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint_triple1</span>(g, a, b, c, d, e, f, nx, ny, nz):
    hx <span style="color: #666666">=</span> (b <span style="color: #666666">-</span> a)<span style="color: #666666">/</span><span style="color: #008000">float</span>(nx)
    hy <span style="color: #666666">=</span> (d <span style="color: #666666">-</span> c)<span style="color: #666666">/</span><span style="color: #008000">float</span>(ny)
    hz <span style="color: #666666">=</span> (f <span style="color: #666666">-</span> e)<span style="color: #666666">/</span><span style="color: #008000">float</span>(nz)
    I <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(nx):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(ny):
            <span style="color: #008000; font-weight: bold">for</span> k <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(nz):
                xi <span style="color: #666666">=</span> a <span style="color: #666666">+</span> hx<span style="color: #666666">/2</span> <span style="color: #666666">+</span> i<span style="color: #666666">*</span>hx
                yj <span style="color: #666666">=</span> c <span style="color: #666666">+</span> hy<span style="color: #666666">/2</span> <span style="color: #666666">+</span> j<span style="color: #666666">*</span>hy
                zk <span style="color: #666666">=</span> e <span style="color: #666666">+</span> hz<span style="color: #666666">/2</span> <span style="color: #666666">+</span> k<span style="color: #666666">*</span>hz
                I <span style="color: #666666">+=</span> hx<span style="color: #666666">*</span>hy<span style="color: #666666">*</span>hz<span style="color: #666666">*</span>g(xi, yj, zk)
    <span style="color: #008000; font-weight: bold">return</span> I

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint</span>(f, a, b, n):
    h <span style="color: #666666">=</span> <span style="color: #008000">float</span>(b<span style="color: #666666">-</span>a)<span style="color: #666666">/</span>n
    result <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n):
        result <span style="color: #666666">+=</span> f((a <span style="color: #666666">+</span> h<span style="color: #666666">/2.0</span>) <span style="color: #666666">+</span> i<span style="color: #666666">*</span>h)
    result <span style="color: #666666">*=</span> h
    <span style="color: #008000; font-weight: bold">return</span> result

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">midpoint_triple2</span>(g, a, b, c, d, e, f, nx, ny, nz):
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">p</span>(x, y):
        <span style="color: #008000; font-weight: bold">return</span> midpoint(<span style="color: #008000; font-weight: bold">lambda</span> z: g(x, y, z), e, f, nz)

    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">q</span>(x):
        <span style="color: #008000; font-weight: bold">return</span> midpoint(<span style="color: #008000; font-weight: bold">lambda</span> y: p(x, y), c, d, ny)

    <span style="color: #008000; font-weight: bold">return</span> midpoint(q, a, b, nx)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_midpoint_triple</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Test that a linear function is integrated exactly.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">g</span>(x, y, z):
        <span style="color: #008000; font-weight: bold">return</span> <span style="color: #666666">2*</span>x <span style="color: #666666">+</span> y <span style="color: #666666">-</span> <span style="color: #666666">4*</span>z

    a <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  b <span style="color: #666666">=</span> <span style="color: #666666">2</span>;  c <span style="color: #666666">=</span> <span style="color: #666666">2</span>;  d <span style="color: #666666">=</span> <span style="color: #666666">3</span>;  e <span style="color: #666666">=</span> <span style="color: #666666">-1</span>;  f <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span>
    x, y, z <span style="color: #666666">=</span> sympy<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;x y z&#39;</span>)
    I_expected <span style="color: #666666">=</span> sympy<span style="color: #666666">.</span>integrate(
        g(x, y, z), (x, a, b), (y, c, d), (z, e, f))
    <span style="color: #008000; font-weight: bold">for</span> nx, ny, nz <span style="color: #AA22FF; font-weight: bold">in</span> (<span style="color: #666666">3</span>, <span style="color: #666666">5</span>, <span style="color: #666666">2</span>), (<span style="color: #666666">4</span>, <span style="color: #666666">4</span>, <span style="color: #666666">4</span>), (<span style="color: #666666">5</span>, <span style="color: #666666">3</span>, <span style="color: #666666">6</span>):
        I_computed1 <span style="color: #666666">=</span> midpoint_triple1(
            g, a, b, c, d, e, f, nx, ny, nz)
        I_computed2 <span style="color: #666666">=</span> midpoint_triple2(
            g, a, b, c, d, e, f, nx, ny, nz)
        tol <span style="color: #666666">=</span> <span style="color: #666666">1E-14</span>
        <span style="color: #008000; font-weight: bold">print</span> I_expected, I_computed1, I_computed2
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(I_computed1 <span style="color: #666666">-</span> I_expected) <span style="color: #666666">&lt;</span> tol
        <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(I_computed2 <span style="color: #666666">-</span> I_expected) <span style="color: #666666">&lt;</span> tol

<span style="color: #008000; font-weight: bold">if</span> __name__ <span style="color: #666666">==</span> <span style="color: #BA2121">&#39;__main__&#39;</span>:
    test_midpoint_triple()
</pre></div>

<h2 id="sec:int:complex:domain">Monte Carlo integration for complex-shaped domains</h2>

<p>
Repeated use of one-dimensional integration rules to handle double
and triple integrals constitute a working strategy only if the
integration domain is a rectangle or box. For any other shape of
domain, completely different methods must be used. A common approach
for two- and three-dimensional domains is to divide the domain into
many small triangles or tetrahedra and use numerical integration
methods for each triangle or tetrahedron. The overall algorithm and
implementation is too complicated to be addressed in this book.
Instead, we shall employ an alternative, very simple and general method,
called Monte Carlo integration. It can be implemented in half a page of
code, but requires orders of magnitude more
function evaluations in double integrals compared to the midpoint
rule.

<p>
However, Monte Carlo integration is much more computationally
efficient than the midpoint rule when computing
higher-dimensional integrals in more than three variables over
hypercube domains.
Our ideas for double and triple integrals can easily be generalized
to handle an integral in \( m \) variables. A midpoint formula
then involves \( m \) sums. With \( n \) cells
in each coordinate direction, the formula requires \( n^m \) function
evaluations. That is, the computational work explodes as an exponential
function of the number of space dimensions.
Monte Carlo integration, on the other hand, does not suffer from this
explosion of computational work and is the preferred method for
computing higher-dimensional integrals. So, it makes sense in a
chapter on numerical integration to address Monte Carlo methods, both
for handling complex domains and for handling integrals with many variables.

<h3 id="___sec116">The Monte Carlo integration algorithm </h3>

<p>
The idea of Monte Carlo integration of \( \int_a^b f(x)dx \) is to
use the mean-value theorem from calculus, which states that the
integral \( \int_a^b f(x)dx \) equals the length of the integration
domain, here \( b-a \), times the <em>average</em> value of \( f \), \( \bar f \), in
\( [a,b] \). The average value can be computed by sampling \( f \) at
a set of <em>random</em> points inside the domain and take the mean of
the function values. In higher dimensions, an integral is estimated
as the area/volume of the domain times the average value, and again
one can evaluate the integrand at a set of random points in the domain
and compute the mean value of those evaluations.

<p>
Let us introduce some quantities to help us make the
specification of the integration algorithm more precise.
Suppose we have some two-dimensional integral

$$ \int_\Omega f(x,y)dxdx, $$

where \( \Omega \) is a two-dimensional domain defined via a help function
\( g(x,y) \):

$$ \Omega = \{ (x,y)\,|\, g(x,y) \geq 0\} $$

That is, points \( (x,y) \) for which \( g(x,y)\geq 0 \) lie inside \( \Omega \),
and points for which \( g(x,y) < \Omega \) are outside \( \Omega \).  The
boundary of the domain \( \partial\Omega \) is given by the implicit curve
\( g(x,y)=0 \). Such formulations of geometries have been very common
during the last couple of decades, and one refers to \( g \) as a
<em>level-set function</em> and the boundary \( g=0 \) as the zero-level contour
of the level-set function. For simple geometries one can easily construct
\( g \) by hand, while in more complicated industrial applications one must
resort to mathematical models for constructing \( g \).

<p>
Let \( A(\Omega) \) be the area of a domain \( \Omega \).
We can estimate the integral by this Monte Carlo integration method:

<ol>
<li> embed the geometry \( \Omega \) in a rectangular area \( R \)</li>
<li> draw a large number of <em>random</em> points \( (x,y) \) in \( R \)</li>
<li> count the fraction \( q \) of points that are inside \( \Omega \)</li>
<li> approximate \( A(\Omega)/A(R) \) by \( q \), i.e., set \( A(\Omega) = qA(R) \)</li>
<li> evaluate the mean of \( f \), \( \bar f \), at the points inside \( \Omega \)</li>
<li> estimate the integral as \( A(\Omega)\bar f \)</li>
</ol>

Note that \( A(R) \) is trivial to compute since \( R \) is a rectangle,
while \( A(\Omega) \) is unknown. However, if we assume that the fraction
of \( A(R) \) occupied by \( A(\Omega) \) is the same as the fraction of
random points inside \( \Omega \), we get a simple estimate for \( A(\Omega) \).

<p>
To get an idea of the method, consider a circular domain
\( \Omega \) embedded in a rectangle as shown below. A collection of
random points is illustrated by black dots.

<p>
<center><p><img src="figs/integral_complex_domain.png" align="bottom" width=600></p></center>

<h3 id="___sec117">Implementation </h3>

<p>
A Python function implementing \( \int_\Omega f(x,y)dxdy \) can be written
like this:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">MonteCarlo_double</span>(f, g, x0, x1, y0, y1, n):
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;</span>
<span style="color: #BA2121; font-style: italic">    Monte Carlo integration of f over a domain g&gt;=0, embedded</span>
<span style="color: #BA2121; font-style: italic">    in a rectangle [x0,x1]x[y0,y1]. n^2 is the number of</span>
<span style="color: #BA2121; font-style: italic">    random points.</span>
<span style="color: #BA2121; font-style: italic">    &quot;&quot;&quot;</span>
    <span style="color: #408080; font-style: italic"># Draw n**2 random points in the rectangle</span>
    x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(x0, x1, n)
    y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(y0, y1, n)
    <span style="color: #408080; font-style: italic"># Compute sum of f values inside the integration domain</span>
    f_mean <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    num_inside <span style="color: #666666">=</span> <span style="color: #666666">0</span>   <span style="color: #408080; font-style: italic"># number of x,y points inside domain (g&gt;=0)</span>
    <span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(x)):
        <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #008000">len</span>(y)):
            <span style="color: #008000; font-weight: bold">if</span> g(x[i], y[j]) <span style="color: #666666">&gt;=</span> <span style="color: #666666">0</span>:
                num_inside <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
                f_mean <span style="color: #666666">+=</span> f(x[i], y[j])
    f_mean <span style="color: #666666">=</span> f_mean<span style="color: #666666">/</span><span style="color: #008000">float</span>(num_inside)
    area <span style="color: #666666">=</span> num_inside<span style="color: #666666">/</span><span style="color: #008000">float</span>(n<span style="color: #666666">**2</span>)<span style="color: #666666">*</span>(x1 <span style="color: #666666">-</span> x0)<span style="color: #666666">*</span>(y1 <span style="color: #666666">-</span> y0)
    <span style="color: #008000; font-weight: bold">return</span> area<span style="color: #666666">*</span>f_mean
</pre></div>
<p>
(See the file
<a href="https://github.com/hplgit/prog4comp/tree/master/src/py/MC_double.py" target="_self"><tt>MC_double.py</tt></a>.)

<h3 id="___sec118">Verification </h3>

<p>
A simple test case is to check the area of a rectangle \( [0,2]\times[3,4.5] \)
embedded in a rectangle \( [0,3]\times [2,5] \). The right answer is 3,
but Monte Carlo integration is, unfortunately, never exact so it is
impossible to predict the output of the algorithm. All we know is that
the estimated integral should approach 3 as the number of random points
goes to infinity. Also, for a fixed number of points, we can
run the algorithm several times and get different numbers that fluctuate
around the exact value, since different sample points are used in different
calls to the Monte Carlo integration algorithm.

<p>
The area of the rectangle can be computed by the integral \( \int_0^2\int_3^{4.5}
dydx \), so in this case we identify
\( f(x,y)=1 \), and the \( g \) function can be specified as (e.g.)
1 if \( (x,y) \) is inside \( [0,2]\times[3,4.5] \) and \( -1 \) otherwise.
Here is an example on how we can utilize the <code>MonteCarlo_double</code>
function to compute the area for different number of samples:

<p>

<!-- code=python (!bc pyshell) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">MC_double</span> <span style="color: #008000; font-weight: bold">import</span> MonteCarlo_double
<span style="color: #666666">&gt;&gt;&gt;</span> <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">g</span>(x, y):
<span style="color: #666666">...</span>     <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> x <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #666666">3</span> <span style="color: #666666">&lt;=</span> y <span style="color: #666666">&lt;=</span> <span style="color: #666666">4.5</span>) <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">-1</span>)
<span style="color: #666666">...</span>
<span style="color: #666666">&gt;&gt;&gt;</span> MonteCarlo_double(<span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">1</span>, g, <span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">2</span>, <span style="color: #666666">5</span>, <span style="color: #666666">100</span>)
<span style="color: #666666">2.9484</span>
<span style="color: #666666">&gt;&gt;&gt;</span> MonteCarlo_double(<span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">1</span>, g, <span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">2</span>, <span style="color: #666666">5</span>, <span style="color: #666666">1000</span>)
<span style="color: #666666">2.947032</span>
<span style="color: #666666">&gt;&gt;&gt;</span> MonteCarlo_double(<span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">1</span>, g, <span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">2</span>, <span style="color: #666666">5</span>, <span style="color: #666666">1000</span>)
<span style="color: #666666">3.0234600000000005</span>
<span style="color: #666666">&gt;&gt;&gt;</span> MonteCarlo_double(<span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">1</span>, g, <span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">2</span>, <span style="color: #666666">5</span>, <span style="color: #666666">2000</span>)
<span style="color: #666666">2.9984580000000003</span>
<span style="color: #666666">&gt;&gt;&gt;</span> MonteCarlo_double(<span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">1</span>, g, <span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">2</span>, <span style="color: #666666">5</span>, <span style="color: #666666">2000</span>)
<span style="color: #666666">3.1903469999999996</span>
<span style="color: #666666">&gt;&gt;&gt;</span> MonteCarlo_double(<span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">1</span>, g, <span style="color: #666666">0</span>, <span style="color: #666666">3</span>, <span style="color: #666666">2</span>, <span style="color: #666666">5</span>, <span style="color: #666666">5000</span>)
<span style="color: #666666">2.986515</span>
</pre></div>
<p>
We see that the values fluctuate around 3, a fact that supports
a correct implementation, but in principle, bugs could be hidden
behind the inaccurate answers.

<p>
It is mathematically known that the standard deviation of the Monte Carlo
estimate of an integral converges as \( n^{-1/2} \), where \( n \) is the number
of samples. This kind of convergence rate estimate could be used to
verify the implementation, but this topic is beyond the scope of this book.

<h3 id="___sec119">Test function for function with random numbers </h3>

<p>
To make a test function, we need a unit test that has identical
behavior each time we run the test. This seems difficult when random
numbers are involved, because these numbers are different every time
we run the algorithm, and each run hence produces a (slightly)
different result.  A standard way to test algorithms involving random
numbers is to <em>fix the seed</em> of the random number generator. Then the
sequence of numbers is the same every time we run the algorithm.
Assuming that the <code>MonteCarlo_double</code> function works, we fix the seed,
observe a certain result, and take this result as the correct
result. Provided the test function always uses this seed, we should
get exactly this result every time the <code>MonteCarlo_double</code> function is
called. Our test function can then be written as shown below.

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_MonteCarlo_double_rectangle_area</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Check the area of a rectangle.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">g</span>(x, y):
        <span style="color: #008000; font-weight: bold">return</span> (<span style="color: #666666">1</span> <span style="color: #008000; font-weight: bold">if</span> (<span style="color: #666666">0</span> <span style="color: #666666">&lt;=</span> x <span style="color: #666666">&lt;=</span> <span style="color: #666666">2</span> <span style="color: #AA22FF; font-weight: bold">and</span> <span style="color: #666666">3</span> <span style="color: #666666">&lt;=</span> y <span style="color: #666666">&lt;=</span> <span style="color: #666666">4.5</span>) <span style="color: #008000; font-weight: bold">else</span> <span style="color: #666666">-1</span>)

    x0 <span style="color: #666666">=</span> <span style="color: #666666">0</span>;  x1 <span style="color: #666666">=</span> <span style="color: #666666">3</span>;  y0 <span style="color: #666666">=</span> <span style="color: #666666">2</span>;  y1 <span style="color: #666666">=</span> <span style="color: #666666">5</span>  <span style="color: #408080; font-style: italic"># embedded rectangle</span>
    n <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">8</span>)      <span style="color: #408080; font-style: italic"># must fix the seed!</span>
    I_expected <span style="color: #666666">=</span> <span style="color: #666666">3.121092</span>  <span style="color: #408080; font-style: italic"># computed with this seed</span>
    I_computed <span style="color: #666666">=</span> MonteCarlo_double(
        <span style="color: #008000; font-weight: bold">lambda</span> x, y: <span style="color: #666666">1</span>, g, x0, x1, y0, y1, n)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(I_expected <span style="color: #666666">-</span> I_computed) <span style="color: #666666">&lt;</span> <span style="color: #666666">1E-14</span>
</pre></div>
<p>
(See the file <a href="https://github.com/hplgit/prog4comp/tree/master/src/py/MC_double.py" target="_self"><tt>MC_double.py</tt></a>.)

<h3 id="___sec120">Integral over a circle </h3>

<p>
The test above involves a trivial function \( f(x,y)=1 \). We should also
test a non-constant \( f \) function and a more complicated domain. Let
\( \Omega \) be a circle at the origin with radius 2, and let \( f=\sqrt{x^2
+ y^2} \).  This choice makes it possible to compute an exact result: in
polar coordinates, \( \int_\Omega f(x,y)dxdy \) simplifies to
\( 2\pi\int_0^2 r^2dr = 16\pi/3 \).  We must be prepared for quite crude
approximations that fluctuate around this exact result. As in the test
case above, we experience better results with larger number of points.
When we have such evidence for a working implementation, we can turn
the test into a proper test function. Here is an example:

<p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_MonteCarlo_double_circle_r</span>():
    <span style="color: #BA2121; font-style: italic">&quot;&quot;&quot;Check the integral of r over a circle with radius 2.&quot;&quot;&quot;</span>
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">g</span>(x, y):
        xc, yc <span style="color: #666666">=</span> <span style="color: #666666">0</span>, <span style="color: #666666">0</span>  <span style="color: #408080; font-style: italic"># center</span>
        R <span style="color: #666666">=</span> <span style="color: #666666">2</span>          <span style="color: #408080; font-style: italic"># radius</span>
        <span style="color: #008000; font-weight: bold">return</span>  R<span style="color: #666666">**2</span> <span style="color: #666666">-</span> ((x<span style="color: #666666">-</span>xc)<span style="color: #666666">**2</span> <span style="color: #666666">+</span> (y<span style="color: #666666">-</span>yc)<span style="color: #666666">**2</span>)

    <span style="color: #408080; font-style: italic"># Exact: integral of r*r*dr over circle with radius R becomes</span>
    <span style="color: #408080; font-style: italic"># 2*pi*1/3*R**3</span>
    <span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">sympy</span>
    r <span style="color: #666666">=</span> sympy<span style="color: #666666">.</span>symbols(<span style="color: #BA2121">&#39;r&#39;</span>)
    I_exact <span style="color: #666666">=</span> sympy<span style="color: #666666">.</span>integrate(<span style="color: #666666">2*</span>sympy<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>r<span style="color: #666666">*</span>r, (r, <span style="color: #666666">0</span>, <span style="color: #666666">2</span>))
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;Exact integral:&#39;</span>, I_exact<span style="color: #666666">.</span>evalf()
    x0 <span style="color: #666666">=</span> <span style="color: #666666">-2</span>;  x1 <span style="color: #666666">=</span> <span style="color: #666666">2</span>;  y0 <span style="color: #666666">=</span> <span style="color: #666666">-2</span>;  y1 <span style="color: #666666">=</span> <span style="color: #666666">2</span>
    n <span style="color: #666666">=</span> <span style="color: #666666">1000</span>
    np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>seed(<span style="color: #666666">6</span>)
    I_expected <span style="color: #666666">=</span> <span style="color: #666666">16.7970837117376384</span>  <span style="color: #408080; font-style: italic"># Computed with this seed</span>
    I_computed <span style="color: #666666">=</span> MonteCarlo_double(
        <span style="color: #008000; font-weight: bold">lambda</span> x, y: np<span style="color: #666666">.</span>sqrt(x<span style="color: #666666">**2</span> <span style="color: #666666">+</span> y<span style="color: #666666">**2</span>),
        g, x0, x1, y0, y1, n)
    <span style="color: #008000; font-weight: bold">print</span> <span style="color: #BA2121">&#39;MC approximation </span><span style="color: #BB6688; font-weight: bold">%d</span><span style="color: #BA2121"> samples): </span><span style="color: #BB6688; font-weight: bold">%.16f</span><span style="color: #BA2121">&#39;</span> <span style="color: #666666">%</span> (n<span style="color: #666666">**2</span>, I_computed)
    <span style="color: #008000; font-weight: bold">assert</span> <span style="color: #008000">abs</span>(I_expected <span style="color: #666666">-</span> I_computed) <span style="color: #666666">&lt;</span> <span style="color: #666666">1E-15</span>
</pre></div>
<p>
(See the file <a href="https://github.com/hplgit/prog4comp/tree/master/src/py/MC_double.py" target="_self"><tt>MC_double.py</tt></a>.)

<p>
<!-- Adaptive integration as a project: use a crude discretization, -->
<!-- refine each part uniformly until eps diff, visualize the result -->
<!-- Differentiation: mesh function concept -->
<!-- Symbolic integration, conversion to py func (matlab?) -->

<p>
<p>
<!-- navigation buttons at the bottom of the page -->
<ul class="pager">
  <li class="previous">
    <a href="._p4c-bootstrap-Python016.html">&larr; Prev</a>
  </li>
  <li class="next">
    <a href="._p4c-bootstrap-Python018.html">Next &rarr;</a>
  </li>
</ul>
<!-- ------------------- end of main content --------------- -->

</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>

<!-- Bootstrap footer
<footer>
<a href="http://..."><img width="250" align=right src="http://..."></a>
</footer>
-->


</body>
</html>
    

