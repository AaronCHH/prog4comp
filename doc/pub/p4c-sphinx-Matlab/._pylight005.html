
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Solving ordinary differential equations</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script src="http://sagecell.sagemath.org/static/jquery.min.js"></script>
        <script src="http://sagecell.sagemath.org/static/embedded_sagecell.js"></script>

        <script>sagecell.makeSagecell({inputLocation: ".sage"});</script>

        <style type="text/css">
                .sagecell .CodeMirror-scroll {
                        overflow-y: hidden;
                        overflow-x: auto;
                }
                .sagecell .CodeMirror {
                        height: auto;
                }
        </style>

    
    <link rel="top" title="Programming for Computations" href="index.html" />
    <link rel="next" title="Solving partial differential equations" href="._pylight006.html" />
    <link rel="prev" title="Computing integrals" href="._pylight004.html" />

   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  
       <style type="text/css">
         div.admonition {
           background-color: whiteSmoke;
           border: 1px solid #bababa;
         }
       </style>
      </head>
    
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="._pylight006.html" title="Solving partial differential equations"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="._pylight004.html" title="Computing integrals"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Programming for Computations</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="solving-ordinary-differential-equations">
<h1>Solving ordinary differential equations<a class="headerlink" href="#solving-ordinary-differential-equations" title="Permalink to this headline">¶</a></h1>
<div class="figure">
<a class="reference internal image-reference" href="_images/FE_comic_strip.png"><img alt="_images/FE_comic_strip.png" src="_images/FE_comic_strip.png" style="width: 800px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>Differential equations constitute one of the most powerful mathematical
tools to understand and predict the behavior of dynamical systems in
nature, engineering, and society. A dynamical system is some system with
some state, usually expressed by a set of variables, that evolves in time.
For example, an oscillating pendulum, the spreading of a disease,
and the weather are examples of dynamical systems.
We can use basic laws of physics, or plain intuition, to express mathematical
rules that govern the evolution of the system in time.
These rules take the form of
<em>differential equations</em>. You are probably well experienced with
equations, at least equations like <span class="math">\(ax+b=0\)</span> or <span class="math">\(ax^2 + bx + c=0\)</span>.
Such equations are known as <em>algebraic equations</em>, and the unknown
is a number. The unknown in a differential equation is a function,
and a differential equation will almost always involve this function
and one or more derivatives of the function.
For example, <span class="math">\(f'(x)=f(x)\)</span> is a simple
differential equation (asking if there is any function <span class="math">\(f\)</span> such that
it equals its derivative - you might remember that <span class="math">\(e^x\)</span> is a
candidate).</p>
<p>The present chapter starts with explaining how easy it is to solve
both single (scalar) first-order ordinary differential equations and
systems of first-order differential equations by the Forward Euler
method. We demonstrate all the mathematical and programming details
through two specific applications: population growth and spreading of
diseases.</p>
<p>Then we turn to a physical application: oscillating mechanical
systems, which arise in a wide range of engineering situations. The
differential equation is now of second order, and the Forward Euler
method does not perform well. This observation motivates the need for
other solution methods, and we derive the Euler-Cromer scheme <a class="footnote-reference" href="#scheme" id="id1">[1]</a>, the
2nd- and 4th-order Runge-Kutta schemes, as well as a finite difference
scheme (the latter to handle the second-order differential equation
directly without reformulating it as a first-order system). The
presentation starts with undamped free oscillations and then treats
general oscillatory systems with possibly nonlinear damping, nonlinear
spring forces, and arbitrary external excitation.  Besides developing
programs from scratch, we also demonstrate how to access ready-made
implementations of more advanced differential equation solvers in
Matlab.</p>
<span class="target" id="index-0"></span><table class="docutils footnote" frame="void" id="scheme" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The term <em>scheme</em> is used as synonym for method or
computational recipe, especially in the context of numerical
methods for differential equations.</td></tr>
</tbody>
</table>
<p>As we progress with more advanced methods, we develop more
sophisticated and reusable programs, and in particular, we incorporate
good testing strategies so that we bring solid evidence to correct
computations. Consequently, the beginning with population growth and
disease modeling examples have a very gentle learning curve, while
that curve gets significantly steeper towards the end of the treatment
of differential equations for oscillatory systems.</p>
<div class="section" id="population-growth">
<span id="sec-de-pg"></span><h2>Population growth<a class="headerlink" href="#population-growth" title="Permalink to this headline">¶</a></h2>
<p>Our first taste of differential equations regards modeling of the
growth of some population, such as a cell culture, an animal
population, or a human population. The ideas even extend trivially to
growth of money in a bank. Let <span class="math">\(N(t)\)</span> be the number of individuals in
the population at time <span class="math">\(t\)</span>. How can we predict how <span class="math">\(N(t)\)</span> evolves in
time? Below we shall derive a differential equation whose solution is
<span class="math">\(N(t)\)</span>. The equation reads</p>
<div class="math" id="equation-sec:de:eq:N">
<span id="eq-sec-de-eq-n"></span><span class="eqno">(1)</span>\[     N'(t) = rN(t),\]</div>
<p>where <span class="math">\(r\)</span> is a number. Note that although <span class="math">\(N\)</span> is an integer in real life,
we model <span class="math">\(N\)</span> as a real-valued function. We are forced to do this because
the solution of differential equations are (normally continuous) real-valued
functions. An integer-valued <span class="math">\(N(t)\)</span> in the model would lead to a lot of
mathematical difficulties.</p>
<p>With a bit of guessing, you may realize that <span class="math">\(N(t)=Ce^{rt}\)</span>, where <span class="math">\(C\)</span>
is any number. To make this solution unique, we need to fix <span class="math">\(C\)</span>, done
by prescribing the value of <span class="math">\(N\)</span> at some time, usually <span class="math">\(t=0\)</span>.
Say <span class="math">\(N(0)\)</span> is given as <span class="math">\(N_0\)</span>. Then <span class="math">\(N(t)=N_0e^{rt}\)</span>.</p>
<p>In general, a differential equation model consists of a <em>differential
equation</em>, such as <a href="#equation-sec:de:eq:N">(1)</a> <em>and</em> an <em>initial condition</em>, such
as <span class="math">\(N(0)=N_0\)</span>. With a known initial condition, the differential equation
can be solved for the unknown function and the solution is unique.</p>
<p>It is, of course, very seldom that we can find the solution of a
differential equation as easy as in this example. Normally, one has to
apply certain mathematical methods, but these can only handle some of
the simplest differential equations. However, we can easily deal with
almost any differential equation by applying numerical methods and a
bit of programming.  This is exactly the topic of the present chapter.</p>
<div class="section" id="derivation-of-the-model">
<span id="sec-de-pg-model"></span><h3>Derivation of the model<a class="headerlink" href="#derivation-of-the-model" title="Permalink to this headline">¶</a></h3>
<p>It can be instructive to show how an equation like <a href="#equation-sec:de:eq:N">(1)</a>
arises. Consider some population of (say) an animal specie and let
<span class="math">\(N(t)\)</span> be the number of individuals in a certain spatial region, e.g. an island.
We are not concerned with the spatial distribution of the animals, just
the number of them in some spatial area where there is no exchange
of individuals with other spatial areas.
During a time interval <span class="math">\(\Delta t\)</span>, some animals will
die and some new will be born. The number of deaths and births are
expected to be proportional to <span class="math">\(N\)</span>. For example, if there are twice
as many individuals, we expect them to get twice as many newborns.
In a time interval <span class="math">\(\Delta t\)</span>, the net growth of the population
will be</p>
<div class="math">
\[N(t+\Delta t) - N(t) = \hat b N(t) - \hat d N(t),\]</div>
<p>where <span class="math">\(\hat bN(t)\)</span> are the number of newborns and <span class="math">\(\hat d N(t)\)</span>
the number of deaths. If we double <span class="math">\(\Delta t\)</span>, we expect the proportionality
constants <span class="math">\(\hat b\)</span> and <span class="math">\(\hat d\)</span> to double too, so it makes sense to
think of <span class="math">\(\hat b\)</span> and <span class="math">\(\hat d\)</span> as proportional to <span class="math">\(\Delta t\)</span> and
&#8220;factor out&#8221; <span class="math">\(\Delta t\)</span>. That is, we introduce <span class="math">\(b=\hat b/\Delta t\)</span> and
<span class="math">\(d=\hat d/\Delta t\)</span> to be proportionality constants for newborns and
deaths independent of <span class="math">\(\Delta t\)</span>. Also, we introduce <span class="math">\(r=b-d\)</span>, which
is the net rate of growth of the population per time unit.
Our model then becomes</p>
<div class="math" id="equation-sec:de:eq:N:discrete">
<span id="eq-sec-de-eq-n-discrete"></span><span class="eqno">(2)</span>\[      N(t+\Delta t) - N(t) = \Delta t\, r N(t)\thinspace .\]</div>
<p>Equation <a href="#equation-sec:de:eq:N:discrete">(2)</a> is actually a computational model.
Given <span class="math">\(N(t)\)</span>, we can advance the population size by</p>
<div class="math">
\[N(t+\Delta t) = N(t) + \Delta t\, rN(t)\thinspace .\]</div>
<p>This is called a <em>difference equation</em>.
If we know <span class="math">\(N(t)\)</span> for some <span class="math">\(t\)</span>, e.g., <span class="math">\(N(0)=N_0\)</span>, we can compute</p>
<div class="math">
\[\begin{split}N(\Delta t) &amp;= N_0 + \Delta t\, rN_0,\\
N(2\Delta t) &amp;= N(\Delta t) + \Delta t\, rN(\Delta t),\\
N(3\Delta t) &amp;= N(2\Delta t) + \Delta t\, rN(2\Delta t),\\
&amp; \vdots\\
N((k+1)\Delta t) &amp;= N(k\Delta t) + \Delta t\, rN(k\Delta t),\end{split}\]</div>
<p>where <span class="math">\(k\)</span> is some arbitrary integer. A computer program can easily
compute <span class="math">\(N((k+1)\Delta t)\)</span> for us with the aid of a little loop.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Observe that the computational formula cannot be started unless we have an
initial condition!</p>
<p class="last">The solution of <span class="math">\(N'=rN\)</span> is <span class="math">\(N=Ce^{rt}\)</span>
for any constant <span class="math">\(C\)</span>, and the initial condition is needed to fix <span class="math">\(C\)</span> so
the solution becomes unique. However,
from a mathematical point of view, knowing <span class="math">\(N(t)\)</span> at any point <span class="math">\(t\)</span> is
sufficient as initial condition. Numerically, we more literally need an
initial condition: we need to know a starting value at the left
end of the interval in order to get the computational formula going.</p>
</div>
<p>In fact, we do not need a computer since we see a repetitive pattern
when doing hand calculations, which leads us to a mathematical
formula for <span class="math">\(N((k+1)\Delta t)\)</span>, :</p>
<div class="math">
\[\begin{split}N((k+1)\Delta t) &amp;= N(k\Delta t) + \Delta t\, rN(k\Delta t) = N(k\Delta t)(1+\Delta t\, r)\\
&amp;= N((k-1)\Delta t)(1+\Delta t\,r)^2\\
&amp;\vdots\\
&amp;= N_0(1+\Delta t\,r)^{k+1}\thinspace .\end{split}\]</div>
<p>Rather than using <a href="#equation-sec:de:eq:N:discrete">(2)</a> as a computational model
directly, there is a strong tradition for deriving a differential
equation from this difference equation. The idea is to consider a
very small time interval <span class="math">\(\Delta t\)</span> and look at the instantaneous
growth as this time interval is shrunk to an infinitesimal small
size. In mathematical terms, it means that we let
<span class="math">\(\Delta t\rightarrow 0\)</span>. As <a href="#equation-sec:de:eq:N:discrete">(2)</a>
stands, letting <span class="math">\(\Delta t\rightarrow 0\)</span> will just produce an equation
<span class="math">\(0=0\)</span>, so we have to divide by
<span class="math">\(\Delta t\)</span> and then take the limit:</p>
<div class="math">
\[\lim_{\Delta t\rightarrow 0}\frac{N(t+\Delta t)-N(t)}{\Delta t} = rN(t)\thinspace .\]</div>
<p>The term on the left-hand side is actually the definition of the
derivative <span class="math">\(N'(t)\)</span>, so we have</p>
<div class="math">
\[N'(t) = rN(t),\]</div>
<p>which is the corresponding differential equation.</p>
<p>There is nothing in our derivation that forces the parameter <span class="math">\(r\)</span> to be
constant - it can change with time due to, e.g., seasonal changes or
more permanent environmental changes.</p>
<div class="admonition-detour-exact-mathematical-solution admonition">
<p class="first admonition-title">Detour: Exact mathematical solution</p>
<p>If you have taken a course on mathematical solution methods for
differential equations, you may want to recap how an equation like
<span class="math">\(N'=rN\)</span> or <span class="math">\(N'=r(t)N\)</span> is solved. The <em>method of separation of
variables</em> is the most convenient solution strategy in this case:</p>
<div class="math">
\[\begin{split}N' &amp;=rN\\
\frac{dN}{dt} &amp;= rN\\
\frac{dN}{N} &amp;= rdt\\
\int_{N_0}^N \frac{dN}{N} &amp;= \int_0^t rdt\\
\ln N - \ln N_0 &amp;= \int_0^t r(t)dt\\
N &amp;= N_0\exp{(\int_0^t r(t)dt)},\end{split}\]</div>
<p>which for constant <span class="math">\(r\)</span> results in <span class="math">\(N=N_0e^{rt}\)</span>.</p>
<p class="last">As will be described later, <span class="math">\(r\)</span> must in more realistic models depend on <span class="math">\(N\)</span>.
The method of separation of variables then requires to integrate
<span class="math">\(\int_{N_0}^{N} N/r(N)dN\)</span>, which quickly becomes non-trivial for many choices
of <span class="math">\(r(N)\)</span>. The only generally applicable solution approach is therefore
a numerical method.</p>
</div>
</div>
<div class="section" id="numerical-solution-1">
<span id="sec-de-pg-numerics"></span><h3>Numerical solution  (1)<a class="headerlink" href="#numerical-solution-1" title="Permalink to this headline">¶</a></h3>
<p id="index-1">There is a jungle of numerical methods for problems like
<a href="#equation-sec:de:eq:N:discrete">(2)</a>, and in general any equation of the form
<span class="math">\(u'=f(u,t)\)</span>, where <span class="math">\(u(t)\)</span> is the unknown function in the problem,
and <span class="math">\(f\)</span> is some known formula of <span class="math">\(u\)</span> and optionally
<span class="math">\(t\)</span>. For example, <span class="math">\(f(u,t)=ru\)</span> in <a href="#equation-sec:de:eq:N:discrete">(2)</a>.
We will first present a simple <em>finite difference method</em> solving
<span class="math">\(u'=f(u,t)\)</span>. The idea is four-fold:</p>
<ol class="arabic simple">
<li>Introduce a mesh in time with <span class="math">\(N_t+1\)</span> points <span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>.
We seek the unknown <span class="math">\(u\)</span> at
the mesh points <span class="math">\(t_n\)</span>, and introduce <span class="math">\(u^n\)</span> as the numerical approximation
to <span class="math">\(u(t_n)\)</span>, see Figure <a class="reference internal" href="#sec-de-fig-mesh"><span>Mesh in time with corresponding discrete values (unknowns)</span></a>.</li>
<li>Assume that the differential equation is valid at the mesh points only.</li>
<li>Approximate derivatives by finite differences, see Figure <a class="reference internal" href="#sec-de-fig-fe"><span>Illustration of a forward difference approximation to the derivative</span></a>.</li>
<li>Formulate a computational algorithm that can compute a new
value <span class="math">\(u^n\)</span> based on previously computed values <span class="math">\(u^i\)</span>, <span class="math">\(i&lt;n\)</span>.</li>
</ol>
<div class="figure" id="id4">
<span id="sec-de-fig-mesh"></span><a class="reference internal image-reference" href="_images/fdm_u_ue.png"><img alt="_images/fdm_u_ue.png" src="_images/fdm_u_ue.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Mesh in time with corresponding discrete values (unknowns)</em></span></p>
</div>
<div class="figure" id="id5">
<span id="sec-de-fig-fe"></span><a class="reference internal image-reference" href="_images/fd_forward.png"><img alt="_images/fd_forward.png" src="_images/fd_forward.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of a forward difference approximation to the derivative</em></span></p>
</div>
<p>An example will illustrate the steps. First, we introduce the mesh, and
very often the mesh is uniform, meaning that the spacing between
points <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span> is constant. This property implies that</p>
<div class="math">
\[t_n = n\Delta t,\quad n=0,1,\ldots, N_t\thinspace .\]</div>
<p>Second, the differential equation is supposed to hold at the mesh
points only. Note that this is an approximation, because the
differential equation is originally valid at all real values of <span class="math">\(t\)</span>.
We can express this property mathematically as</p>
<div class="math">
\[u'(t_n)=f(u^n,t_n),\quad  n=0,1,\ldots,N_t\thinspace .\]</div>
<p>For example, with our model equation <span class="math">\(u'=ru\)</span>, we have the special case</p>
<div class="math">
\[u'(t_n)=ru^n,\quad  n=0,1,\ldots,N_t,\]</div>
<p>or</p>
<div class="math">
\[u'(t_n)=r(t_n)u^n,\quad  n=0,1,\ldots,N_t,\]</div>
<p>if <span class="math">\(r\)</span> depends explicitly on <span class="math">\(t\)</span>.</p>
<p id="index-2">Third, derivatives are to be replaced by finite differences. To this end,
we need to know specific formulas for how derivatives can be
approximated by finite differences. One simple possibility is to use
the definition of the derivative from any calculus book,</p>
<div class="math">
\[u'(t) = \lim_{\Delta t\rightarrow 0}\frac{u(t+\Delta t)-u(t)}{\Delta t}\thinspace .\]</div>
<p>At an arbitrary mesh point <span class="math">\(t_n\)</span> this definition can be written as</p>
<div class="math">
\[u'(t_n) = \lim_{\Delta t\rightarrow 0}\frac{u^{n+1}-u^n}{\Delta t}\thinspace .\]</div>
<p>Instead of going to the limit <span class="math">\(\Delta t\rightarrow 0\)</span> we can use
a small <span class="math">\(\Delta t\)</span>, which yields a computable approximation to <span class="math">\(u'(t_n)\)</span>:</p>
<div class="math">
\[u'(t_n) \approx \frac{u^{n+1}-u^n}{\Delta t}\thinspace .\]</div>
<p>This is known as a <em>forward difference</em> since we go forward in time
(<span class="math">\(u^{n+1}\)</span>) to collect information in <span class="math">\(u\)</span> to estimate the derivative.
Figure <a class="reference internal" href="#sec-de-fig-fe"><span>Illustration of a forward difference approximation to the derivative</span></a> illustrates the idea. The accuracy of
the forward difference is proportional to <span class="math">\(\Delta t\)</span>, usually written
as <span class="math">\({\mathcal{O}(\Delta t)}\)</span>.</p>
<p>We can now plug in the forward difference in our differential equation
sampled at the arbitrary mesh point <span class="math">\(t_n\)</span>:</p>
<div class="math" id="equation-sec:de:FE">
<span id="eq-sec-de-fe"></span><span class="eqno">(3)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = f(u^n,t_n),\]</div>
<p>or with <span class="math">\(f(u,t)=ru\)</span> in our special model problem for population growth,</p>
<div class="math" id="equation-sec:de:FE:pop:growth">
<span id="eq-sec-de-fe-pop-growth"></span><span class="eqno">(4)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = ru^n\thinspace .\]</div>
<p>If <span class="math">\(r\)</span> depends on time, we insert <span class="math">\(r(t_n)=r^n\)</span> for <span class="math">\(r\)</span> in this latter
equation.</p>
<p>The fourth step is to derive a computational algorithm. Looking at
<a href="#equation-sec:de:FE">(3)</a>, we realize that if <span class="math">\(u^n\)</span> should be known, we can
easily solve with respect to <span class="math">\(u^{n+1}\)</span> to get a formula for <span class="math">\(u\)</span> at
the next time level <span class="math">\(t_{n+1}\)</span>:</p>
<div class="math" id="equation-sec:de:FE2">
<span id="eq-sec-de-fe2"></span><span class="eqno">(5)</span>\[     u^{n+1}= u^n + \Delta t f(u^n,t_n)\thinspace .\]</div>
<p>Provided we have a known starting value, <span class="math">\(u^0=U_0\)</span>, we can use
<a href="#equation-sec:de:FE2">(5)</a> to advance the solution by first computing <span class="math">\(u^1\)</span>
from <span class="math">\(u^0\)</span>, then <span class="math">\(u^2\)</span> from <span class="math">\(u^1\)</span>, <span class="math">\(u^3\)</span> from <span class="math">\(u^2\)</span>, and so forth.</p>
<p id="index-3">Such an algorithm is called a <em>numerical scheme</em> for the differential
equation and often written compactly as</p>
<div class="math" id="equation-sec:de:FE3">
<span id="eq-sec-de-fe3"></span><span class="eqno">(6)</span>\[     u^{n+1}= u^n + \Delta t f(u^n,t_n),\quad u^0=U_0,\quad n=0,1,\ldots,N_t-1\thinspace .\]</div>
<p>This scheme is known as the <em>Forward Euler scheme</em>, also called
<em>Euler&#8217;s method</em>.</p>
<p>In our special population growth model, we have</p>
<div class="math" id="equation-sec:de:FE3:pop:growth">
<span id="eq-sec-de-fe3-pop-growth"></span><span class="eqno">(7)</span>\[     u^{n+1}= u^n + \Delta t\, ru^n,\quad u^0=U_0,\quad n=0,1,\ldots,N_t-1\thinspace .\]</div>
<p>We may also write this model using the problem-specific symbol <span class="math">\(N\)</span> instead
of the generic <span class="math">\(u\)</span> function:</p>
<div class="math" id="equation-sec:de:FE3:pop:growth:N">
<span id="eq-sec-de-fe3-pop-growth-n"></span><span class="eqno">(8)</span>\[     N^{n+1}= N^n + \Delta t\, rN^n,\quad N^0=N_0,\quad n=0,1,\ldots,N_t-1\thinspace .\]</div>
<p>The observant reader will realize that <a href="#equation-sec:de:FE3:pop:growth:N">(8)</a> is
nothing but the computational model <a href="#equation-sec:de:eq:N:discrete">(2)</a>
arising directly in the model derivation. The formula
<a href="#equation-sec:de:FE3:pop:growth:N">(8)</a> arises, however, from a detour via
a differential equation and a numerical method for the differential
equation. This looks rather unnecessary! The reason why we bother
to derive the differential equation model and then discretize it by
a numerical method is simply that the discretization can be done
in many ways, and we can create (much) more accurate and more
computationally efficient methods than <a href="#equation-sec:de:FE3:pop:growth:N">(8)</a>
or <a href="#equation-sec:de:FE3">(6)</a>. This can be useful in many problems!
Nevertheless, the Forward Euler scheme is intuitive and widely
applicable, at least when <span class="math">\(\Delta t\)</span> is chosen to be small.</p>
<div class="admonition-the-numerical-solution-between-the-mesh-points admonition">
<p class="first admonition-title">The numerical solution between the mesh points</p>
<p class="last">Our numerical method computes the unknown function <span class="math">\(u\)</span>
at discrete mesh points <span class="math">\(t_1,t_2,\ldots,t_{N_t}\)</span>. What if we
want to evaluate the numerical solution between the mesh points?
The most natural choice is to <em>assume</em> a linear variation between
the mesh points, see Figure <a class="reference internal" href="#sec-de-fig-ui"><span>The numerical solution at points can be extended by linear segments between the mesh points</span></a>. This is compatible
with the fact that when we plot
the array <span class="math">\(u^0,u^1,\ldots\)</span> versus <span class="math">\(t_0,t_1,\ldots\)</span>, a straight
line is drawn between the discrete points.</p>
</div>
<div class="figure" id="id6">
<span id="sec-de-fig-ui"></span><a class="reference internal image-reference" href="_images/fdm_u_uei.png"><img alt="_images/fdm_u_uei.png" src="_images/fdm_u_uei.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>The numerical solution at points can be extended by linear segments between the mesh points</em></span></p>
</div>
</div>
<div class="section" id="programming-the-forward-euler-scheme-the-special-case">
<span id="sec-de-pg-prog1"></span><h3>Programming the Forward Euler scheme; the special case<a class="headerlink" href="#programming-the-forward-euler-scheme-the-special-case" title="Permalink to this headline">¶</a></h3>
<p>Let us compute <a href="#equation-sec:de:FE3:pop:growth:N">(8)</a> in a program.
The input variables are <span class="math">\(N_0\)</span>, <span class="math">\(\Delta t\)</span>, <span class="math">\(r\)</span>, and <span class="math">\(N_t\)</span>.
Note that we need to compute <span class="math">\(N_t+1\)</span> new values <span class="math">\(N^1,\ldots,N^{N_t+1}\)</span>.
A total of <span class="math">\(N_t+2\)</span> values are needed in an array representation of <span class="math">\(N^n\)</span>,
<span class="math">\(n=0,\ldots,N_t+1\)</span>.</p>
<p>Our first version of this program is as simple as possible:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="n">N_0</span> <span class="p">=</span> <span class="n">input</span><span class="p">(</span><span class="s">&#39;Give initial population size N_0: &#39;</span><span class="p">);</span>
<span class="n">r</span>   <span class="p">=</span> <span class="n">input</span><span class="p">(</span><span class="s">&#39;Give net growth rate r: &#39;</span><span class="p">);</span>
<span class="n">dt</span>  <span class="p">=</span> <span class="n">input</span><span class="p">(</span><span class="s">&#39;Give time step size: &#39;</span><span class="p">);</span>
<span class="n">N_t</span> <span class="p">=</span> <span class="n">input</span><span class="p">(</span><span class="s">&#39;Give number of steps: &#39;</span><span class="p">);</span>
<span class="n">t</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">2</span><span class="p">);</span>
<span class="n">N</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="n">N</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">N_0</span><span class="p">;</span>
<span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N_t</span>
    <span class="n">N</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">N</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">N</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="k">end</span>

<span class="k">if</span> <span class="n">N_t</span> <span class="o">&lt;</span> <span class="mi">70</span>
    <span class="n">numerical_sol</span> <span class="p">=</span> <span class="s">&#39;bo&#39;</span><span class="p">;</span>
<span class="k">else</span>
    <span class="n">numerical_sol</span> <span class="p">=</span> <span class="s">&#39;b-&#39;</span><span class="p">;</span>
<span class="k">end</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">numerical_sol</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">N_0</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="n">r</span><span class="o">.*</span><span class="n">t</span><span class="p">),</span> <span class="s">&#39;r-&#39;</span><span class="p">);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span> <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;N(t)&#39;</span><span class="p">);</span>
<span class="n">legend</span><span class="p">(</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">,</span> <span class="s">&#39;location&#39;</span><span class="p">,</span> <span class="s">&#39;northwest&#39;</span><span class="p">);</span>
<span class="n">filestem</span> <span class="p">=</span> <span class="n">strcat</span><span class="p">(</span><span class="s">&#39;growth1_&#39;</span><span class="p">,</span> <span class="n">num2str</span><span class="p">(</span><span class="n">N_t</span><span class="p">),</span> <span class="s">&#39;steps&#39;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="n">filestem</span><span class="p">,</span> <span class="s">&#39;-dpng&#39;</span><span class="p">);</span>  <span class="n">print</span><span class="p">(</span><span class="n">filestem</span><span class="p">,</span> <span class="s">&#39;-dpdf&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>The complete code above resides in the file
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/growth1.m">growth1.m</a>.</p>
<p>Let us demonstrate a simulation where we start with 100 animals, a net
growth rate of 10 percent (0.1) per time unit, which can be one month,
and <span class="math">\(t\in [0,20]\)</span> months. We may first try <span class="math">\(\Delta t\)</span> of half a month
(0.5), which implies <span class="math">\(N_t=40\)</span> (or to be absolutely precise, the last
time point to be computed according to our set-up above is
<span class="math">\(t_{N_t+1}=20.5\)</span>).  Figure <a class="reference internal" href="#sec-de-fig-growth1-0-5"><span>Evolution of a population computed with time step 0.5 month</span></a> shows the
results. The solid line is the exact solution, while the circles are
the computed numerical solution. The discrepancy is clearly
visible. What if we make <span class="math">\(\Delta t\)</span> 10 times smaller? The result is
displayed in Figure <a class="reference internal" href="#sec-de-fig-growth1-0-05"><span>Evolution of a population computed with time step 0.05 month</span></a>, where we now use a
solid line also for the numerical solution (otherwise, 400 circles
would look very cluttered, so the program has a test on how to display
the numerical solution, either as circles or a solid line).  We can
hardly distinguish the exact and the numerical solution.  The
computing time is also a fraction of a second on a laptop, so it
appears that the Forward Euler method is sufficiently accurate for
practical purposes. (This is not always true for large, complicated
simulation models in engineering, so more sophisticated methods may be
needed.)</p>
<div class="figure" id="id7">
<span id="sec-de-fig-growth1-0-5"></span><a class="reference internal image-reference" href="_images/growth1_40steps.png"><img alt="_images/growth1_40steps.png" src="_images/growth1_40steps.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Evolution of a population computed with time step 0.5 month</em></span></p>
</div>
<div class="figure" id="id8">
<span id="sec-de-fig-growth1-0-05"></span><a class="reference internal image-reference" href="_images/growth1_400steps.png"><img alt="_images/growth1_400steps.png" src="_images/growth1_400steps.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Evolution of a population computed with time step 0.05 month</em></span></p>
</div>
<p>It is also of interest to see what happens if we increase <span class="math">\(\Delta t\)</span>
to 2 months. The results in Figure <a class="reference internal" href="#sec-de-fig-growth1-2"><span>Evolution of a population computed with time step 2 months</span></a> indicate
that this is an inaccurate computation.</p>
<div class="figure" id="id9">
<span id="sec-de-fig-growth1-2"></span><a class="reference internal image-reference" href="_images/growth1_10steps.png"><img alt="_images/growth1_10steps.png" src="_images/growth1_10steps.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Evolution of a population computed with time step 2 months</em></span></p>
</div>
</div>
<div class="section" id="understanding-the-forward-euler-method">
<span id="sec-de-pg-geom"></span><h3>Understanding the Forward Euler method<a class="headerlink" href="#understanding-the-forward-euler-method" title="Permalink to this headline">¶</a></h3>
<p>The good thing about the Forward Euler method is that it gives
an understanding of what a differential equation is and a
geometrical picture of how to construct the solution. The first
idea is that we have already computed the solution up to some
time point <span class="math">\(t_n\)</span>. The second idea is that we want to progress
the solution from <span class="math">\(t_n\)</span> to <span class="math">\(t_{n+1}\)</span> as a straight line.</p>
<p>We know that the line must go through the solution at <span class="math">\(t_n\)</span>, i.e., the
point <span class="math">\((t_n, u^n)\)</span>. The differential equation tells us the slope of
the line: <span class="math">\(u'(t_n) = f(u^n,t_n)=ru^n\)</span>. That is, the differential
equation gives a direct formula for the further <em>direction</em> of the
solution curve. We can say that the differential equation expresses
how the system (<span class="math">\(u\)</span>) undergoes changes at a point.</p>
<p>There is a general formula for a straight line <span class="math">\(y=ax+b\)</span> with slope <span class="math">\(a\)</span>
that goes through the point <span class="math">\((x_0,y_0)\)</span>: <span class="math">\(y=a(x-x_0)+y_0\)</span>. Using this
formula adapted to the present case, and evaluating the formula for
<span class="math">\(t_{n+1}\)</span>, results in</p>
<div class="math">
\[u^{n+1} = ru^n(t_{n+1} - t_n) + u^n = u^n + \Delta t\,ru^n,\]</div>
<p>which is nothing but the Forward Euler formula. You are now encouraged
to do <a class="reference internal" href="#sec-de-exer-geom"><span>Exercise 43: Geometric construction of the Forward Euler method</span></a> to become more familiar with
the geometric interpretation of the Forward Euler method.</p>
</div>
<div class="section" id="programming-the-forward-euler-scheme-the-general-case">
<span id="sec-de-fe-gen"></span><h3>Programming the Forward Euler scheme; the general case<a class="headerlink" href="#programming-the-forward-euler-scheme-the-general-case" title="Permalink to this headline">¶</a></h3>
<p>Our previous program was just a flat main program tailored to a
special differential equation.  When programming mathematics, it is
always good to consider a (large) class of problems and making a
Matlab function to solve any problem that fits into the class. More
specifically, we will make software for the class of differential
equation problems of the form</p>
<div class="math">
\[u'(t)=f(u,t),\quad u=U_0,\ t\in [0,T],\]</div>
<p>for some given function <span class="math">\(f\)</span>, and numbers <span class="math">\(U_0\)</span> and <span class="math">\(T\)</span>. The Matlab function
calculating the solution must take <span class="math">\(f\)</span>, <span class="math">\(U_0\)</span>, <span class="math">\(\Delta t\)</span>, and
<span class="math">\(T\)</span> as input, find the corresponding <span class="math">\(N_t\)</span>, compute the solution, and return and
array with <span class="math">\(u^0,u^1,\ldots,u^{N_t}\)</span> and an array with
<span class="math">\(t_0,t_1,\ldots,t_{N_t}\)</span>.  The Forward Euler scheme reads</p>
<div class="math">
\[u^{n+1}=u^n + \Delta t f(u^n,t_n),\quad n=0,\ldots,N_t-1\thinspace .\]</div>
<p>The corresponding program <code class="docutils literal"><span class="pre">ode_FE.m</span></code> may now take the form</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span>[sol, time] <span class="p">=</span><span class="w"> </span><span class="nf">ode_FE</span><span class="p">(</span>f, U_0, dt, T<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">N_t</span> <span class="p">=</span> <span class="nb">floor</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">);</span>
    <span class="n">u</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">t</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_t</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
    <span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">U_0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N_t</span>
        <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
    <span class="k">end</span>
    <span class="n">sol</span>  <span class="p">=</span> <span class="n">u</span><span class="p">;</span>
    <span class="n">time</span> <span class="p">=</span> <span class="n">t</span><span class="p">;</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Note that the function <code class="docutils literal"><span class="pre">ode_FE</span></code> is general, i.e. it can
solve any differential equation <span class="math">\(u'=f(u,t)\)</span>.</p>
<p>A proper demo function for this solver might be written as
(file <a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/demo_population_growth.m">demo_population_growth.m</a>):</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span><span class="nf">demo_population_growth</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="c">% Test case: u&#39; = r*u, u(0)=100</span>
<span class="k">    function</span><span class="w"> </span>r <span class="p">=</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span>u, t<span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="n">r</span> <span class="p">=</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">u</span><span class="p">;</span>
    <span class="k">end</span>
    <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode_FE</span><span class="p">(@</span><span class="n">f</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="mi">100</span><span class="o">*</span><span class="nb">exp</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="n">t</span><span class="p">));</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The solution should be identical to what the <code class="docutils literal"><span class="pre">growth1.py</span></code> program
produces with the same parameter settings (<span class="math">\(r=0.1\)</span>, <span class="math">\(N_0=100\)</span>).
This feature can easily be tested by inserting print statement, but
a much better, automated verification is suggested in
<a class="reference internal" href="#sec-de-exer-geom"><span>Exercise 43: Geometric construction of the Forward Euler method</span></a>. You are strongly encouraged to take
a &#8220;break&#8221; and do that exercise now.</p>
<div class="admonition-remark-on-the-use-of-u-as-variable admonition">
<p class="first admonition-title">Remark on the use of <code class="docutils literal"><span class="pre">u</span></code> as variable</p>
<p class="last">In the <code class="docutils literal"><span class="pre">ode_FE</span></code> program, the variable <code class="docutils literal"><span class="pre">u</span></code> is used in different
contexts. Inside the <code class="docutils literal"><span class="pre">ode_FE</span></code> function, <code class="docutils literal"><span class="pre">u</span></code> is an array, but in
the <code class="docutils literal"><span class="pre">f(u,t)</span></code> function, as exemplified in the <code class="docutils literal"><span class="pre">demo_population_growth</span></code>
function, the argument <code class="docutils literal"><span class="pre">u</span></code> is
a number. Typically, we call <code class="docutils literal"><span class="pre">f</span></code> (in <code class="docutils literal"><span class="pre">ode_FE</span></code>) with the <code class="docutils literal"><span class="pre">u</span></code> argument as
one element of the array <code class="docutils literal"><span class="pre">u</span></code> in the <code class="docutils literal"><span class="pre">ode_FE</span></code> function:
<code class="docutils literal"><span class="pre">u(n)</span></code>.</p>
</div>
</div>
<div class="section" id="making-the-population-growth-model-more-realistic">
<h3>Making the population growth model more realistic<a class="headerlink" href="#making-the-population-growth-model-more-realistic" title="Permalink to this headline">¶</a></h3>
<p>Exponential growth of a population according the model <span class="math">\(N'=rN\)</span>, with
exponential solution <span class="math">\(N=N_0e^{rt}\)</span>, is unrealistic in the long run
because the resources needed to feed the population are finite. At
some point there will not be enough resources and the growth will
decline. A common model taking this effect into account assumes that
<span class="math">\(r\)</span> depends on the size of the population, <span class="math">\(N\)</span>:</p>
<div class="math">
\[N(t+\Delta t) - N(t) = r(N(t))N(t)\thinspace .\]</div>
<p>The corresponding differential equation becomes</p>
<div class="math">
\[N' = r(N)N\thinspace .\]</div>
<p>The reader is strongly encouraged to repeat the steps in the
derivation of the Forward Euler scheme and establish that we get</p>
<div class="math">
\[N^{n+1} = N^n + \Delta t\, r(N^n)N^n,\]</div>
<p>which computes as easy as for a constant <span class="math">\(r\)</span>, since <span class="math">\(r(N^n)\)</span> is
known when computing <span class="math">\(N^{n+1}\)</span>. Alternatively, one can use the Forward Euler formula for
the general problem <span class="math">\(u'=f(u,t)\)</span> and use <span class="math">\(f(u,t)=r(u)u\)</span> and replace <span class="math">\(u\)</span> by <span class="math">\(N\)</span>.</p>
<span class="target" id="index-4"></span><p id="index-5">The simplest choice of <span class="math">\(r(N)\)</span> is a linear function, starting with some
growth value <span class="math">\(\bar r\)</span> and declining until the population has reached
its maximum, <span class="math">\(M\)</span>, according to the available resources:</p>
<div class="math">
\[r(N) = \bar r(1 - N/M)\thinspace .\]</div>
<p>In the beginning, <span class="math">\(N\ll M\)</span> and we will have exponential growth <span class="math">\(e^{\bar rt}\)</span>,
but as <span class="math">\(N\)</span> increases, <span class="math">\(r(N)\)</span> decreases, and when <span class="math">\(N\)</span> reaches <span class="math">\(M\)</span>,
<span class="math">\(r(N)=0\)</span> so there is now more growth and the population remains at
<span class="math">\(N(t)=M\)</span>. This linear choice of <span class="math">\(r(N)\)</span> gives rise to a model that is called
the <em>logistic model</em>. The parameter <span class="math">\(M\)</span> is known as the <em>carrying capacity</em>
of the population.</p>
<p>Let us run the logistic model with aid of the <code class="docutils literal"><span class="pre">ode_FE</span></code> function in
the <code class="docutils literal"><span class="pre">ode_FE</span></code> module. We choose <span class="math">\(N(0)=100\)</span>, <span class="math">\(\Delta t=0.5\)</span> month,
<span class="math">\(T=60\)</span> months, <span class="math">\(r=0.1\)</span>, and <span class="math">\(M=500\)</span>. The complete program, called
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/logistic.m">logistic.m</a>,
is basically a call to <code class="docutils literal"><span class="pre">ode_FE</span></code>:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="n">f</span> <span class="p">=</span> <span class="p">@(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="mf">0.1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">u</span><span class="o">/</span><span class="mi">500</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">;</span>
<span class="n">U_0</span> <span class="p">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="n">dt</span> <span class="p">=</span> <span class="mf">0.5</span><span class="p">;</span>  <span class="n">T</span> <span class="p">=</span> <span class="mi">60</span><span class="p">;</span>
<span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span>  <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;N(t)&#39;</span><span class="p">);</span>
<span class="n">filestem</span> <span class="p">=</span> <span class="n">strcat</span><span class="p">(</span><span class="s">&#39;tmp_&#39;</span><span class="p">,</span><span class="n">num2str</span><span class="p">(</span><span class="n">dt</span><span class="p">));</span>
<span class="c">% Note: this print statement gets a problem with the decimal point</span>
<span class="c">%print(filestem,&#39;-dpng&#39;);  print(filestem,&#39;-dpdf&#39;);</span>
<span class="c">% so we rather do it like this:</span>
<span class="n">filename</span> <span class="p">=</span> <span class="n">strcat</span><span class="p">(</span><span class="n">filestem</span><span class="p">,</span> <span class="s">&#39;.png&#39;</span><span class="p">);</span> <span class="n">print</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>
<span class="n">filename</span> <span class="p">=</span> <span class="n">strcat</span><span class="p">(</span><span class="n">filestem</span><span class="p">,</span> <span class="s">&#39;.pdf&#39;</span><span class="p">);</span> <span class="n">print</span><span class="p">(</span><span class="n">filename</span><span class="p">);</span>

<span class="n">dt</span> <span class="p">=</span> <span class="mi">20</span><span class="p">;</span>  <span class="n">T</span> <span class="p">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span>  <span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;N(t)&#39;</span><span class="p">);</span>
<span class="n">filestem</span> <span class="p">=</span> <span class="n">strcat</span><span class="p">(</span><span class="s">&#39;tmp_&#39;</span><span class="p">,</span><span class="n">num2str</span><span class="p">(</span><span class="n">dt</span><span class="p">));</span>
<span class="n">print</span><span class="p">(</span><span class="n">filestem</span><span class="p">,</span> <span class="s">&#39;-dpng&#39;</span><span class="p">);</span>  <span class="n">print</span><span class="p">(</span><span class="n">filestem</span><span class="p">,</span> <span class="s">&#39;-dpdf&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#sec-de-fig-growth2-logistic"><span>Logistic growth of a population</span></a>
shows the resulting curve. We see that the population stabilizes around
<span class="math">\(M=500\)</span> individuals. A corresponding exponential growth would reach
<span class="math">\(N_0e^{rt}=100e^{0.1\cdot 60}\approx 40,300\)</span> individuals!</p>
<div class="figure" id="id10">
<span id="sec-de-fig-growth2-logistic"></span><a class="reference internal image-reference" href="_images/logistic.png"><img alt="_images/logistic.png" src="_images/logistic.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Logistic growth of a population</em></span></p>
</div>
<p>It is always interesting to see what happens with large <span class="math">\(\Delta t\)</span> values.
We may set <span class="math">\(\Delta t=20\)</span> and <span class="math">\(T=100\)</span>. Now the solution, seen in
Figure <a class="reference internal" href="#sec-de-fig-growth2-logistic-coarse"><span>Logistic growth with large time step</span></a>, oscillates and is hence
qualitatively wrong, because one can prove that the exact solution
of the differential equation is monotone.
(However, there is a corresponding difference
equation model, <span class="math">\(N_{n+1}=rN_n(1-N_n/M)\)</span>, which allows oscillatory solutions
and those are observed in animal populations. The problem with large
<span class="math">\(\Delta t\)</span> is that it just leads to wrong mathematics - and two wrongs
don&#8217;t make a right in terms of a relevant model.)</p>
<div class="figure" id="id11">
<span id="sec-de-fig-growth2-logistic-coarse"></span><a class="reference internal image-reference" href="_images/logistic_coarse.png"><img alt="_images/logistic_coarse.png" src="_images/logistic_coarse.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Logistic growth with large time step</em></span></p>
</div>
<div class="admonition-remark-on-the-world-population admonition">
<p class="first admonition-title">Remark on the world population</p>
<p>The <a class="reference external" href="http://en.wikipedia.org/wiki/Population_growth">number of people on the planet</a>
follows the model <span class="math">\(N'=r(t)N\)</span>, where
the net reproduction <span class="math">\(r(t)\)</span> varies with time and has decreased since
its top in 1990. The current world value of <span class="math">\(r\)</span> is 1.2%, and it is
difficult to <a class="reference external" href="http://users.rcn.com/jkimball.ma.ultranet/BiologyPages/P/Populations.html">predict future values</a>. At
the moment, the predictions of the world population
point to a growth to 9.6 billion before
declining.</p>
<p class="last">This example shows the limitation of a differential equation model: we
need to know all input parameters, including <span class="math">\(r(t)\)</span>, in order to
predict the future.  It is seldom the case that we know all input
parameters. Sometimes knowledge of the solution from measurements can
help estimate missing input parameters.</p>
</div>
</div>
<div class="section" id="verification-exact-linear-solution-of-the-discrete-equations">
<span id="sec-de-growth-test-linear"></span><h3>Verification: exact linear solution of the discrete equations<a class="headerlink" href="#verification-exact-linear-solution-of-the-discrete-equations" title="Permalink to this headline">¶</a></h3>
<p>How can we verify that the programming of an ODE model is correct?
The best method is to find a problem where there are no unknown
numerical approximation errors, because we can then compare the
exact solution of the problem with the result produced by our
implementation and expect the difference to be within a very small
tolerance. We shall base a unit test on this idea and implement a
corresponding <em>test function</em> (see the section <a class="reference internal" href="._pylight004.html#sec-integrals-test-functions"><span>Constructing unit tests and writing test functions</span></a>)
for automatic verification of our implementation.</p>
<p>It appears that most numerical methods for ODEs will exactly
reproduce a solution <span class="math">\(u\)</span> that is linear in <span class="math">\(t\)</span>.
We may therefore set <span class="math">\(u=at+b\)</span> and choose any <span class="math">\(f\)</span> whose derivative
is <span class="math">\(a\)</span>. The choice <span class="math">\(f(u,t)=a\)</span> is very simple, but we may add
anything that is zero, e.g.,</p>
<div class="math">
\[f(u,t) = a + (u - (at+b))^m,\]</div>
<p>This is a valid <span class="math">\(f(u,t)\)</span> for any <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, and <span class="math">\(m\)</span>.
The corresponding
ODE looks highly non-trivial, however:</p>
<div class="math">
\[u' = a + (u - (at+b))^m\]</div>
<p>Using the general <code class="docutils literal"><span class="pre">ode_FE</span></code> function in
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/ode_FE.m">ode_FE.m</a>,
we may
write a proper test function as follows
(in file
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/test_ode_FE_exact_linear.m">test_ode_FE_exact_linear.m</a>):</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span><span class="nf">test_ode_FE_exact_linear</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="c">% Test if a linear function u(t) = a*x + b is exactly reproduced.</span>

    <span class="n">a</span> <span class="p">=</span> <span class="mi">4</span><span class="p">;</span>  <span class="n">b</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="n">m</span> <span class="p">=</span> <span class="mi">6</span><span class="p">;</span>

    <span class="n">exact_solution</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="o">&#39;</span><span class="p">;</span>
    <span class="n">f</span> <span class="p">=</span> <span class="p">@(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>^<span class="n">m</span><span class="p">;</span>

    <span class="n">dt</span> <span class="p">=</span> <span class="mf">0.5</span><span class="p">;</span>       <span class="n">T</span> <span class="p">=</span> <span class="mf">20.0</span><span class="p">;</span>

    <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">exact_solution</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="n">diff</span> <span class="p">=</span> <span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">exact_solution</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">));</span>
    <span class="n">tol</span> <span class="p">=</span> <span class="mf">1E-15</span><span class="p">;</span>           <span class="c">% Tolerance for float comparison</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">diff</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Observe that we cannot compare <code class="docutils literal"><span class="pre">diff</span></code> to zero, which is what we mathematically
expect, because <code class="docutils literal"><span class="pre">diff</span></code> is a floating-point variable that most likely
contains small round-off errors. Therefore, we must compare <code class="docutils literal"><span class="pre">diff</span></code> to
zero with a tolerance, here <span class="math">\(10^{-15}\)</span>.</p>
<p>You are encouraged to do <a class="reference internal" href="#sec-de-exer-fe-test1"><span>Exercise 44: Make test functions for the Forward Euler method</span></a> where the goal
is to make a test function for a verification based on comparison with
hand-calculated results for a few time steps.</p>
</div>
</div>
<div class="section" id="spreading-of-diseases">
<h2>Spreading of diseases<a class="headerlink" href="#spreading-of-diseases" title="Permalink to this headline">¶</a></h2>
<p>Our aim with this section is to show in detail how one can apply mathematics
and programming to investigate spreading of diseases. The mathematical
model is now a system of three differential equations with three unknown
functions. To derive such a model, we can use mainly intuition, so
no specific background knowledge of diseases is required.</p>
<div class="section" id="spreading-of-a-flu">
<span id="sec-de-flu"></span><h3>Spreading of a flu<a class="headerlink" href="#spreading-of-a-flu" title="Permalink to this headline">¶</a></h3>
<p id="index-6">Imagine a boarding school out in the country side.  This school is a
small and closed society. Suddenly, one or more of the pupils get a
flu. We expect that the flu may spread quite effectively or die
out. The question is how many of the pupils and the school&#8217;s staff
will be affected. Some quite simple mathematics can help us to
achieve insight into the dynamics of how the disease spreads.</p>
<p>Let the mathematical function <span class="math">\(S(t)\)</span> count how many individuals, at
time <span class="math">\(t\)</span>, that have the possibility to get infected. Here, <span class="math">\(t\)</span> may
count hours or days, for instance.  These individuals make up a
category called susceptibles, labeled as S. Another category, I,
consists of the individuals that are infected. Let <span class="math">\(I(t)\)</span> count how
many there are in category I at time <span class="math">\(t\)</span>. An individual having
recovered from the disease is assumed to gain immunity. There is also
a small possibility that an infected will die. In either case, the
individual is moved from the I category to a category we call the
removed category, labeled with R.  We let <span class="math">\(R(t)\)</span> count the number of
individuals in the <span class="math">\(R\)</span> category at time <span class="math">\(t\)</span>. Those who enter the <span class="math">\(R\)</span>
category, cannot leave this category.</p>
<p>To summarize, the spreading of this disease is essentially the dynamics
of moving individuals from the S to the I and then to the R
category:</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/categories_SIR.png"><img alt="_images/categories_SIR.png" src="_images/categories_SIR.png" style="width: 400px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>We can use mathematics to more precisely describe the
exchange between the categories. The fundamental idea is to describe
the changes that take place during a small
time interval, denoted by <span class="math">\(\Delta t\)</span>.</p>
<p>Our disease model is often referred to as a <em>compartment model</em>, where
quantities are shuffled between compartments (here a synonym for
categories) according to some rules. The rules express <em>changes</em> in
a small time interval <span class="math">\(\Delta t\)</span>, and
from these changes we can let <span class="math">\(\Delta t\)</span> go to zero and obtain
derivatives. The resulting equations then go from difference equations
(with finite <span class="math">\(\Delta t\)</span>) to differential equations (<span class="math">\(\Delta t\rightarrow 0\)</span>).</p>
<p>We introduce a uniform mesh in time, <span class="math">\(t_n=n\Delta t\)</span>,
<span class="math">\(n=0,\ldots,N_t\)</span>, and seek <span class="math">\(S\)</span> at the mesh points. The numerical
approximation to <span class="math">\(S\)</span> at time <span class="math">\(t_n\)</span> is denoted by <span class="math">\(S^n\)</span>. Similarly,
<span class="math">\(I(t)\)</span> and <span class="math">\(R(t)\)</span> are considered unknown at the mesh points only, and
we introduce a similar notation <span class="math">\(I^n\)</span> and <span class="math">\(R^n\)</span> for the approximations
to the exact values <span class="math">\(I(t_n)\)</span> and <span class="math">\(R(t_n)\)</span>.</p>
<p>In the time interval <span class="math">\(\Delta t\)</span> we know that some people will be
infected, so <span class="math">\(S\)</span> will decrease. We shall soon argue by mathematics
that there will be <span class="math">\(\beta\Delta tSI\)</span> new infected individuals in this
time interval, where <span class="math">\(\beta\)</span> is a parameter reflecting how easy people
get infected during a time interval of unit length. If the loss in <span class="math">\(S\)</span>
is <span class="math">\(\beta\Delta tSI\)</span>, we have that the change in <span class="math">\(S\)</span> is</p>
<div class="math" id="equation-sec:de:SIR:eq1">
<span id="eq-sec-de-sir-eq1"></span><span class="eqno">(9)</span>\[     S^{n+1} - S^n = -\beta\Delta tS^nI^n\thinspace .\]</div>
<p>Dividing by <span class="math">\(\Delta t\)</span> and letting <span class="math">\(\Delta t\rightarrow 0\)</span>, makes
the left-hand side approach <span class="math">\(S'(t_n)\)</span> such that we obtain a
differential equation</p>
<div class="math" id="equation-sec:de:SIR:eq1:de">
<span id="eq-sec-de-sir-eq1-de"></span><span class="eqno">(10)</span>\[     S' = -\beta SI\thinspace .\]</div>
<p>The reasoning in going from the difference equation <a href="#equation-sec:de:SIR:eq1">(9)</a>
to the differential equation <a href="#equation-sec:de:SIR:eq1:de">(10)</a> follows exactly
the steps explained in the section <a class="reference internal" href="#sec-de-pg-model"><span>Derivation of the model</span></a>.</p>
<p>Before proceeding with how <span class="math">\(I\)</span> and <span class="math">\(R\)</span> develops in time,
let us explain the formula <span class="math">\(\beta\Delta tSI\)</span>.  We
have <span class="math">\(S\)</span> susceptibles and <span class="math">\(I\)</span> infected people. These can make up <span class="math">\(SI\)</span>
pairs. Now, suppose that during a time interval <span class="math">\(T\)</span> we measure that
<span class="math">\(m\)</span> actual pairwise meetings do occur among <span class="math">\(n\)</span> theoretically possible
pairings of people from the S and I categories. The probability
that people meet in pairs during a time <span class="math">\(T\)</span> is
(by the empirical frequency definition
of probability) equal to
<span class="math">\(m/n\)</span>, i.e., the number of successes divided by the number of possible
outcomes. From such statistics we normally derive quantities
expressed per unit time, i.e., here we want the
probability per unit time, <span class="math">\(\mu\)</span>,
which is found from dividing by <span class="math">\(T\)</span>: <span class="math">\(\mu = m/(nT)\)</span>.</p>
<p>Given the probability <span class="math">\(\mu\)</span>, the expected number of meetings per
time interval of <span class="math">\(SI\)</span> possible pairs of people is (from basic statistics)
<span class="math">\(\mu SI\)</span>. During a time interval <span class="math">\(\Delta t\)</span>, there will be
<span class="math">\(\mu SI\Delta t\)</span> expected number of meetings between susceptibles and infected
people such that
the virus may spread.  Only a fraction of the <span class="math">\(\mu\Delta t SI\)</span> meetings are
effective in the sense that the susceptible actually becomes infected.
Counting that <span class="math">\(m\)</span> people get infected in <span class="math">\(n\)</span> such pairwise meetings
(say 5 are infected from 1000 meetings), we can estimate the
probability of being infected as <span class="math">\(p=m/n\)</span>. The expected number of
individuals in the S category that in a time interval <span class="math">\(\Delta t\)</span>
catch the virus and get infected
is then <span class="math">\(p\mu\Delta t SI\)</span>. Introducing a new constant <span class="math">\(\beta =p\mu\)</span>
to save some writing, we arrive at the formula <span class="math">\(\beta\Delta tSI\)</span>.</p>
<p>The value of <span class="math">\(\beta\)</span> must be known in order to predict the future
with the disease model. One possibility is to
estimate <span class="math">\(p\)</span> and <span class="math">\(\mu\)</span> from their meanings in the derivation
above. Alternatively, we can observe an &#8220;experiment&#8221; where there
are <span class="math">\(S_0\)</span> susceptibles and <span class="math">\(I_0\)</span> infected at some point in time.
During a time interval <span class="math">\(T\)</span> we count that <span class="math">\(N\)</span> susceptibles have become
infected. Using <a href="#equation-sec:de:SIR:eq1">(9)</a> as a rough approximation of how
<span class="math">\(S\)</span> has developed during time <span class="math">\(T\)</span> (and now <span class="math">\(T\)</span> is not necessarily small,
but we use <a href="#equation-sec:de:SIR:eq1">(9)</a> anyway), we get</p>
<div class="math" id="equation-sec:de:beta:estimate">
<span id="eq-sec-de-beta-estimate"></span><span class="eqno">(11)</span>\[     N = \beta T S_0I_0\quad\Rightarrow\quad\beta = {N\over TS_0I_0}\thinspace .\]</div>
<p>We need an additional equation to describe the evolution of <span class="math">\(I(t)\)</span>.
Such an equation is easy to establish by noting that
the loss in the S category is a corresponding gain in the I category.
More precisely,</p>
<div class="math" id="equation-sec:de:SIR:eq2a">
<span id="eq-sec-de-sir-eq2a"></span><span class="eqno">(12)</span>\[     I^{n+1} - I^n = \beta\Delta tS^nI^n\thinspace .\]</div>
<p>However, there is also a loss in the I category because people recover
from the disease. Suppose that we can measure that <span class="math">\(m\)</span> out of <span class="math">\(n\)</span>
individuals recover in a time period <span class="math">\(T\)</span> (say 10 of 40 sick
people recover during a day: <span class="math">\(m=10\)</span>, <span class="math">\(n=40\)</span>, <span class="math">\(T=24\)</span> h). Now,
<span class="math">\(\gamma =m/(nT)\)</span> is the probability that one individual recover in
a unit time interval. Then (on average) <span class="math">\(\gamma\Delta t I\)</span> infected
will recover in a time interval <span class="math">\(\Delta t\)</span>. This quantity represents
a loss in the I category and a gain in the R category. We can therefore
write the total change in the I category as</p>
<div class="math" id="equation-sec:de:SIR:eq2">
<span id="eq-sec-de-sir-eq2"></span><span class="eqno">(13)</span>\[     I^{n+1} - I^n = \beta\Delta tS^nI^n - \gamma\Delta t I^n\thinspace .\]</div>
<p>The change in the R category is simple: there is always an increase
from the I category:</p>
<div class="math" id="equation-sec:de:SIR:eq3">
<span id="eq-sec-de-sir-eq3"></span><span class="eqno">(14)</span>\[     R^{n+1} - R^n = \gamma\Delta t I^n\thinspace .\]</div>
<p>Since there is no loss in the R category (people are either recovered
and immune, or dead), we are done with the modeling of this category.
In fact, we do not strictly need the equation <a href="#equation-sec:de:SIR:eq3">(14)</a> for <span class="math">\(R\)</span>,
but extensions of the model later will need an equation for <span class="math">\(R\)</span>.</p>
<p>Dividing by <span class="math">\(\Delta t\)</span> in <a href="#equation-sec:de:SIR:eq2">(13)</a> and <a href="#equation-sec:de:SIR:eq2">(13)</a>
and letting <span class="math">\(\Delta t\rightarrow 0\)</span>, results in the corresponding
differential equations</p>
<div class="math" id="equation-sec:de:SIR:eq2:de">
<span id="eq-sec-de-sir-eq2-de"></span><span class="eqno">(15)</span>\[     I' = \beta\Delta tSI - \gamma\Delta t I,\]</div>
<p>and</p>
<div class="math" id="equation-sec:de:SIR:eq3:de">
<span id="eq-sec-de-sir-eq3-de"></span><span class="eqno">(16)</span>\[     R' = \gamma I\thinspace .\]</div>
<p>To summarize, we have derived difference equations
<a href="#equation-sec:de:SIR:eq1">(9)</a>-<a href="#equation-sec:de:SIR:eq3">(14)</a>, and alternative
differential equations <a href="#equation-sec:de:SIR:eq2:de">(15)</a>-<a href="#equation-sec:de:SIR:eq3:de">(16)</a>.
For reference, we list the complete set of the three difference
equations:</p>
<div class="math">
\[S^{n+1} = S^n -\beta\Delta tS^nI^n,\]</div>
<div class="math">
\[I^{n+1} = I^n + \beta\Delta tS^nI^n - \gamma\Delta t I^n,\]</div>
<div class="math">
\[R^{n+1} = R^n + \gamma\Delta t I^n\thinspace .\]</div>
<p>Note that we have isolated the new unknown quantities <span class="math">\(S^{n+1}\)</span>, <span class="math">\(I^{n+1}\)</span>,
and <span class="math">\(R^{n+1}\)</span> on the left-hand side, such that these can readily be
computed if <span class="math">\(S^n\)</span>, <span class="math">\(I^n\)</span>, and <span class="math">\(R^n\)</span> are known. To get such a procedure
started, we need to know <span class="math">\(S^0\)</span>, <span class="math">\(I^0\)</span>, <span class="math">\(R^0\)</span>. Obviously, we also need
to have values for the parameters <span class="math">\(\beta\)</span> and <span class="math">\(\gamma\)</span>.</p>
<p>We also list the system of three differential equations:</p>
<div class="math">
\[S' = \beta SI,\]</div>
<div class="math">
\[I' = \beta SI - \gamma I,\]</div>
<div class="math">
\[R' = \gamma I\thinspace .\]</div>
<p>This differential equation model (and also its discrete counterpart above)
is known as a <em>SIR model</em>. The input data to the differential equation
model consist of the parameters <span class="math">\(\beta\)</span> and <span class="math">\(\gamma\)</span> as well
as the initial conditions <span class="math">\(S(0)=S_0\)</span>, <span class="math">\(I(0)=I_0\)</span>, and <span class="math">\(R(0)=R_0\)</span>.</p>
</div>
<div class="section" id="a-forward-euler-method-for-the-differential-equation-system">
<span id="sec-de-flu-fe"></span><h3>A Forward Euler method for the differential equation system<a class="headerlink" href="#a-forward-euler-method-for-the-differential-equation-system" title="Permalink to this headline">¶</a></h3>
<p>Let us apply the same principles as we did in the section <a class="reference internal" href="#sec-de-pg-numerics"><span>Numerical solution  (1)</span></a>
to discretize the differential equation system by the Forward Euler
method.
We already have a time mesh and time-discrete quantities <span class="math">\(S^n\)</span>, <span class="math">\(I^n\)</span>,
<span class="math">\(R^n\)</span>, <span class="math">\(n=0,\ldots,N_t\)</span>. The three differential equations are
assumed to be valid at the mesh points. At the point <span class="math">\(t_n\)</span> we then
have</p>
<div class="math">
\[S'(t_n) = \beta S(t_n)I(t_n),\]</div>
<div class="math">
\[I'(t_n) = \beta S(t_n)I(t_n) - \gamma I(t_n),\]</div>
<div class="math">
\[R'(t_n) = \gamma I(t_n),\]</div>
<p>for <span class="math">\(n=0,1,\ldots,N_t\)</span>.
This is an approximation since the differential equations are originally
valid at all times <span class="math">\(t\)</span> (usually in some finite interval <span class="math">\([0,T]\)</span>).
Using forward finite differences for the derivatives results in
an additional approximation,</p>
<div class="math" id="equation-sec:de:flu:S">
<span id="eq-sec-de-flu-s"></span><span class="eqno">(17)</span>\[     \frac{S^{n+1}- S^n}{\Delta t} = \beta S^nI^n,\]</div>
<div class="math" id="equation-sec:de:flu:I">
<span id="eq-sec-de-flu-i"></span><span class="eqno">(18)</span>\[     \frac{I^{n+1}- I^n}{\Delta t} = \beta S^nI^n - \gamma I^n,\]</div>
<div class="math" id="equation-sec:de:flu:R">
<span id="eq-sec-de-flu-r"></span><span class="eqno">(19)</span>\[     \frac{R^{n+1}- R^n}{\Delta t} = \gamma I^n\thinspace .\]</div>
<p>As we see, these equations are identical to the difference equations that
naturally arise in the derivation of the model. However, other numerical
methods than the Forward Euler scheme
will result in slightly different difference equations.</p>
</div>
<div class="section" id="programming-the-numerical-method-the-special-case-1">
<span id="sec-de-flu-prog-spec"></span><h3>Programming the numerical method; the special case  (1)<a class="headerlink" href="#programming-the-numerical-method-the-special-case-1" title="Permalink to this headline">¶</a></h3>
<p>The computation of <a href="#equation-sec:de:flu:S">(17)</a>-<a href="#equation-sec:de:flu:R">(19)</a> can be
readily made in a computer program
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/SIR1.m">SIR1.m</a>:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="c">% Time unit: 1 h</span>
<span class="nb">beta</span> <span class="p">=</span> <span class="mi">10</span><span class="o">/</span><span class="p">(</span><span class="mi">40</span><span class="o">*</span><span class="mi">8</span><span class="o">*</span><span class="mi">24</span><span class="p">);</span>
<span class="nb">gamma</span> <span class="p">=</span> <span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="mi">24</span><span class="p">);</span>
<span class="n">dt</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">;</span>               <span class="c">% 6 min</span>
<span class="n">D</span> <span class="p">=</span> <span class="mi">30</span><span class="p">;</span>                 <span class="c">% Simulate for D days</span>
<span class="n">N_t</span> <span class="p">=</span> <span class="nb">floor</span><span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="mi">24</span><span class="o">/</span><span class="n">dt</span><span class="p">);</span>   <span class="c">% Corresponding no of hours</span>

<span class="n">t</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_t</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="n">S</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">I</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">R</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c">% Initial condition</span>
<span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="n">I</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c">% Step equations forward in time</span>
<span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N_t</span>
   <span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="nb">beta</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
   <span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="nb">beta</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="nb">gamma</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
   <span class="n">R</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">R</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="nb">gamma</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="k">end</span>

<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">R</span><span class="p">);</span>
<span class="n">legend</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;R&#39;</span><span class="p">,</span> <span class="s">&#39;Location&#39;</span><span class="p">,</span><span class="s">&#39;northwest&#39;</span><span class="p">);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;hours&#39;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="s">&#39;tmp&#39;</span><span class="p">,</span> <span class="s">&#39;-dpdf&#39;</span><span class="p">);</span>  <span class="n">print</span><span class="p">(</span><span class="s">&#39;tmp&#39;</span><span class="p">,</span> <span class="s">&#39;-dpng&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>This program was written to investigate the spreading of a flu at the
mentioned boarding school, and the reasoning for the specific choices
<span class="math">\(\beta\)</span> and <span class="math">\(\gamma\)</span> goes as follows. At some other school where the
disease has already spread, it was observed that in the beginning of a
day there were 40 susceptibles and 8 infected, while the numbers were
30 and 18, respectively, 24 hours later. Using 1 h as time unit, we
then have from <a href="#equation-sec:de:beta:estimate">(11)</a> that <span class="math">\(\beta = 10/(40\cdot
8\cdot 24)\)</span>.  Among 15 infected, it was observed that 3 recovered
during a day, giving <span class="math">\(\gamma = 3/(15\cdot 24)\)</span>. Applying these
parameters to a new case where there is one infected initially and 50
susceptibles, gives the graphs in Figure <a class="reference internal" href="#sec-de-flu-fig1"><span>Natural evolution of a flu at a boarding school</span></a>. These
graphs are just straight lines between the values at times
<span class="math">\(t_i=i\Delta t\)</span> as computed by the program. We observe that <span class="math">\(S\)</span>
reduces as <span class="math">\(I\)</span> and <span class="math">\(R\)</span> grows. After about 30 days everyone has become
ill and recovered again.</p>
<div class="figure" id="id12">
<span id="sec-de-flu-fig1"></span><a class="reference internal image-reference" href="_images/SIR1.png"><img alt="_images/SIR1.png" src="_images/SIR1.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Natural evolution of a flu at a boarding school</em></span></p>
</div>
<p>We can experiment with <span class="math">\(\beta\)</span> and <span class="math">\(\gamma\)</span> to see whether we get an
outbreak of the disease or not. Imagine that a &#8220;wash your hands&#8221;
campaign was successful and that the other school in this case
experienced a reduction of <span class="math">\(\beta\)</span> by a factor of 5. With this lower
<span class="math">\(\beta\)</span> the disease spreads very slowly so we simulate for 60
days. The curves appear in Figure <a class="reference internal" href="#sec-de-flu-fig2"><span>Small outbreak of a flu at a boarding school ( \( beta \)  is much smaller than in Figure :ref:`sec:de:flu:fig2`)</span></a>.</p>
<div class="figure" id="id13">
<span id="sec-de-flu-fig2"></span><a class="reference internal image-reference" href="_images/SIR1b.png"><img alt="_images/SIR1b.png" src="_images/SIR1b.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Small outbreak of a flu at a boarding school ( \( beta \)  is much smaller than in Figure :ref:`sec:de:flu:fig2`)</em></span></p>
</div>
</div>
<div class="section" id="outbreak-or-not">
<h3>Outbreak or not<a class="headerlink" href="#outbreak-or-not" title="Permalink to this headline">¶</a></h3>
<p>Looking at the equation for <span class="math">\(I\)</span>, it is clear that we must have <span class="math">\(\beta
SI - \gamma I&gt;0\)</span> for <span class="math">\(I\)</span> to increase. When we start the simulation it
means that</p>
<div class="math">
\[\begin{split}\beta S(0)I(0) - \gamma I(0)&gt;0,\end{split}\]</div>
<p>or simpler</p>
<div class="math" id="equation-sec:de:SIR:criticalpoint">
<span id="eq-sec-de-sir-criticalpoint"></span><span class="eqno">(20)</span>\[\begin{split}     \frac{\beta S(0)}{\gamma} &gt; 1\end{split}\]</div>
<p>to increase the number of infected people and accelerate the spreading
of the disease. You can run the <code class="docutils literal"><span class="pre">SIR1.m</span></code> program with a smaller <span class="math">\(\beta\)</span>
such that <a href="#equation-sec:de:SIR:criticalpoint">(20)</a> is violated and observe that there is
no outbreak.</p>
<div class="admonition-the-power-of-mathematical-modeling admonition">
<p class="first admonition-title">The power of mathematical modeling</p>
<p class="last">The reader should notice our careful use of words in the previous
paragraphs. We started out with modeling a very specific case, namely
the spreading of a flu among pupils and staff at a boarding school.
With purpose we exchanged words like pupils and flu with more neutral
and general words like <em>individuals</em> and <em>disease</em>,
respectively. Phrased equivalently, we raised the abstraction level by
moving from a specific case (flu at a boarding school) to a more
general case (disease in a closed society).  Very often, when
developing mathematical models, we start with a specific example and
see, through the modeling, that what is going on of essence in this
example also will take place in many similar problem settings.  We try
to incorporate this generalization in the model so that the model has
a much wider application area than what we aimed at in the
beginning. This is the very power of mathematical modeling: by solving
one specific case we have often developed more generic tools that can
readily be applied to solve seemingly different problems.  The next
sections will give substance to this assertion.</p>
</div>
</div>
<div class="section" id="abstract-problem-and-notation">
<span id="sec-de-flu-generic"></span><h3>Abstract problem and notation<a class="headerlink" href="#abstract-problem-and-notation" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-7"></span><span class="target" id="index-8"></span><span class="target" id="index-9"></span><span class="target" id="index-10"></span><p id="index-11">When we had a specific differential equation with one unknown, we quickly
turned to an abstract differential equation written in the generic
form <span class="math">\(u'=f(u,t)\)</span>. We refer to such a problem as a <em>scalar ODE</em>.
A specific equation corresponds to a specific
choice of the formula <span class="math">\(f(u,t)\)</span> involving <span class="math">\(u\)</span> and (optionally) <span class="math">\(t\)</span>.</p>
<p>It is advantageous to also write a system of differential equations
in the same abstract notation,</p>
<div class="math">
\[u'=f(u,t),\]</div>
<p>but this time it is understood
that <span class="math">\(u\)</span> is a vector of functions and <span class="math">\(f\)</span> is also vector.
We say that <span class="math">\(u'=f(u,t)\)</span> is a <em>vector ODE</em> or <em>system of ODEs</em> in this case.
For the SIR model we introduce the two 3-vectors, one for the unknowns,</p>
<div class="math">
\[u = (S(t), I(t), R(t)),\]</div>
<p>and one for the right-hand side functions,</p>
<div class="math">
\[f(u,t) = (-\beta SI, \beta SI -\gamma I, \gamma I)\thinspace .\]</div>
<p>The equation <span class="math">\(u'=f(u,t)\)</span> means setting the two vectors equal, i.e.,
each component must be equal. Since <span class="math">\(u'=(S', I', R')\)</span>, we get that
<span class="math">\(u'=f\)</span> implies</p>
<div class="math">
\[\begin{split}S' &amp;= -\beta SI,\\
I' &amp;= \beta SI - \gamma I,\\
R' &amp;= \gamma I\thinspace .\end{split}\]</div>
<p>The generalized short notation <span class="math">\(u'=f(u,t)\)</span> is very handy since we can
derive numerical methods and implement software for this abstract system
and in a particular application just identify the formulas in the <span class="math">\(f\)</span> vector,
implement these, and call functionality that solves the differential
equation system.</p>
</div>
<div class="section" id="programming-the-numerical-method-the-general-case">
<span id="sec-de-flu-prog-generic"></span><h3>Programming the numerical method; the general case<a class="headerlink" href="#programming-the-numerical-method-the-general-case" title="Permalink to this headline">¶</a></h3>
<p>In Matlab code, the Forward Euler step</p>
<div class="math">
\[u^{n+1} = u^n + \Delta t f(u^n, t_n),\]</div>
<p>being a scalar or a vector equation,
can be coded as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,:)</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">,:)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">,:),</span> <span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
<p>both in the scalar and vector case. In the vector case,
<code class="docutils literal"><span class="pre">u(n,:)</span></code> is a one-dimensional array of length <span class="math">\(m+1\)</span>
holding the mathematical quantity
<span class="math">\(u^n\)</span>, and the Matlab function <code class="docutils literal"><span class="pre">f</span></code> must return an array
of length <span class="math">\(m+1\)</span>. Then the expression <code class="docutils literal"><span class="pre">u(n,:)</span> <span class="pre">+</span> <span class="pre">dt*f(u(n,:),</span> <span class="pre">t(n))</span></code>
is an array plus a scalar times an array.</p>
<p>For all this to work, the complete numerical solution must be represented by a
two-dimensional array, created by <code class="docutils literal"><span class="pre">u</span> <span class="pre">=</span> <span class="pre">zeros(N_t+1,</span> <span class="pre">m+1)</span></code>.
The first index counts the time points and the second the components
of the solution vector at one time point.
That is, <code class="docutils literal"><span class="pre">u(n,i)</span></code> corresponds
to the mathematical quantity <span class="math">\(u^n_i\)</span>. Writing <code class="docutils literal"><span class="pre">u(n,:)</span></code> picks out all the
components in the solution at the time point with index <code class="docutils literal"><span class="pre">n</span></code>.
The nice feature of these facts is that the same piece of
Matlab code works for both a scalar ODE and a system of ODEs!</p>
<p>The <code class="docutils literal"><span class="pre">ode_FE</span></code> function for the vector ODE is placed in the file
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/ode_system_FE.m">ode_system_FE.m</a>
and was written as follows:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span>[u, t] <span class="p">=</span><span class="w"> </span><span class="nf">ode_FE</span><span class="p">(</span>f, U_0, dt, T<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">N_t</span> <span class="p">=</span> <span class="nb">floor</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">);</span>
    <span class="n">u</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">U_0</span><span class="p">));</span>
    <span class="n">t</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_t</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="nb">length</span><span class="p">(</span><span class="n">u</span><span class="p">));</span>
    <span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span> <span class="p">=</span> <span class="n">U_0</span><span class="p">;</span>      <span class="c">% Initial values</span>
    <span class="n">t</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N_t</span>
        <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,:)</span>  <span class="p">=</span> <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">,:)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">,:),</span> <span class="n">t</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Let us show how the previous SIR model can be solved using the new
general <code class="docutils literal"><span class="pre">ode_FE</span></code> that can solve <em>any</em> vector ODE. The user&#8217;s <code class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t)</span></code>
function takes a vector <code class="docutils literal"><span class="pre">u</span></code>, with three components corresponding to
<span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> as argument, along with the current time point <code class="docutils literal"><span class="pre">t(n)</span></code>,
and must return the values of the formulas of the right-hand sides
in the vector ODE. An appropriate implementation is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">function</span> <span class="n">result</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">I</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">R</span> <span class="o">=</span> <span class="n">u</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">beta</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">I</span> <span class="n">beta</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span> <span class="n">gamma</span><span class="o">*</span><span class="n">I</span><span class="p">]</span>
<span class="n">end</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">beta</span></code> and <code class="docutils literal"><span class="pre">gamma</span></code> are problem specific parameters set outside of that function.
Note that the <code class="docutils literal"><span class="pre">S</span></code>, <code class="docutils literal"><span class="pre">I</span></code>, and <code class="docutils literal"><span class="pre">R</span></code> values correspond to <span class="math">\(S^n\)</span>, <span class="math">\(I^n\)</span>, and <span class="math">\(R^n\)</span>.
These values are then just inserted in the various formulas
in the vector ODE.</p>
<p>We can now show a function
(in file
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/demo_SIR.m">demo_SIR.m</a>)
that runs the previous SIR example,
but which applies the generic <code class="docutils literal"><span class="pre">ode_FE</span></code> function:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span><span class="nf">demo_SIR</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="c">% Test case using an SIR model</span>

    <span class="n">dt</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">;</span>               <span class="c">% 6 min</span>
    <span class="n">D</span> <span class="p">=</span> <span class="mi">30</span><span class="p">;</span>                 <span class="c">% Simulate for D days</span>
    <span class="n">N_t</span> <span class="p">=</span> <span class="nb">floor</span><span class="p">(</span><span class="n">D</span><span class="o">*</span><span class="mi">24</span><span class="o">/</span><span class="n">dt</span><span class="p">);</span>   <span class="c">% Corresponding no of hours</span>
    <span class="n">T</span> <span class="p">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">N_t</span><span class="p">;</span>             <span class="c">% End time</span>
    <span class="n">U_0</span> <span class="p">=</span> <span class="p">[</span><span class="mi">50</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">];</span>

    <span class="n">f_handle</span> <span class="p">=</span> <span class="p">@</span><span class="n">f</span><span class="p">;</span>

    <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">ode_FE</span><span class="p">(</span><span class="n">f_handle</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>

    <span class="n">S</span> <span class="p">=</span> <span class="n">u</span><span class="p">(:,</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">I</span> <span class="p">=</span> <span class="n">u</span><span class="p">(:,</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">R</span> <span class="p">=</span> <span class="n">u</span><span class="p">(:,</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="s">&#39;r-&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="s">&#39;g-&#39;</span><span class="p">);</span>
    <span class="n">legend</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;R&#39;</span><span class="p">);</span>
    <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;hours&#39;</span><span class="p">);</span>
    <span class="c">% Consistency check:</span>
    <span class="n">N</span> <span class="p">=</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">I</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="nb">eps</span> <span class="p">=</span> <span class="mf">1E-12</span><span class="p">;</span>           <span class="c">% Tolerance for comparing real numbers</span>
    <span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="nb">length</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">err</span> <span class="p">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">R</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">N</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="nb">eps</span><span class="p">)</span>
            <span class="n">error</span><span class="p">(</span><span class="s">&#39;demo_SIR: error=%g&#39;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
        <span class="k">end</span>
    <span class="k">end</span>
<span class="k">end</span>

<span class="k">function</span><span class="w"> </span>result <span class="p">=</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span>u,t<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="nb">beta</span> <span class="p">=</span> <span class="mi">10</span><span class="o">/</span><span class="p">(</span><span class="mi">40</span><span class="o">*</span><span class="mi">8</span><span class="o">*</span><span class="mi">24</span><span class="p">);</span>
    <span class="nb">gamma</span> <span class="p">=</span> <span class="mi">3</span><span class="o">/</span><span class="p">(</span><span class="mi">15</span><span class="o">*</span><span class="mi">24</span><span class="p">);</span>

    <span class="n">S</span> <span class="p">=</span> <span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="n">I</span> <span class="p">=</span> <span class="n">u</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span> <span class="n">R</span> <span class="p">=</span> <span class="n">u</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">result</span> <span class="p">=</span> <span class="p">[</span><span class="o">-</span><span class="nb">beta</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">I</span> <span class="nb">beta</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">I</span> <span class="o">-</span> <span class="nb">gamma</span><span class="o">*</span><span class="n">I</span> <span class="nb">gamma</span><span class="o">*</span><span class="n">I</span><span class="p">];</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Recall that the <code class="docutils literal"><span class="pre">u</span></code> returned from <code class="docutils literal"><span class="pre">ode_FE</span></code> contains all components
(<span class="math">\(S\)</span>, <span class="math">\(I\)</span>, <span class="math">\(R\)</span>) in the solution vector at all time points. We
therefore need to extract the <span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span> values in separate
arrays for further analysis and easy plotting.</p>
<p>Another key feature of this higher-quality code is the consistency
check. By adding the three differential equations in the SIR
model, we realize that <span class="math">\(S' + I' + R'=0\)</span>, which means that
<span class="math">\(S+I+R=\mbox{const}\)</span>. We can check that this relation holds
by comparing <span class="math">\(S^n+I^n+R^n\)</span> to the sum of the initial conditions.
The check is not a full-fledged
verification, but it is a much better than doing nothing and hoping
that the computation is correct.
<a class="reference internal" href="#sec-de-exer-sir-dtopt"><span>Exercise 47: Find an appropriate time step; SIR model</span></a> suggests another method for
controlling the quality of the numerical solution.</p>
</div>
<div class="section" id="time-restricted-immunity">
<h3>Time-restricted immunity<a class="headerlink" href="#time-restricted-immunity" title="Permalink to this headline">¶</a></h3>
<p>Let us now assume that immunity after the disease
only lasts for some certain time period. This means that there is
transport from the R state to the S state:</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/categories_SIR_feedback.png"><img alt="_images/categories_SIR_feedback.png" src="_images/categories_SIR_feedback.png" style="width: 400px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>Modeling the loss of immunity
is very similar to modeling recovering from the disease: the
amount of people losing immunity is proportional to the amount
of recovered patients and the length of the time interval <span class="math">\(\Delta t\)</span>.
We can therefore write the loss in the R category as
<span class="math">\(-\nu\Delta t R\)</span> in time <span class="math">\(\Delta t\)</span>, where <span class="math">\(\nu^{-1}\)</span> is the
typical time it takes to lose immunity. The loss in <span class="math">\(R(t)\)</span>
is a gain in <span class="math">\(S(t)\)</span>. The &#8220;budgets&#8221; for the categories
therefore become</p>
<div class="math">
\[S^{n+1} = S^n -\beta\Delta tS^nI^n + \nu\Delta t R,\]</div>
<div class="math">
\[I^{n+1} = I^n + \beta\Delta tS^nI^n - \gamma\Delta t I^n,\]</div>
<div class="math">
\[R^{n+1} = R^n + \gamma\Delta t I^n - \nu\Delta t R\thinspace .\]</div>
<p>Dividing by <span class="math">\(\Delta t\)</span> and letting <span class="math">\(\Delta t\rightarrow 0\)</span> gives
the differential equation system</p>
<div class="math">
\[S' = \beta SI + \nu R,\]</div>
<div class="math">
\[I' = \beta SI - \gamma I,\]</div>
<div class="math">
\[R' = \gamma I - \nu R\thinspace .\]</div>
<p>This system can be solved by the same methods as we demonstrated for
the original SIR model. Only one modification in the program is
necessary: adding <code class="docutils literal"><span class="pre">nu*R[n]</span></code> to the <code class="docutils literal"><span class="pre">S[n+1]</span></code> update and subtracting
the same quantity in the <code class="docutils literal"><span class="pre">R[n+1]</span></code> update:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N_t</span>
    <span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="nb">beta</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">nu</span><span class="o">*</span><span class="n">R</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="nb">beta</span><span class="o">*</span><span class="n">S</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="nb">gamma</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">R</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">R</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="nb">gamma</span><span class="o">*</span><span class="n">I</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">nu</span><span class="o">*</span><span class="n">R</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The modified code is found in the file <code class="docutils literal"><span class="pre">SIR2.m</span></code>.</p>
<p>Setting <span class="math">\(\nu^{-1}\)</span> to 50 days, reducing <span class="math">\(\beta\)</span> by a factor of 4 compared
to the previous example (<span class="math">\(\beta=0.00033\)</span>),
and simulating for 300 days gives an oscillatory
behavior in the categories, as depicted in Figure <a class="reference internal" href="#sec-de-flu-fig3"><span>Including loss of immunity</span></a>.
It is easy now to play around and study how the parameters affect the
spreading of the disease.
For example,
making the disease slightly more effective (increase <span class="math">\(\beta\)</span> to 0.00043)
and increasing the average time to loss of immunity to 90 days lead
to other oscillations in Figure <a class="reference internal" href="#sec-de-flu-fig4"><span>Increasing  \( beta \)  and reducing  \( nu \)  compared to Figure :ref:`sec:de:flu:fig3`</span></a>.</p>
<div class="figure" id="id14">
<span id="sec-de-flu-fig3"></span><a class="reference internal image-reference" href="_images/SIR2.png"><img alt="_images/SIR2.png" src="_images/SIR2.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Including loss of immunity</em></span></p>
</div>
<div class="figure" id="id15">
<span id="sec-de-flu-fig4"></span><a class="reference internal image-reference" href="_images/SIR2b.png"><img alt="_images/SIR2b.png" src="_images/SIR2b.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Increasing  \( beta \)  and reducing  \( nu \)  compared to Figure :ref:`sec:de:flu:fig3`</em></span></p>
</div>
</div>
<div class="section" id="incorporating-vaccination">
<span id="sec-de-flu-vaccine"></span><h3>Incorporating vaccination<a class="headerlink" href="#incorporating-vaccination" title="Permalink to this headline">¶</a></h3>
<p>We can extend the model to also include vaccination. To this end, it can
be useful to track those who are vaccinated and not, so we introduce
a fourth category, V, for the those who have taken a successful
vaccination. Furthermore, we assume that in a time interval <span class="math">\(\Delta t\)</span>,
a fraction <span class="math">\(p\Delta t\)</span> of the S category is subject to a successful
vaccination. This means that in time <span class="math">\(\Delta t\)</span>, <span class="math">\(p\Delta t S\)</span> people
leave from the S to the V category. Since the vaccinated ones cannot
get the disease, there is no impact on the I or R categories. We can
visualize the categories and the movement between them as</p>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<div class="figure">
<a class="reference internal image-reference" href="_images/categories_SIRV2.png"><img alt="_images/categories_SIRV2.png" src="_images/categories_SIRV2.png" style="width: 400px;" /></a>
</div>
<div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
<p>The new, extended differential equations with the <span class="math">\(V\)</span> quantity become</p>
<div class="math">
\[S' = \beta SI + \nu R -pS,\]</div>
<div class="math">
\[V' = pS,\]</div>
<div class="math">
\[I' = \beta SI - \gamma I,\]</div>
<div class="math">
\[R' = \gamma I - \nu R\thinspace .\]</div>
<p>We shall refer to this model as the SIRV model.</p>
<p>The new equation for <span class="math">\(V'\)</span> poses no difficulties when it comes to the
numerical method. In a Forward Euler scheme we simply add an update</p>
<div class="math">
\[V^{n+1} = V^n + \Delta t p V^n\thinspace .\]</div>
<p>The program needs to store <span class="math">\(V(t)\)</span> in an additional array <code class="docutils literal"><span class="pre">V</span></code>,
and the plotting command must be extended with more arguments to
plot <code class="docutils literal"><span class="pre">V</span></code> versus <code class="docutils literal"><span class="pre">t</span></code> as well. The complete code is found in
the file <code class="docutils literal"><span class="pre">SIRV1.m</span></code>.</p>
<p>Using <span class="math">\(p=0.0005\)</span> and <span class="math">\(p=0.0001\)</span> as vaccine efficiency parameter,
Figure <a class="reference internal" href="#sec-de-flu-fig5"><span>The effect of vaccination:  \( p=0005 \)  (left) and  \( p=0.0001 \)  (right)</span></a>
shows the effect of vaccination (other parameters are
as in Figure <a class="reference internal" href="#sec-de-flu-fig3"><span>Including loss of immunity</span></a>).</p>
<div class="figure" id="id16">
<span id="sec-de-flu-fig5"></span><a class="reference internal image-reference" href="_images/SIRV1.png"><img alt="_images/SIRV1.png" src="_images/SIRV1.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>The effect of vaccination:  \( p=0005 \)  (left) and  \( p=0.0001 \)  (right)</em></span></p>
</div>
</div>
<div class="section" id="discontinuous-coefficients-a-vaccination-campaign">
<span id="sec-de-flu-vaccine-discont"></span><h3>Discontinuous coefficients: a vaccination campaign<a class="headerlink" href="#discontinuous-coefficients-a-vaccination-campaign" title="Permalink to this headline">¶</a></h3>
<p>What about modeling a vaccination campaign? Imagine that six days
after the outbreak of the disease, the local
health station launches a vaccination campaign. The reach out
to many people, say 10 times as efficiently as in the previous
(constant vaccination) case. If the campaign lasts for 10 days
we can write</p>
<div class="math">
\[\begin{split}p(t) = \left\lbrace\begin{array}{ll}
0.005,&amp; 6\cdot 24\leq t\leq 15\cdot 24,\\
0,&amp; \hbox{otherwise} \end{array}\right.\end{split}\]</div>
<p>Note that we must multiply the <span class="math">\(t\)</span> value by 24 because <span class="math">\(t\)</span> is measured
in hours, not days.
In the differential equation system, <span class="math">\(pS(t)\)</span> must be replaced by
<span class="math">\(p(t)S(t)\)</span>, and in this case we get a differential equation system
with a term that is <em>discontinuous</em>. This is usually quite a challenge
in mathematics, but as long as we solve the equations numerically
in a program, a discontinuous coefficient is easy to treat.</p>
<p>There are two ways to implement the discontinuous coefficient <span class="math">\(p(t)\)</span>:
through a function and through an array. The function approach is
perhaps the easiest:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span>value <span class="p">=</span><span class="w"> </span><span class="nf">p</span><span class="p">(</span>t<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span> <span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="mi">24</span> <span class="o">&lt;</span><span class="p">=</span> <span class="n">t</span> <span class="o">&lt;</span><span class="p">=</span> <span class="mi">15</span><span class="o">*</span><span class="mi">24</span><span class="p">)</span>
        <span class="n">value</span> <span class="p">=</span> <span class="mf">0.005</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">value</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>In the code for updating the arrays <code class="docutils literal"><span class="pre">S</span></code> and <code class="docutils literal"><span class="pre">V</span></code> we get a term
<code class="docutils literal"><span class="pre">p(t(n))*S(n)</span></code>.</p>
<p>We can also let <span class="math">\(p(t)\)</span> be an array filled with correct values prior
to the simulation. Then we need to allocate an array <code class="docutils literal"><span class="pre">p</span></code> of length <code class="docutils literal"><span class="pre">N_t+1</span></code>
and find the indices corresponding to the time period between 6 and 15
days. These indices are found from the time point divided by
<span class="math">\(\Delta t\)</span>. That is,</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="n">p</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">start_index</span> <span class="p">=</span> <span class="mi">6</span><span class="o">*</span><span class="mi">24</span><span class="o">/</span><span class="n">dt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">stop_index</span> <span class="p">=</span> <span class="mi">15</span><span class="o">*</span><span class="mi">24</span><span class="o">/</span><span class="n">dt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">p</span><span class="p">(</span><span class="n">start_index</span><span class="p">:</span><span class="n">stop_index</span><span class="p">)</span> <span class="p">=</span> <span class="mf">0.005</span><span class="p">;</span>
</pre></div>
</div>
<p>The <span class="math">\(p(t)S(t)\)</span> term in the updating formulas for <span class="math">\(S\)</span> and <span class="math">\(V\)</span> simply becomes
<code class="docutils literal"><span class="pre">p(n)*S(n)</span></code>. The file <code class="docutils literal"><span class="pre">SIRV2.m</span></code>
contains a program based on filling an array <code class="docutils literal"><span class="pre">p</span></code>.</p>
<p>The effect of a vaccination campaign is illustrated in Figure
<a class="reference internal" href="#sec-de-flu-fig6"><span>The effect of a vaccination campaign</span></a>. All the data are as in Figure <a class="reference internal" href="#sec-de-flu-fig5"><span>The effect of vaccination:  \( p=0005 \)  (left) and  \( p=0.0001 \)  (right)</span></a>,
except that <span class="math">\(p\)</span> is ten times stronger for a period of 10 days and
<span class="math">\(p=0\)</span> elsewhere.</p>
<div class="figure" id="id17">
<span id="sec-de-flu-fig6"></span><a class="reference internal image-reference" href="_images/SIRV2.png"><img alt="_images/SIRV2.png" src="_images/SIRV2.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>The effect of a vaccination campaign</em></span></p>
</div>
</div>
</div>
<div class="section" id="oscillating-one-dimensional-systems">
<span id="sec-de-vib"></span><h2>Oscillating one-dimensional systems<a class="headerlink" href="#oscillating-one-dimensional-systems" title="Permalink to this headline">¶</a></h2>
<p>Numerous engineering constructions and devices contain materials
that act like springs. Such springs give rise to oscillations, and
controlling oscillations is a key engineering task. We shall now
learn to simulate oscillating systems.</p>
<p>As always, we start with the simplest meaningful mathematical
model, which for oscillations is a second-order differential equation:</p>
<div class="math" id="equation-sec:de:vib:ode1">
<span id="eq-sec-de-vib-ode1"></span><span class="eqno">(21)</span>\[     u''(t) + \omega^2 u(t) = 0,\]</div>
<p>where <span class="math">\(\omega\)</span> is a given physical parameter. Equation <a href="#equation-sec:de:vib:ode1">(21)</a>
models a one-dimensional system oscillating without damping
(i.e., with negligible damping). One-dimensional here means that some
motion takes place along one dimension only in some coordinate system.
Along with <a href="#equation-sec:de:vib:ode1">(21)</a> we need the two <em>initial conditions</em>
<span class="math">\(u(0)\)</span> and <span class="math">\(u'(0)\)</span>.</p>
<div class="section" id="derivation-of-a-simple-model">
<h3>Derivation of a simple model<a class="headerlink" href="#derivation-of-a-simple-model" title="Permalink to this headline">¶</a></h3>
<div class="figure" id="id18">
<span id="sec-de-vib-ode1-fig1"></span><a class="reference internal image-reference" href="_images/oscillator_spring.png"><img alt="_images/oscillator_spring.png" src="_images/oscillator_spring.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Sketch of a one-dimensional, oscillating dynamic system (without friction)</em></span></p>
</div>
<p>Many engineering systems undergo oscillations, and differential
equations constitute the key tool to understand, predict, and control the
oscillations.  We start with the simplest possible model that
captures the essential dynamics of an oscillating system. Some body
with mass <span class="math">\(m\)</span> is attached to a spring and moves along a line
without friction, see Figure <a class="reference internal" href="#sec-de-vib-ode1-fig1"><span>Sketch of a one-dimensional, oscillating dynamic system (without friction)</span></a>
for a sketch (rolling wheels
indicate &#8220;no friction&#8221;).
When the spring is stretched (or compressed), the spring force pulls (or pushes) the body back and work
&#8220;against&#8221; the motion. More precisely, let <span class="math">\(x(t)\)</span> be the position of
the body on the <span class="math">\(x\)</span> axis, along which the body moves. The spring is
not stretched when <span class="math">\(x=0\)</span>, so the force is zero, and <span class="math">\(x=0\)</span> is hence
the equilibrium position of the body. The spring force is <span class="math">\(-kx\)</span>,
where <span class="math">\(k\)</span> is a constant to be measured. We assume that there are no
other forces (e.g., no friction). Newton&#8217;s 2nd law of motion <span class="math">\(F=ma\)</span>
then has <span class="math">\(F=-kx\)</span> and <span class="math">\(a=\ddot x\)</span>,</p>
<div class="math" id="equation-sec:de:model:osc1a">
<span id="eq-sec-de-model-osc1a"></span><span class="eqno">(22)</span>\[     -kx = m\ddot x,\]</div>
<p>which can be rewritten as</p>
<div class="math" id="equation-sec:de:model:osc1b">
<span id="eq-sec-de-model-osc1b"></span><span class="eqno">(23)</span>\[     x'' + \omega^2x = 0,\]</div>
<p>by introducing <span class="math">\(\omega = \sqrt{k/m}\)</span> (which is very common).</p>
<p>Equation <a href="#equation-sec:de:model:osc1b">(23)</a>
is a <em>second-order</em> differential equation, and therefore we need
<em>two</em> initial conditions, one on the position <span class="math">\(x(0)\)</span> and one on the
velocity <span class="math">\(x'(0)\)</span>. Here we choose the body to be at rest, but
moved away from its equilibrium position:</p>
<div class="math">
\[x(0)=X_0,\quad x'(0)=0\thinspace .\]</div>
<p>The exact solution of <a href="#equation-sec:de:model:osc1b">(23)</a> with these initial
conditions is <span class="math">\(x(t)=X_0\cos\omega t\)</span>. This can easily be verified by
substituting into <a href="#equation-sec:de:model:osc1b">(23)</a> and checking the initial
conditions. The solution tells that such a spring-mass system
oscillates back and forth as described by a cosine curve.</p>
<p>The differential equation <a href="#equation-sec:de:model:osc1b">(23)</a> appears in numerous
other contexts. A classical example is a simple pendulum that
oscillates back and forth. Physics books derive, from Newton&#8217;s second law
of motion, that</p>
<div class="math">
\[mL\theta'' + mg\sin \theta = 0,\]</div>
<p>where <span class="math">\(m\)</span> is the mass of the body at the end of a pendulum with length <span class="math">\(L\)</span>,
<span class="math">\(g\)</span> is the acceleration of gravity, and <span class="math">\(\theta\)</span> is the angle the pendulum makes
with the vertical. Considering small angles <span class="math">\(\theta\)</span>, <span class="math">\(\sin \theta\approx \theta\)</span>,
and we get <a href="#equation-sec:de:model:osc1b">(23)</a> with <span class="math">\(x=\theta\)</span>, <span class="math">\(\omega = \sqrt{g/L}\)</span>,
<span class="math">\(x(0)=\Theta\)</span>, and <span class="math">\(x'(0)=0\)</span>, if <span class="math">\(\Theta\)</span> is the initial angle and the
pendulum is at rest at <span class="math">\(t=0\)</span>.</p>
</div>
<div class="section" id="numerical-solution-2">
<h3>Numerical solution  (2)<a class="headerlink" href="#numerical-solution-2" title="Permalink to this headline">¶</a></h3>
<p>We have not looked at numerical methods for handling second-order
derivatives, and such methods are an option, but we know how to solve
first-order differential equations and even systems of first-order
equations. With a little, yet very common, trick we can rewrite
<a href="#equation-sec:de:model:osc1b">(23)</a> as a first-order system of two differential
equations. We introduce <span class="math">\(u=x\)</span> and <span class="math">\(v=x'=u'\)</span> as <em>two</em> new unknown functions.
The two corresponding equations arise from the definition <span class="math">\(v=u'\)</span> and
the original equation <a href="#equation-sec:de:model:osc1b">(23)</a>:</p>
<div class="math" id="equation-sec:de:model:osc2:u">
<span id="eq-sec-de-model-osc2-u"></span><span class="eqno">(24)</span>\[     u' = v,\]</div>
<div class="math" id="equation-sec:de:model:osc2:v">
<span id="eq-sec-de-model-osc2-v"></span><span class="eqno">(25)</span>\[     v' = -\omega^2 u\thinspace .\]</div>
<p>(Notice that we can use <span class="math">\(u''=v'\)</span> to remove the second-order derivative from
Newton&#8217;s 2nd law.)</p>
<p>We can now apply the Forward Euler method to
<a href="#equation-sec:de:model:osc2:u">(24)</a>-<a href="#equation-sec:de:model:osc2:v">(25)</a>,
exactly as we did in the section <a class="reference internal" href="#sec-de-flu-fe"><span>A Forward Euler method for the differential equation system</span></a>:</p>
<div class="math" id="equation-sec:de:model:osc2:ud0">
<span id="eq-sec-de-model-osc2-ud0"></span><span class="eqno">(26)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = v^n,\]</div>
<div class="math" id="equation-sec:de:model:osc2:vd0">
<span id="eq-sec-de-model-osc2-vd0"></span><span class="eqno">(27)</span>\[     \frac{v^{n+1}-v^n}{\Delta t}  = -\omega^2 u^n,\]</div>
<p>resulting in the computational scheme</p>
<div class="math" id="equation-sec:de:model:osc2:ud">
<span id="eq-sec-de-model-osc2-ud"></span><span class="eqno">(28)</span>\[     u^{n+1} = u^n + \Delta t\,v^n,\]</div>
<div class="math" id="equation-sec:de:model:osc2:vd">
<span id="eq-sec-de-model-osc2-vd"></span><span class="eqno">(29)</span>\[     v^{n+1} = v^n -\Delta t\,\omega^2 u^n\thinspace .\]</div>
</div>
<div class="section" id="programming-the-numerical-method-the-special-case-2">
<span id="sec-de-vib-special"></span><h3>Programming the numerical method; the special case  (2)<a class="headerlink" href="#programming-the-numerical-method-the-special-case-2" title="Permalink to this headline">¶</a></h3>
<p>A simple program for <a href="#equation-sec:de:model:osc2:ud">(28)</a>-<a href="#equation-sec:de:model:osc2:vd">(29)</a>
follows the same ideas as in the section <a class="reference internal" href="#sec-de-flu-prog-spec"><span>Programming the numerical method; the special case  (1)</span></a>:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="n">omega</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">P</span> <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="nb">pi</span><span class="o">/</span><span class="n">omega</span><span class="p">;</span>
<span class="n">dt</span> <span class="p">=</span> <span class="n">P</span><span class="o">/</span><span class="mi">20</span><span class="p">;</span>
<span class="n">T</span> <span class="p">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">P</span><span class="p">;</span>
<span class="n">N_t</span> <span class="p">=</span> <span class="nb">floor</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">);</span>
<span class="n">t</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_t</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

<span class="n">u</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">v</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

<span class="c">% Initial condition</span>
<span class="n">X_0</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">X_0</span><span class="p">;</span>
<span class="n">v</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c">% Step equations forward in time</span>
<span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N_t</span>
    <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">omega</span>^<span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="k">end</span>

<span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s">&#39;b-&#39;</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">X_0</span><span class="o">*</span><span class="nb">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">),</span> <span class="s">&#39;r--&#39;</span><span class="p">);</span>
<span class="n">legend</span><span class="p">(</span><span class="s">&#39;numerical&#39;</span><span class="p">,</span> <span class="s">&#39;exact&#39;</span><span class="p">,</span> <span class="s">&#39;Location&#39;</span><span class="p">,</span><span class="s">&#39;northwest&#39;</span><span class="p">);</span>
<span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">);</span>
<span class="n">print</span><span class="p">(</span><span class="s">&#39;tmp&#39;</span><span class="p">,</span> <span class="s">&#39;-dpdf&#39;</span><span class="p">);</span>  <span class="n">print</span><span class="p">(</span><span class="s">&#39;tmp&#39;</span><span class="p">,</span> <span class="s">&#39;-dpng&#39;</span><span class="p">);</span>
</pre></div>
</div>
<p>(See file <a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/osc_FE_special_case.m">osc_FE_special_case.m</a>.)</p>
<p>Since we already know the exact solution as <span class="math">\(u(t)=X_0\cos\omega
t\)</span>, we have reasoned as follows to find an appropriate simulation interval
<span class="math">\([0,T]\)</span> and also how many points we should choose.  The
solution has a period <span class="math">\(P=2\pi/\omega\)</span>. (The period <span class="math">\(P\)</span> is the time difference
between two peaks of the <span class="math">\(u(t)\sim\cos\omega t\)</span> curve.)
Simulating for three periods of
the cosine function, <span class="math">\(T=3P\)</span>, and choosing <span class="math">\(\Delta t\)</span> such that there
are 20 intervals per period gives <span class="math">\(\Delta t=P/20\)</span> and a total of
<span class="math">\(N_t=T/\Delta t\)</span> intervals. The rest of the program is a
straightforward coding of the Forward Euler scheme.</p>
<p>Figure <a class="reference internal" href="#sec-de-osc-fig1"><span>Simulation of an oscillating system</span></a> shows a comparison between the numerical
solution and the exact solution of the differential equation.
To our surprise, the numerical solution looks wrong. Is this
discrepancy due to a programming error or a problem with the Forward
Euler method?</p>
<div class="figure" id="id19">
<span id="sec-de-osc-fig1"></span><a class="reference internal image-reference" href="_images/osc_FE_20pp.png"><img alt="_images/osc_FE_20pp.png" src="_images/osc_FE_20pp.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Simulation of an oscillating system</em></span></p>
</div>
<p>First of all, even before trying to run the program, you should sit down and
compute two steps in the time loop with a calculator so you have some
intermediate results to compare with. Using <span class="math">\(X_0=2\)</span>, <span class="math">\(dt=0.157079632679\)</span>,
and <span class="math">\(\omega=2\)</span>, we get <span class="math">\(u^1=2\)</span>, <span class="math">\(v^1=-1.25663706\)</span>, <span class="math">\(u^2=1.80260791\)</span>,
and <span class="math">\(v^2=-2.51327412\)</span>. Such calculations show that
the program is seemingly correct. (Later, we can use such values to
construct a unit test and a corresponding test function.)</p>
<p>The next step is to reduce the discretization parameter
<span class="math">\(\Delta t\)</span> and see if the results become more accurate.
Figure <a class="reference internal" href="#sec-de-osc-fig2"><span>Simulation of an oscillating system with different time steps. Upper left: 40 steps per oscillation period. Upper right: 160 steps per period. Lower left: 2000 steps per period. Lower right: 2000 steps per period, but longer simulation</span></a> shows the numerical and exact solution for
the cases <span class="math">\(\Delta t = P/40, P/160, P/2000\)</span>. The results clearly become
better, and the finest resolution gives graphs that cannot be visually
distinguished. Nevertheless, the finest resolution involves 6000
computational intervals in total, which is considered quite much.
This is no problem on a modern laptop, however, as the computations take just
a fraction of a second.</p>
<div class="figure" id="id20">
<span id="sec-de-osc-fig2"></span><a class="reference internal image-reference" href="_images/osc_FE_3dt.png"><img alt="_images/osc_FE_3dt.png" src="_images/osc_FE_3dt.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Simulation of an oscillating system with different time steps. Upper left: 40 steps per oscillation period. Upper right: 160 steps per period. Lower left: 2000 steps per period. Lower right: 2000 steps per period, but longer simulation</em></span></p>
</div>
<p>Although 2000 intervals per oscillation period seem sufficient for an
accurate numerical solution, the lower right graph in Figure <a class="reference internal" href="#sec-de-osc-fig2"><span>Simulation of an oscillating system with different time steps. Upper left: 40 steps per oscillation period. Upper right: 160 steps per period. Lower left: 2000 steps per period. Lower right: 2000 steps per period, but longer simulation</span></a> shows that if we increase the simulation time, here to 20 periods, there is
a little growth of the amplitude, which becomes significant over time.
The conclusion is that the Forward Euler method has a fundamental problem with
its growing amplitudes, and that very small <span class="math">\(\Delta t\)</span> is required to
achieve satisfactory results. The longer the simulation is, the smaller
<span class="math">\(\Delta t\)</span> has to be. It is certainly time to look for more effective
numerical methods!</p>
</div>
<div class="section" id="a-magic-fix-of-the-numerical-method">
<h3>A magic fix of the numerical method<a class="headerlink" href="#a-magic-fix-of-the-numerical-method" title="Permalink to this headline">¶</a></h3>
<p>In the Forward Euler scheme,</p>
<div class="math">
\[\begin{split}u^{n+1} &amp;= u^n + \Delta t\,v^n,\\
v^{n+1} &amp;= v^n -\Delta t\,\omega^2 u^n,\end{split}\]</div>
<p>we can replace <span class="math">\(u^n\)</span> in the last equation by the recently computed value
<span class="math">\(u^{n+1}\)</span> from the first equation:</p>
<div class="math" id="equation-sec:de:model:osc2:fb:ud">
<span id="eq-sec-de-model-osc2-fb-ud"></span><span class="eqno">(30)</span>\[     u^{n+1} = u^n + \Delta t\,v^n,\]</div>
<div class="math" id="equation-sec:de:model:osc2:fb:vd">
<span id="eq-sec-de-model-osc2-fb-vd"></span><span class="eqno">(31)</span>\[     v^{n+1} = v^n -\Delta t\,\omega^2 u^{n+1}\thinspace .\]</div>
<p>Before justifying this fix more mathematically, let us try it on the
previous example. The results appear in Figure <a class="reference internal" href="#sec-de-osc-fig3"><span>Adjusted method: first four periods (left) and period 36-40 (right)</span></a>.
We see that the amplitude <em>does not grow</em>, but the phase is not
entirely correct. After 40 periods (Figure <a class="reference internal" href="#sec-de-osc-fig3"><span>Adjusted method: first four periods (left) and period 36-40 (right)</span></a> right)
we see a significant difference between the numerical and the exact solution.
Decreasing <span class="math">\(\Delta t\)</span> decreases the error. For example, with 2000 intervals per
period, we only see a small phase error even after 50,000 periods (!).
We can safely conclude that the fix results in an excellent numerical method!</p>
<div class="figure" id="id21">
<span id="sec-de-osc-fig3"></span><a class="reference internal image-reference" href="_images/osc2.png"><img alt="_images/osc2.png" src="_images/osc2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Adjusted method: first four periods (left) and period 36-40 (right)</em></span></p>
</div>
<p>Let us interpret the adjusted scheme mathematically. First we order
<a href="#equation-sec:de:model:osc2:fb:ud">(30)</a>-<a href="#equation-sec:de:model:osc2:fb:vd">(31)</a>
such that the difference approximations to derivatives become
transparent:</p>
<div class="math" id="equation-sec:de:model:osc2:fb:ud2">
<span id="eq-sec-de-model-osc2-fb-ud2"></span><span class="eqno">(32)</span>\[     \frac{u^{n+1} - u^n}{\Delta t} = v^n,\]</div>
<div class="math" id="equation-sec:de:model:osc2:fb:vd2">
<span id="eq-sec-de-model-osc2-fb-vd2"></span><span class="eqno">(33)</span>\[     \frac{v^{n+1} - v^n}{\Delta t} = -\omega^2 u^{n+1}\thinspace .\]</div>
<p>We interpret <a href="#equation-sec:de:model:osc2:fb:ud2">(32)</a> as the
differential equation sampled at mesh point <span class="math">\(t_n\)</span>, because
we have <span class="math">\(v^n\)</span> on the right-hand side.
The left-hand side is then a <em>forward difference</em> or Forward Euler
approximation to the derivative <span class="math">\(u'\)</span>, see Figure <a class="reference internal" href="#sec-de-fig-fe"><span>Illustration of a forward difference approximation to the derivative</span></a>.
On the other hand, we interpret <a href="#equation-sec:de:model:osc2:fb:vd2">(33)</a>
as the differential equation sampled at mesh point <span class="math">\(t_{n+1}\)</span>,
since we have <span class="math">\(u^{n+1}\)</span> on the right-hand side. In this case,
the difference approximation on the left-hand side is
a <em>backward difference</em>,</p>
<div class="math">
\[v'(t_{n+1}) \approx \frac{v^{n+1} - v^n}{\Delta t}\quad\hbox{ or }\quad
v'(t_{n}) \approx \frac{v^{n} - v^{n-1}}{\Delta t}\thinspace .\]</div>
<p>Figure <a class="reference internal" href="#sec-de-fig-be"><span>Illustration of a backward difference approximation to the derivative</span></a> illustrates the backward difference.
The accuracy of the backward difference is <span class="math">\({\mathcal{O}(\Delta t)}\)</span>, the
same as for the forward difference (but the proportionality constant
in the error term has different sign).
The resulting discretization method for <a href="#equation-sec:de:model:osc2:fb:vd2">(33)</a>
is often referred to as a Backward Euler scheme.</p>
<div class="figure" id="id22">
<span id="sec-de-fig-be"></span><a class="reference internal image-reference" href="_images/fd_backward.png"><img alt="_images/fd_backward.png" src="_images/fd_backward.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of a backward difference approximation to the derivative</em></span></p>
</div>
<p>To summarize, using a forward difference for the first equation and a
backward difference for the second equation results in a much
better method than just using forward differences in both equations.</p>
<p>The standard way of expressing this scheme in physics is to
change the order of the equations,</p>
<div class="math" id="equation-sec:de:model:osc2:v2">
<span id="eq-sec-de-model-osc2-v2"></span><span class="eqno">(34)</span>\[     v' = -\omega^2 u,\]</div>
<div class="math" id="equation-sec:de:model:osc2:u2">
<span id="eq-sec-de-model-osc2-u2"></span><span class="eqno">(35)</span>\[     u' = v,\]</div>
<p>and apply a forward difference to <a href="#equation-sec:de:model:osc2:v2">(34)</a>
and a backward difference to <a href="#equation-sec:de:model:osc2:u2">(35)</a>:</p>
<div class="math" id="equation-sec:de:model:osc2:fb:vd3">
<span id="eq-sec-de-model-osc2-fb-vd3"></span><span class="eqno">(36)</span>\[     v^{n+1} = v^n -\Delta t\,\omega^2 u^{n},\]</div>
<div class="math" id="equation-sec:de:model:osc2:fb:ud3">
<span id="eq-sec-de-model-osc2-fb-ud3"></span><span class="eqno">(37)</span>\[     u^{n+1} = u^n + \Delta t\,v^{n+1}\thinspace .\]</div>
<p>That is, first the velocity <span class="math">\(v\)</span> is updated and then the position <span class="math">\(u\)</span>,
using the most recently computed velocity.
There is no difference between
<a href="#equation-sec:de:model:osc2:fb:vd3">(36)</a>-<a href="#equation-sec:de:model:osc2:fb:ud3">(37)</a>
and
<a href="#equation-sec:de:model:osc2:fb:ud">(30)</a>-<a href="#equation-sec:de:model:osc2:fb:vd">(31)</a>
with respect to accuracy, so the order of the original differential
equations does not matter.
The scheme <a href="#equation-sec:de:model:osc2:fb:vd3">(36)</a>-<a href="#equation-sec:de:model:osc2:fb:ud3">(37)</a>
goes under the names <a class="reference external" href="http://en.wikipedia.org/wiki/Semi-implicit_Euler_method">Semi-implicit Euler</a> or Euler-Cromer.
The implementation of
<a href="#equation-sec:de:model:osc2:fb:vd3">(36)</a>-<a href="#equation-sec:de:model:osc2:fb:ud3">(37)</a>
is found in the file <code class="docutils literal"><span class="pre">osc_EC.m</span></code>. The core of the code goes like</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="n">u</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">v</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="c">% Initial condition</span>
<span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">v</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c">% Step equations forward in time</span>
<span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="n">N_t</span>
    <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="o">*</span><span class="n">omega</span>^<span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="section" id="the-2nd-order-runge-kutta-method-or-heun-s-method">
<span id="sec-de-osc-heun"></span><h3>The 2nd-order Runge-Kutta method (or Heun&#8217;s method)<a class="headerlink" href="#the-2nd-order-runge-kutta-method-or-heun-s-method" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-12"></span><span class="target" id="index-13"></span><span class="target" id="index-14"></span><p id="index-15">A very popular method for solving scalar and vector ODEs of first
order is the 2nd-order Runge-Kutta method (RK2), also known as Heun&#8217;s method.
The idea, first thinking of a scalar ODE, is to form a <em>centered difference</em>
approximation to the derivative between two time steps:</p>
<div class="math">
\[u'(t_n+\frac{1}{2}\Delta t)\approx \frac{u^{n+1}-u^n}{\Delta t}\thinspace .\]</div>
<p>The centered difference formula is visualized in Figure <a class="reference internal" href="#sec-de-fig-cn"><span>Illustration of a centered difference approximation to the derivative</span></a>.
The accuracy of the centered difference is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, one order
higher than the forward and backward differences.</p>
<div class="figure" id="id23">
<span id="sec-de-fig-cn"></span><a class="reference internal image-reference" href="_images/fd_centered_CN.png"><img alt="_images/fd_centered_CN.png" src="_images/fd_centered_CN.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of a centered difference approximation to the derivative</em></span></p>
</div>
<p>The problem with such a centered scheme for the general ODE <span class="math">\(u'=f(u,t)\)</span> is
that we get</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} = f(u^{n+\frac{1}{2}},t_{n+\frac{1}{2}}),\]</div>
<p>which leads to difficulties since we do not know what <span class="math">\(u^{n+\frac{1}{2}}\)</span>
is. However, we can approximate the value of <span class="math">\(f\)</span> between two time
levels by the arithmetic average of the values at <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>:</p>
<div class="math">
\[f(u^{n+\frac{1}{2}},t_{n+\frac{1}{2}}) \approx
\frac{1}{2}(f(u^n, t_n) + f(u^{n+1}, t_{n+1}))\thinspace .\]</div>
<p>This results in</p>
<div class="math">
\[\frac{u^{n+1}-u^n}{\Delta t} =
\frac{1}{2}(f(u^n, t_n) + f(u^{n+1}, t_{n+1})),\]</div>
<p>which in general is a <em>nonlinear algebraic equation</em> for <span class="math">\(u^{n+1}\)</span>
if <span class="math">\(f(u,t)\)</span> is not a linear function of <span class="math">\(u\)</span>. To deal with the unknown term
<span class="math">\(f(u^{n+1}, t_{n+1})\)</span>, without solving nonlinear equations,
we can approximate or predict <span class="math">\(u^{n+1}\)</span>
using a Forward Euler step:</p>
<div class="math">
\[u^{n+1} = u^n + \Delta tf(u^n,t_n)\thinspace .\]</div>
<p>This reasoning gives rise to the method</p>
<div class="math">
\[u^* = u^n + \Delta tf(u^n,t_n),\]</div>
<div class="math">
\[u^{n+1} = u^n + \frac{\Delta t}{2}(
f(u^n,t_n) + f(u^{*},t_{n+1})\thinspace .\]</div>
<p>The scheme applies to both scalar and vector ODEs.</p>
<p>For an oscillating system with <span class="math">\(f=(v,-\omega^2u)\)</span> the file
<code class="docutils literal"><span class="pre">osc_Heun.m</span></code> implements this method.
The demo script <code class="docutils literal"><span class="pre">demo_osc_Heun.m</span></code> runs the simulation for 10 periods
with 20 time steps per period.
The corresponding numerical and exact solution are shown
in Figure <a class="reference internal" href="#sec-de-osc-fig-heun"><span>Simulation of 10 periods of oscillations by Heun&#8217;s method</span></a>. We see that the amplitude grows,
but not as much as for the Forward Euler method. However, the
Euler-Cromer method is much better!</p>
<div class="figure" id="id24">
<span id="sec-de-osc-fig-heun"></span><a class="reference internal image-reference" href="_images/osc_Heun.png"><img alt="_images/osc_Heun.png" src="_images/osc_Heun.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Simulation of 10 periods of oscillations by Heun&#8217;s method</em></span></p>
</div>
<p>We should add that in problems where the Forward Euler method gives
satisfactory approximations, such as growth/decay problems or
the SIR model, the 2nd-order Runge-Kutta method or
Heun&#8217;s method, usually works considerably better and produces
greater accuracy for the same computational cost. It is therefore
a very valuable method to be aware of, although it cannot compete
with the Euler-Cromer scheme for oscillation problems.
The derivation of the RK2/Heun scheme is also good general training in
&#8220;numerical thinking&#8221;.</p>
</div>
<div class="section" id="odespy-software-for-solving-odes">
<span id="sec-de-osc-odespy"></span><h3>Odespy: software for solving ODEs<a class="headerlink" href="#odespy-software-for-solving-odes" title="Permalink to this headline">¶</a></h3>
<p>There is a jungle of methods for solving ODEs, and it would be nice to
have easy access to implementations of a wide range of methods,
especially the sophisticated
and complicated <em>adaptive</em> methods that adjusts <span class="math">\(\Delta t\)</span> automatically
to obtain a prescribed accuracy. The Python package
<a class="reference external" href="https://github.com/hplgit/odespy">Odespy</a> gives easy access to a lot
of numerical methods for ODEs.</p>
<p>The simplest possible example on
using Odespy is to
solve <span class="math">\(u'=u\)</span>, <span class="math">\(u(0)=2\)</span>, for 100 time steps until <span class="math">\(t=4\)</span>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">u</span>

<span class="n">method</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">Heun</span>   <span class="c"># or, e.g., odespy.ForwardEuler</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">101</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, you define your right-hand side function <code class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t)</span></code>,
initialize an Odespy <code class="docutils literal"><span class="pre">solver</span></code> object, set the initial condition,
compute a collection of time points where you want the solution,
and ask for the solution. The returned arrays <code class="docutils literal"><span class="pre">u</span></code> and <code class="docutils literal"><span class="pre">t</span></code> can be
plotted directly: <code class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u</span></code>).</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Note that Odespy <em>must</em> be operated from Python, so you need to
learn some basic Python to make use of this software.
The type of Python programming you need to learn has a syntax very
close to that of Matlab.</p>
</div>
<p>A nice feature of Odespy is that problem parameters can be
arguments to the user&#8217;s <code class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t)</span></code> function. For example,
if our ODE problem is <span class="math">\(u'=-au+b\)</span>, with two problem parameters
<span class="math">\(a\)</span> and <span class="math">\(b\)</span>, we may write our <code class="docutils literal"><span class="pre">f</span></code> function as</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">b</span>
</pre></div>
</div>
<p>The extra, problem-dependent arguments <code class="docutils literal"><span class="pre">a</span></code> and <code class="docutils literal"><span class="pre">b</span></code> can be transferred
to this function
if we collect their values in a list or tuple
when creating the Odespy solver and use the <code class="docutils literal"><span class="pre">f_args</span></code> argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f_args</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
</pre></div>
</div>
<p>This is a good feature because problem parameters must otherwise be
global variables - now they can be arguments in our right-hand side
function in a natural way. <a class="reference internal" href="#sec-de-exer-odespy-decay"><span>Exercise 58: Use Odespy to solve a simple ODE</span></a> asks
you to make a complete implementation of this problem and plot the
solution.</p>
<p>Using Odespy to solve oscillation ODEs like <span class="math">\(u''+\omega^2u=0\)</span>,
reformulated as a system <span class="math">\(u'=v\)</span> and <span class="math">\(v'=-\omega^2u\)</span>, is done
as follows. We specify
a given number of time steps per period and compute the
associated time steps and end time of the simulation (<code class="docutils literal"><span class="pre">T</span></code>),
given a number of periods to simulate:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>

<span class="c"># Define the ODE system</span>
<span class="c"># u&#39; = v</span>
<span class="c"># v&#39; = -omega**2*u</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">sol</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">]</span>

<span class="c"># Set and compute problem dependent parameters</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">X_0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">number_of_periods</span> <span class="o">=</span> <span class="mi">40</span>
<span class="n">time_intervals_per_period</span> <span class="o">=</span> <span class="mi">20</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">cos</span>
<span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span>                      <span class="c"># length of one period</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">time_intervals_per_period</span>    <span class="c"># time step</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">number_of_periods</span><span class="o">*</span><span class="n">P</span>             <span class="c"># final simulation time</span>

<span class="c"># Create Odespy solver object</span>
<span class="n">odespy_method</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RK2</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">odespy_method</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f_args</span><span class="o">=</span><span class="p">[</span><span class="n">omega</span><span class="p">])</span>

<span class="c"># The initial condition for the system is collected in a list</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="n">X_0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

<span class="c"># Compute the desired time points where we want the solution</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>              <span class="c"># no of time intervals</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># Solve the ODE problem</span>
<span class="n">sol</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="c"># Note: sol contains both displacement and velocity</span>
<span class="c"># Extract original variables</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>The last two statements are important since our two functions <span class="math">\(u\)</span> and <span class="math">\(v\)</span>
in the ODE system are packed together in one array inside the Odespy solver.
The solution of the ODE system
is returned as a two-dimensional array where the first
column (<code class="docutils literal"><span class="pre">sol[:,0]</span></code>) stores <span class="math">\(u\)</span> and the second (<code class="docutils literal"><span class="pre">sol[:,1]</span></code>) stores <span class="math">\(v\)</span>.
Plotting <span class="math">\(u\)</span> and <span class="math">\(v\)</span> is a matter of running <code class="docutils literal"><span class="pre">plot(t,</span> <span class="pre">u,</span> <span class="pre">t,</span> <span class="pre">v)</span></code>.</p>
<div class="admonition-remark admonition">
<p class="first admonition-title">Remark</p>
<p>In the right-hand side function we write <code class="docutils literal"><span class="pre">f(sol,</span> <span class="pre">t,</span> <span class="pre">omega)</span></code> instead
of <code class="docutils literal"><span class="pre">f(u,</span> <span class="pre">t,</span> <span class="pre">omega)</span></code> to indicate that the solution sent to <code class="docutils literal"><span class="pre">f</span></code>
is a solution at time <code class="docutils literal"><span class="pre">t</span></code> where the values of <span class="math">\(u\)</span> and <span class="math">\(v\)</span> are
packed together: <code class="docutils literal"><span class="pre">sol</span> <span class="pre">=</span> <span class="pre">[u,</span> <span class="pre">v]</span></code>. We might well use <code class="docutils literal"><span class="pre">u</span></code> as argument:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="o">-</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">]</span>
</pre></div>
</div>
<p class="last">This just means that we redefine the name <code class="docutils literal"><span class="pre">u</span></code> inside the function
to mean the solution at time <code class="docutils literal"><span class="pre">t</span></code> for the first component of
the ODE system.</p>
</div>
<p>To switch to another numerical method, just substitute <code class="docutils literal"><span class="pre">RK2</span></code> by
the proper name of the desired method.
Typing <code class="docutils literal"><span class="pre">pydoc</span> <span class="pre">odespy</span></code> in the terminal window brings up a list
of all the implemented methods.
This very simple way of choosing a method suggests an obvious extension
of the code above: we can define a list of methods, run all
methods, and compare their <span class="math">\(u\)</span> curves in a plot.
As Odespy also contains the Euler-Cromer scheme, we rewrite
the system with <span class="math">\(v'=-\omega^2u\)</span> as the first ODE and <span class="math">\(u'=v\)</span>
as the second ODE, because this is the standard choice when
using the Euler-Cromer method (also in Odespy):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">return</span> <span class="p">[</span><span class="o">-</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>
</pre></div>
</div>
<p>This change of equations also affects the initial condition:
the first component is zero and second is <code class="docutils literal"><span class="pre">X_0</span></code> so we need
to pass the list <code class="docutils literal"><span class="pre">[0,</span> <span class="pre">X_0]</span></code> to <code class="docutils literal"><span class="pre">solver.set_initial_condition</span></code>.</p>
<p>The code
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/ode_odespy.m">ode_odespy.m</a>
contains the details:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">odespy_methods</span><span class="p">,</span>
            <span class="n">omega</span><span class="p">,</span>
            <span class="n">X_0</span><span class="p">,</span>
            <span class="n">number_of_periods</span><span class="p">,</span>
            <span class="n">time_intervals_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>

    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">cos</span>
    <span class="n">P</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">omega</span>                      <span class="c"># length of one period</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">P</span><span class="o">/</span><span class="n">time_intervals_per_period</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">number_of_periods</span><span class="o">*</span><span class="n">P</span>

    <span class="c"># If odespy_methods is not a list, but just the name of</span>
    <span class="c"># a single Odespy solver, we wrap that name in a list</span>
    <span class="c"># so we always have odespy_methods as a list</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">odespy_methods</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">([]):</span>
        <span class="n">odespy_methods</span> <span class="o">=</span> <span class="p">[</span><span class="n">odespy_methods</span><span class="p">]</span>

    <span class="c"># Make a list of solver objects</span>
    <span class="n">solvers</span> <span class="o">=</span> <span class="p">[</span><span class="n">method</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f_args</span><span class="o">=</span><span class="p">[</span><span class="n">omega</span><span class="p">])</span> <span class="k">for</span> <span class="n">method</span> <span class="ow">in</span>
               <span class="n">odespy_methods</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">X_0</span><span class="p">])</span>

    <span class="c"># Compute the time points where we want the solution</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>  <span class="c"># avoid integer division</span>
    <span class="n">N_t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">))</span>
    <span class="n">time_points</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_t</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">legends</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">solver</span> <span class="ow">in</span> <span class="n">solvers</span><span class="p">:</span>
        <span class="n">sol</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">sol</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># Plot only the last p periods</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">time_intervals_per_period</span>  <span class="c"># no time steps to plot</span>
        <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">:],</span> <span class="n">u</span><span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">:])</span>
        <span class="n">hold</span><span class="p">(</span><span class="s">&#39;on&#39;</span><span class="p">)</span>
        <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">name</span><span class="p">())</span>
        <span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;t&#39;</span><span class="p">)</span>
    <span class="c"># Plot exact solution too</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">:],</span> <span class="n">X_0</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="o">*</span><span class="n">t</span><span class="p">)[</span><span class="o">-</span><span class="n">m</span><span class="p">:],</span> <span class="s">&#39;k--&#39;</span><span class="p">)</span>
    <span class="n">legends</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;exact&#39;</span><span class="p">)</span>
    <span class="n">legend</span><span class="p">(</span><span class="n">legends</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s">&#39;lower left&#39;</span><span class="p">)</span>
    <span class="n">axis</span><span class="p">([</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="n">m</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">X_0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">X_0</span><span class="p">])</span>
    <span class="n">title</span><span class="p">(</span><span class="s">&#39;Simulation of </span><span class="si">%d</span><span class="s"> periods with </span><span class="si">%d</span><span class="s"> intervals per period&#39;</span>
          <span class="o">%</span> <span class="p">(</span><span class="n">number_of_periods</span><span class="p">,</span> <span class="n">time_intervals_per_period</span><span class="p">))</span>
    <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.pdf&#39;</span><span class="p">);</span> <span class="n">savefig</span><span class="p">(</span><span class="s">&#39;tmp.png&#39;</span><span class="p">)</span>
    <span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>A new feature in this code is the ability to plot only the last <code class="docutils literal"><span class="pre">p</span></code>
periods, which allows us to perform long time simulations and
watch the end results without a cluttered plot with too many
periods. The syntax <code class="docutils literal"><span class="pre">t[-m:]</span></code> plots the last <code class="docutils literal"><span class="pre">m</span></code> elements in <code class="docutils literal"><span class="pre">t</span></code> (a
negative index in Python arrays/lists counts from the end).</p>
<p>We may compare Heun&#8217;s method (or equivalently the RK2
method) with the Euler-Cromer scheme:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">compare</span><span class="p">(</span><span class="n">odespy_methods</span><span class="o">=</span><span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">Heun</span><span class="p">,</span> <span class="n">odespy</span><span class="o">.</span><span class="n">EulerCromer</span><span class="p">],</span>
        <span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">X_0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">number_of_periods</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
        <span class="n">time_intervals_per_period</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
</pre></div>
</div>
<p>Figure <a class="reference internal" href="#sec-de-osc-fig-heun-vs-ec"><span>Illustration of the impact of resolution (time steps per period) and length of simulation</span></a> shows how Heun&#8217;s method
(the blue line with small disks)
has considerable error in both amplitude and phase already
after 14-20 periods (upper left), but using three times as
many time steps makes the curves almost equal (upper right).
However, after 194-200 periods the errors have grown (lower left),
but can be sufficiently reduced by halving the time step (lower right).</p>
<div class="figure" id="id25">
<span id="sec-de-osc-fig-heun-vs-ec"></span><a class="reference internal image-reference" href="_images/osc_odespy_Heun_vs_EC.png"><img alt="_images/osc_odespy_Heun_vs_EC.png" src="_images/osc_odespy_Heun_vs_EC.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Illustration of the impact of resolution (time steps per period) and length of simulation</em></span></p>
</div>
<p>With all the methods in Odespy at hand, it is now easy to start
exploring other methods, such as backward differences
instead of the forward differences used in the Forward Euler scheme.
<a class="reference internal" href="#sec-de-exer-osc-be"><span>Exercise 59: Set up a Backward Euler scheme for oscillations</span></a> addresses that problem.</p>
<p>Odespy contains quite sophisticated adaptive methods where the user is
&#8220;guaranteed&#8221; to get a solution with prescribed accuracy. There is
no mathematical guarantee, but the error will for most cases not
deviate significantly from the user&#8217;s tolerance that reflects the
accuracy. A very popular method of this type is the Runge-Kutta-Fehlberg method,
which runs a 4th-order Runge-Kutta method and uses a 5th-order
Runge-Kutta method to estimate the error so that <span class="math">\(\Delta t\)</span> can
be adjusted to keep the error below a tolerance. This method is
also widely known as <code class="docutils literal"><span class="pre">ode45</span></code>, because that is the name of the function
implementing the method in Matlab.
We can easily test the Runge-Kutta-Fehlberg method as soon as we
know the corresponding Odespy name, which is <code class="docutils literal"><span class="pre">RKFehlberg</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">compare</span><span class="p">(</span><span class="n">odespy_methods</span><span class="o">=</span><span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">EulerCromer</span><span class="p">,</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RKFehlberg</span><span class="p">],</span>
        <span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">X_0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">number_of_periods</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span>
        <span class="n">time_intervals_per_period</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that the <code class="docutils literal"><span class="pre">time_intervals_per_period</span></code> argument refers to the
time points where we want the solution. These points are also the ones
used for numerical computations in the
<code class="docutils literal"><span class="pre">odespy.EulerCromer</span></code> solver,
while the <code class="docutils literal"><span class="pre">odespy.RKFehlberg</span></code> solver will use an unknown set of
time points since the time intervals are adjusted as the method runs.
One can easily look at the points actually used by the method
as these are available as an array <code class="docutils literal"><span class="pre">solver.t_all</span></code> (but plotting or
examining the points requires modifications inside the <code class="docutils literal"><span class="pre">compare</span></code> method).</p>
<p>Figure <a class="reference internal" href="#sec-de-osc-fig-rkf-vs-ec"><span>Comparison of the Runge-Kutta-Fehlberg adaptive method against the Euler-Cromer scheme for a long time simulation (200 periods)</span></a> shows a computational example
where the Runge-Kutta-Fehlberg method is clearly superior to the
Euler-Cromer scheme in long time simulations, but the comparison is
not really fair because the Runge-Kutta-Fehlberg method applies about
twice as many time steps in this computation and performs much more
work per time step. It is quite a complicated task to compare two so
different methods in a fair way so that the computational work versus
accuracy is scientifically well reported.</p>
<div class="figure" id="id26">
<span id="sec-de-osc-fig-rkf-vs-ec"></span><a class="reference internal image-reference" href="_images/osc_odespy_RKF_vs_EC.png"><img alt="_images/osc_odespy_RKF_vs_EC.png" src="_images/osc_odespy_RKF_vs_EC.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Comparison of the Runge-Kutta-Fehlberg adaptive method against the Euler-Cromer scheme for a long time simulation (200 periods)</em></span></p>
</div>
</div>
<div class="section" id="the-4th-order-runge-kutta-method">
<h3>The 4th-order Runge-Kutta method<a class="headerlink" href="#the-4th-order-runge-kutta-method" title="Permalink to this headline">¶</a></h3>
<p>The 4th-order Runge-Kutta method (RK4) is clearly the most widely used method
to solve ODEs. Its power comes from high accuracy even with not so small
time steps.</p>
<div class="section" id="the-algorithm">
<h4>The algorithm<a class="headerlink" href="#the-algorithm" title="Permalink to this headline">¶</a></h4>
<p>We first just state the four-stage algorithm:</p>
<div class="math">
\[u^{n+1} = u^n +
\frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\frac{1}{2}}
+ 2\tilde{f}^{n+\frac{1}{2}} + \bar{f}^{n+1}\right),\]</div>
<p>where</p>
<div class="math">
\[\hat{f}^{n+\frac{1}{2}} =
f(u^n + \frac{1}{2}{\Delta t} f^n, t_{n+\frac{1}{2}}),\]</div>
<div class="math">
\[\tilde{f}^{n+\frac{1}{2}} =
f(u^n + \frac{1}{2}\Delta t\hat{f}^{n+\frac{1}{2}}, t_{n+\frac{1}{2}}),\]</div>
<div class="math">
\[\bar{f}^{n+1} =
f(u^n + \Delta t \hat{f}^{n+\frac{1}{2}}, t_{n+1})\thinspace .\]</div>
</div>
<div class="section" id="application">
<h4>Application<a class="headerlink" href="#application" title="Permalink to this headline">¶</a></h4>
<p>We can run the same simulation as in Figures <a class="reference internal" href="#sec-de-osc-fig1"><span>Simulation of an oscillating system</span></a>,
<a class="reference internal" href="#sec-de-osc-fig3"><span>Adjusted method: first four periods (left) and period 36-40 (right)</span></a>, and <a class="reference internal" href="#sec-de-osc-fig-heun"><span>Simulation of 10 periods of oscillations by Heun&#8217;s method</span></a>,
for 40 periods. The 10 last periods are shown in Figure <a class="reference internal" href="#sec-de-osc-fig-rk4"><span>The last 10 of 40 periods of oscillations by the 4th-order Runge-Kutta method</span></a>. The results look as impressive as those of the Euler-Cromer method.</p>
<div class="figure" id="id27">
<span id="sec-de-osc-fig-rk4"></span><a class="reference internal image-reference" href="_images/osc_RK4b.png"><img alt="_images/osc_RK4b.png" src="_images/osc_RK4b.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>The last 10 of 40 periods of oscillations by the 4th-order Runge-Kutta method</em></span></p>
</div>
</div>
<div class="section" id="implementation-5">
<h4>Implementation  (5)<a class="headerlink" href="#implementation-5" title="Permalink to this headline">¶</a></h4>
<p>The stages in the 4th-order Runge-Kutta method can easily be implemented
as a modification of the <code class="docutils literal"><span class="pre">osc_Heun.m</span></code> code.
Alternatively, one can use the <code class="docutils literal"><span class="pre">osc_odespy.py</span></code> code by just providing
the argument <code class="docutils literal"><span class="pre">odespy_methods=[odespy.RK4]</span></code> to the <code class="docutils literal"><span class="pre">compare</span></code> function.</p>
</div>
<div class="section" id="derivation">
<h4>Derivation<a class="headerlink" href="#derivation" title="Permalink to this headline">¶</a></h4>
<p>The derivation of the 4th-order Runge-Kutta method can be presented in
a pedagogical way that brings many fundamental elements of
numerical discretization techniques together and that illustrates
many aspects of &#8220;numerical thinking&#8221; when constructing approximate
solution methods.</p>
<p>We start with integrating the general ODE
<span class="math">\(u'=f(u,t)\)</span> over a time step, from <span class="math">\(t_n\)</span> to <span class="math">\(t_{n+1}\)</span>,</p>
<div class="math">
\[u(t_{n+1}) - u(t_n) = \int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt\thinspace .\]</div>
<p>The goal of the computation is <span class="math">\(u(t_{n+1})\)</span> (<span class="math">\(u^{n+1}\)</span>),
while <span class="math">\(u(t_n)\)</span> (<span class="math">\(u^n\)</span>) is the
most recently known value of <span class="math">\(u\)</span>.
The challenge with the integral is that the
integrand involves the unknown <span class="math">\(u\)</span> between <span class="math">\(t_n\)</span> and <span class="math">\(t_{n+1}\)</span>.</p>
<p>The integral can be approximated by the famous
<a class="reference external" href="http://en.wikipedia.org/wiki/Simpson's_rule">Simpson&#8217;s rule</a>:</p>
<div class="math">
\[\int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 4f^{n+\frac{1}{2}} + f^{n+1}\right)\thinspace .\]</div>
<p>The problem with this formula
is that we do not know <span class="math">\(f^{n+\frac{1}{2}}=f(u^{n+\frac{1}{2}},t_{n+\frac{1}{2}})\)</span>
and <span class="math">\(f^{n+1}=(u^{n+1},t_{n+1})\)</span> as only <span class="math">\(u^n\)</span> is available and
only <span class="math">\(f^n\)</span> can then readily be computed.</p>
<p>To proceed, the idea is to use various approximations for <span class="math">\(f^{n+\frac{1}{2}}\)</span> and
<span class="math">\(f^{n+1}\)</span> based on using well-known schemes for the ODE in the
intervals <span class="math">\([t_n,t_{n+\frac{1}{2}}]\)</span> and <span class="math">\([t_n, t_{n+1}]\)</span>.
Let us split the integral into four terms:</p>
<div class="math">
\[\int\limits_{t_{n}}^{t_{n+1}} f(u(t),t)dt
\approx \frac{\Delta t}{6}\left( f^n + 2\hat{f}^{n+\frac{1}{2}}
+ 2\tilde{f}^{n+\frac{1}{2}} + \bar{f}^{n+1}\right),\]</div>
<p>where <span class="math">\(\hat{f}^{n+\frac{1}{2}}\)</span>, <span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span>, and <span class="math">\(\bar{f}^{n+1}\)</span>
are approximations to <span class="math">\(f^{n+\frac{1}{2}}\)</span> and
<span class="math">\(f^{n+1}\)</span> that can utilize already computed quantities.
For <span class="math">\(\hat{f}^{n+\frac{1}{2}}\)</span> we can simply apply
an approximation to <span class="math">\(u^{n+\frac{1}{2}}\)</span> based on a Forward Euler
step of size <span class="math">\(\frac{1}{2}\Delta t\)</span>:</p>
<div class="math" id="equation-sec:de:vib:RK4:hatf">
<span id="eq-sec-de-vib-rk4-hatf"></span><span class="eqno">(38)</span>\[     \hat{f}^{n+\frac{1}{2}} = f(u^n + \frac{1}{2}{\Delta t} f^n, t_{n+\frac{1}{2}})\]</div>
<p>This formula provides a prediction of <span class="math">\(f^{n+\frac{1}{2}}\)</span>, so we can for
<span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span> try a Backward Euler method to approximate <span class="math">\(u^{n+\frac{1}{2}}\)</span>:</p>
<div class="math" id="equation-sec:de:vib:RK4:tildef">
<span id="eq-sec-de-vib-rk4-tildef"></span><span class="eqno">(39)</span>\[     \tilde{f}^{n+\frac{1}{2}} = f(u^n + \frac{1}{2}\Delta t\hat{f}^{n+\frac{1}{2}}, t_{n+\frac{1}{2}})\thinspace .\]</div>
<p>With <span class="math">\(\tilde{f}^{n+\frac{1}{2}}\)</span> as an approximation to
<span class="math">\(f^{n+\frac{1}{2}}\)</span>, we can for the final term <span class="math">\(\bar{f}^{n+1}\)</span> use
a midpoint method (or central difference, also called
a Crank-Nicolson method) to approximate <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-sec:de:vib:RK4:barf">
<span id="eq-sec-de-vib-rk4-barf"></span><span class="eqno">(40)</span>\[     \bar{f}^{n+1} = f(u^n + \Delta t \hat{f}^{n+\frac{1}{2}}, t_{n+1})\thinspace .\]</div>
<p>We have now used the Forward and Backward Euler methods as well as the
centered difference approximation in the context of Simpson&#8217;s rule. The hope is
that the combination of these methods yields an overall time-stepping
scheme from <span class="math">\(t_n\)</span> to <span class="math">\(t_n{+1}\)</span> that is much more accurate than the
<span class="math">\(\mathcal{O}(\Delta t)\)</span> and <span class="math">\(\mathcal{O}(\Delta t^2)\)</span> of the individual steps.
This is indeed true: the numerical error goes like
<span class="math">\(C\Delta t^4\)</span> for a constant <span class="math">\(C\)</span>, which means that the error
goes very quickly to zero as we reduce the time step size,
compared to the Forward Euler method (error <span class="math">\(\sim\Delta t^2\)</span>),
the Euler-Cromer method (error <span class="math">\(\sim\Delta t^2\)</span>) or
the 2nd-order Runge-Kutta, or Heun&#8217;s, method (error <span class="math">\(\sim\Delta t^2\)</span>).</p>
<p>Note that the 4th-order Runge-Kutta method is fully explicit so there
is never any need to solve linear or nonlinear algebraic equations,
regardless of what <span class="math">\(f\)</span> looks like.  However, the stability is
conditional and depends on <span class="math">\(f\)</span>.  There is a large family of <em>implicit</em>
Runge-Kutta methods that are unconditionally stable, but require
solution of algebraic equations involving <span class="math">\(f\)</span> at each time step.
The Odespy package has support for a lot of sophisticated <em>explicit</em>
Runge-Kutta methods, but not yet implicit Runge-Kutta methods.</p>
</div>
</div>
<div class="section" id="more-effects-damping-nonlinearity-and-external-forces">
<h3>More effects: damping, nonlinearity, and external forces<a class="headerlink" href="#more-effects-damping-nonlinearity-and-external-forces" title="Permalink to this headline">¶</a></h3>
<p>Our model problem <span class="math">\(u''+\omega^2u=0\)</span> is the simplest possible mathematical model
for oscillating systems. Nevertheless, this model makes strong demands
to numerical methods, as we have seen, and is very useful as a benchmark
for evaluating the performance of numerical methods.</p>
<p>Real-life applications involve more physical effects, which lead to a
differential equation with more terms and also more complicated
terms. Typically, one has a
damping force <span class="math">\(f(u')\)</span> and a spring
force <span class="math">\(s(u)\)</span>. Both these forces may depend nonlinearly on their
argument, <span class="math">\(u'\)</span> or <span class="math">\(u\)</span>. In addition, environmental forces <span class="math">\(F(t)\)</span> may
act on the system. For example, the classical pendulum has
a nonlinear &#8220;spring&#8221; or restoring force <span class="math">\(s(u)\sim \sin(u)\)</span>, and
air resistance on the pendulum leads to a damping force
<span class="math">\(f(u')\sim |u'|u'\)</span>. Examples on environmental forces include
shaking of the ground (e.g., due to an earthquake) as well as forces
from waves and wind.</p>
<p>With three types of forces on the system: <span class="math">\(F\)</span>, <span class="math">\(f\)</span>, and <span class="math">\(s\)</span>,
the sum of forces is written <span class="math">\(F(t) - f(u') - s(u)\)</span>. Note
the minus sign in
front of <span class="math">\(f\)</span> and <span class="math">\(s\)</span>, which indicates that these functions are defined such that
they represent forces acting <em>against</em> the motion.  For example,
springs attached to the wheels in a car are combined with effective
dampers, each providing a damping force <span class="math">\(f(u')=bu'\)</span> that acts against the spring
velocity <span class="math">\(u'\)</span>. The corresponding physical force is then <span class="math">\(-f\)</span>:
<span class="math">\(-bu'\)</span> points downwards when the spring is being stretched and <span class="math">\(u'\)</span> points
upwards, and <span class="math">\(-f\)</span> acts upwards when the spring is being compressed and
<span class="math">\(u'\)</span> points downwards.</p>
<p>Figure <a class="reference internal" href="#sec-de-ode2-fig1"><span>General oscillating system</span></a> shows an example of a mass <span class="math">\(m\)</span> attached to
a potentially nonlinear spring and dashpot, and subject to an environmental
force <span class="math">\(F(t)\)</span>. Nevertheless, our general model can equally well be
a pendulum as in Figure <a class="reference internal" href="#sec-de-ode2-fig2"><span>A pendulum with forces</span></a> with <span class="math">\(s(u)=mg\sin\theta\)</span> and
<span class="math">\(f(\dot u) =\frac{1}{2}C_D A\varrho \dot\theta |\dot\theta|\)</span> (where
<span class="math">\(C_D=0.4\)</span>, <span class="math">\(A\)</span> is the cross sectional area of the body, and <span class="math">\(\varrho\)</span> is
the density of air).</p>
<div class="figure" id="id28">
<span id="sec-de-ode2-fig1"></span><a class="reference internal image-reference" href="_images/oscillator_general.png"><img alt="_images/oscillator_general.png" src="_images/oscillator_general.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>General oscillating system</em></span></p>
</div>
<div class="figure" id="id29">
<span id="sec-de-ode2-fig2"></span><a class="reference internal image-reference" href="_images/pendulum_body_diagram3.png"><img alt="_images/pendulum_body_diagram3.png" src="_images/pendulum_body_diagram3.png" style="width: 300px;" /></a>
<p class="caption"><span class="caption-text"><em>A pendulum with forces</em></span></p>
</div>
<p>Newton&#8217;s second law for the system can be written with the mass times
acceleration on the left-hand side and the forces on the right-hand side:</p>
<div class="math">
\[mu'' = F(t) - f(u') - s(u)\thinspace .\]</div>
<p>This equation is, however, more commonly reordered to</p>
<div class="math" id="equation-sec:de:vib:ode2">
<span id="eq-sec-de-vib-ode2"></span><span class="eqno">(41)</span>\[     mu'' + f(u') + s(u) = F(t)\thinspace .\]</div>
<p>Because the differential equation is of second order, due to the term <span class="math">\(u''\)</span>,
we need two initial conditions:</p>
<div class="math">
\[u(0)=U_0,\quad u'(0)=V_0\thinspace .\]</div>
<p>Note that with the choices <span class="math">\(f(u')=0\)</span>, <span class="math">\(s(u)=ku\)</span>, and <span class="math">\(F(t)=0\)</span>
we recover the original
ODE <span class="math">\(u'' +\omega^2u=0\)</span> with <span class="math">\(\omega=\sqrt{k/m}\)</span>.</p>
<p>How can we solve <a href="#equation-sec:de:vib:ode2">(41)</a>?
As for the simple ODE <span class="math">\(u''+\omega^2u=0\)</span>, we
start by rewriting the second-order ODE as a system of two
first-order ODEs:</p>
<div class="math" id="equation-sec:de:vib:ode2:v">
<span id="eq-sec-de-vib-ode2-v"></span><span class="eqno">(42)</span>\[     v' = \frac{1}{m}\left(F(t) - s(u) - f(v)\right),\]</div>
<div class="math" id="equation-sec:de:vib:ode2:u">
<span id="eq-sec-de-vib-ode2-u"></span><span class="eqno">(43)</span>\[     u' = v\thinspace .\]</div>
<p>The initial conditions become <span class="math">\(u(0)=U_0\)</span> and <span class="math">\(v(0)=V_0\)</span>.</p>
<p>Any method for a system of first-order ODEs can be used to solve for
<span class="math">\(u(t)\)</span> and <span class="math">\(v(t)\)</span>.</p>
<div class="section" id="the-euler-cromer-scheme">
<h4>The Euler-Cromer scheme<a class="headerlink" href="#the-euler-cromer-scheme" title="Permalink to this headline">¶</a></h4>
<p>An attractive choice from an implementational, accuracy, and
efficiency point of view is the Euler-Cromer scheme where we
take a forward difference in <a href="#equation-sec:de:vib:ode2:v">(42)</a> and
a backward difference in <a href="#equation-sec:de:vib:ode2:u">(43)</a>:</p>
<div class="math" id="equation-sec:de:vib:ode2:v:EC1">
<span id="eq-sec-de-vib-ode2-v-ec1"></span><span class="eqno">(44)</span>\[     \frac{v^{n+1}-v^n}{\Delta t} = \frac{1}{m}\left(F(t_n) - s(u^n) - f(v^n)\right),\]</div>
<div class="math" id="equation-sec:de:vib:ode2:u:EC1">
<span id="eq-sec-de-vib-ode2-u-ec1"></span><span class="eqno">(45)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = v^{n+1},\]</div>
<p>We can easily solve for the new unknowns <span class="math">\(v^{n+1}\)</span> and <span class="math">\(u^{n+1}\)</span>:</p>
<div class="math" id="equation-sec:de:vib:ode2:v:EC2">
<span id="eq-sec-de-vib-ode2-v-ec2"></span><span class="eqno">(46)</span>\[     v^{n+1} = v^n + \frac{\Delta t}{m}\left(F(t_n) - s(u^n) - f(v^n)\right),\]</div>
<div class="math" id="equation-sec:de:vib:ode2:u:EC2">
<span id="eq-sec-de-vib-ode2-u-ec2"></span><span class="eqno">(47)</span>\[     u^{n+1} = u^n + \Delta t v^{n+1}\thinspace .\]</div>
<div class="admonition-remark-on-the-ordering-of-the-odes admonition">
<p class="first admonition-title">Remark on the ordering of the ODEs</p>
<p>The ordering of the ODEs in the ODE system is important for the
extended model <a href="#equation-sec:de:vib:ode2:v">(42)</a>-<a href="#equation-sec:de:vib:ode2:u">(43)</a>.
Imagine that we write the equation for <span class="math">\(u'\)</span> first and
then the one for <span class="math">\(v'\)</span>. The Euler-Cromer method would then
first use a forward difference for <span class="math">\(u^{n+1}\)</span>
and then a backward difference for <span class="math">\(v^{n+1}\)</span>. The latter would
lead to a <em>nonlinear</em> algebraic equation for <span class="math">\(v^{n+1}\)</span>,</p>
<div class="math">
\[v^{n+1} + \frac{\Delta t}{m}f(v^{n+1})
= v^n + \frac{\Delta t}{m}\left(F(t_{n+1}) - s(u^{n+1})\right),\]</div>
<p class="last">if <span class="math">\(f(v)\)</span> is a nonlinear function of <span class="math">\(v\)</span>. This would require a
numerical method for nonlinear algebraic equations to find
<span class="math">\(v^{n+1}\)</span>, while updating <span class="math">\(v^{n+1}\)</span> through a forward
difference gives an equation for <span class="math">\(v^{n+1}\)</span> that is linear and
trivial to solve by hand.</p>
</div>
<p>The file
<a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/osc_EC_general.m">osc_EC_general.m</a>
has a function <code class="docutils literal"><span class="pre">EulerCromer</span></code>
that implements this method:</p>
<div class="highlight-matlab"><div class="highlight"><pre>function [u_values, v_values, t_values] =...
                   EulerCromer(f, s, F, m, T, U_0, V_0, dt)
    N_t = floor(round(T/dt));
    fprintf(&#39;N_t: %d&#39;, N_t);
    t = linspace(0, N_t*dt, T_t+1);

    u = zeros(N_t+1,1);
    v = zeros(N_t+1,1);

   %% Initial conditions
    u(1) = U_0;
    v(1) = V_0;

   %% Step equations forward in time
    for n = 1:N_t
        v(n+1) = v(n) + dt*(1/m)*(F(t(n)) - f(v(n)) - s(u(n)));
        u(n+1) = u(n) + dt*v(n+1);
    end
    u_values = u;
    v_values = v;
    t_values = t;
end
</pre></div>
</div>
</div>
<div class="section" id="the-4-th-order-runge-kutta-method">
<h4>The 4-th order Runge-Kutta method<a class="headerlink" href="#the-4-th-order-runge-kutta-method" title="Permalink to this headline">¶</a></h4>
<p>The RK4 method just evaluates the right-hand side of the ODE
system,</p>
<div class="math">
\[(\frac{1}{m}\left(F(t) - s(u) - f(v)\right), v)\]</div>
<p>for known values of <span class="math">\(u\)</span>, <span class="math">\(v\)</span>, and <span class="math">\(t\)</span>, so the method is
very simple to use regardless of how the functions <span class="math">\(s(u)\)</span> and
<span class="math">\(f(v)\)</span> are chosen.</p>
</div>
</div>
<div class="section" id="illustration-of-linear-damping">
<h3>Illustration of linear damping<a class="headerlink" href="#illustration-of-linear-damping" title="Permalink to this headline">¶</a></h3>
<div class="figure" id="id30">
<span id="sec-de-vib-ode2-fig2"></span><a class="reference internal image-reference" href="_images/oscillator.png"><img alt="_images/oscillator.png" src="_images/oscillator.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Sketch of a one-dimensional, oscillating dynamic system subject to spring and viscous forces</em></span></p>
</div>
<p>We consider an engineering system with a linear spring,
<span class="math">\(s(u)=kx\)</span>, and a viscous damper, where the damping force is
proportional to <span class="math">\(u'\)</span>, <span class="math">\(f(u')=bu'\)</span>, for some constant <span class="math">\(b&gt;0\)</span>.
This choice may model the spring system in a car.
However, engineers often like to illustrate such a system by
a moving mass as depicted in Figure <a class="reference internal" href="#sec-de-vib-ode2-fig2"><span>Sketch of a one-dimensional, oscillating dynamic system subject to spring and viscous forces</span></a>.
We may choose simple values for the constants to illustrate
basic effects of damping (and later excitations). Choosing
the oscillations to be the simple
<span class="math">\(u(t)=\cos t\)</span> function in the undamped case, we
may set <span class="math">\(m=1\)</span>, <span class="math">\(k=1\)</span>, <span class="math">\(b=0.3\)</span>, <span class="math">\(U_0=1\)</span>,
<span class="math">\(V_0=0\)</span>. The following function implements this case:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span><span class="nf">linear_damping</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">b</span> <span class="p">=</span> <span class="mf">0.3</span><span class="p">;</span>
    <span class="n">f</span> <span class="p">=</span> <span class="p">@(</span><span class="n">v</span><span class="p">)</span> <span class="n">b</span><span class="o">*</span><span class="n">v</span><span class="p">;</span>
    <span class="n">s</span> <span class="p">=</span> <span class="p">@(</span><span class="n">u</span><span class="p">)</span> <span class="n">k</span><span class="o">*</span><span class="n">u</span><span class="p">;</span>
    <span class="n">F</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">m</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">k</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">U_0</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">V_0</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">T</span> <span class="p">=</span> <span class="mi">12</span><span class="o">*</span><span class="nb">pi</span><span class="p">;</span>
    <span class="n">dt</span> <span class="p">=</span> <span class="n">T</span><span class="o">/</span><span class="mi">5000</span><span class="p">;</span>

    <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">EulerCromer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">V_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>

    <span class="n">plot_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">plot_u</span></code> function is a collection of plot statements for
plotting <span class="math">\(u(t)\)</span>, or a part of it. Figure <a class="reference internal" href="#sec-de-vib-ode2-fig-linear-damping"><span>Effect of linear damping</span></a>
shows the effect of the <span class="math">\(bu'\)</span> term: we have oscillations with
(an approximate) period <span class="math">\(2\pi\)</span>, as expected, but the amplitude is
efficiently damped.</p>
<div class="figure" id="id31">
<span id="sec-de-vib-ode2-fig-linear-damping"></span><a class="reference internal image-reference" href="_images/osc_EC_linear_damping0.png"><img alt="_images/osc_EC_linear_damping0.png" src="_images/osc_EC_linear_damping0.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Effect of linear damping</em></span></p>
</div>
<div class="admonition-remark-about-working-with-a-scaled-problem admonition">
<p class="first admonition-title">Remark about working with a scaled problem</p>
<p>Instead of setting <span class="math">\(b=0.3\)</span> and <span class="math">\(m=k=U_0=1\)</span> as fairly &#8220;unlikely&#8221;
physical values,
it would be better to <em>scale</em> the equation <span class="math">\(u'' +bu' + ku = 0\)</span>.
This means that we introduce dimensionless independent and dependent
variables:</p>
<div class="math">
\[\bar t = \frac{t}{t_c},\quad \bar u = \frac{u}{u_c},\]</div>
<p>where <span class="math">\(t_c\)</span> and <span class="math">\(u_c\)</span> are characteristic sizes of time and displacement,
respectively, such that <span class="math">\(\bar t\)</span> and <span class="math">\(\bar u\)</span> have their typical size
around unity. In the present problem, we can choose <span class="math">\(u_c=U_0\)</span> and
<span class="math">\(t_c = \sqrt{m/k}\)</span>. This gives the following scaled (or dimensionless)
problem for the dimensionless quantity <span class="math">\(\bar u(\bar t)\)</span>:</p>
<div class="math">
\[\frac{d^2\bar u}{d\bar t^2} + \beta\frac{d\bar u}{d\bar t} +
\bar u = 0,\quad \bar u(0)=1,\ \bar u'(0)=0,\quad \beta = \frac{b}{\sqrt{mk}}
\thinspace .\]</div>
<p>The striking fact is that there is only <em>one</em> physical parameter in this
problem: the dimensionless number <span class="math">\(\beta\)</span>. Solving this problem corresponds
to solving the original problem (with dimensions) with the parameters
<span class="math">\(m=k=U_0=1\)</span> and <span class="math">\(b=\beta\)</span>. However, solving the dimensionless
problem is more general: if we have a solution <span class="math">\(\bar u(\bar t;\beta)\)</span>,
we can find the physical solution of a range of problems since</p>
<div class="math">
\[u(t) = U_0\bar u(t\sqrt{k/m}; \beta)\thinspace .\]</div>
<p class="last">As long as <span class="math">\(\beta\)</span> is fixed, we can find <span class="math">\(u\)</span> for any <span class="math">\(U_0\)</span>, <span class="math">\(k\)</span>, and <span class="math">\(m\)</span>
from the above formula! In this way, a time consuming simulation can be done only once,
but still provide many solutions. This demonstrates the power of working with
scaled or dimensionless problems.</p>
</div>
</div>
<div class="section" id="illustration-of-linear-damping-with-sinusoidal-excitation">
<h3>Illustration of linear damping with sinusoidal excitation<a class="headerlink" href="#illustration-of-linear-damping-with-sinusoidal-excitation" title="Permalink to this headline">¶</a></h3>
<p>We now extend the previous example to also involve some external
oscillating force on the system: <span class="math">\(F(t)=A\sin (wt)\)</span>. Driving a
car on a road with sinusoidal bumps might give such an external
excitation on the spring system in the car (<span class="math">\(w\)</span> is related to
the velocity of the car).</p>
<p>With <span class="math">\(A=0.5\)</span> and
<span class="math">\(w=3\)</span>,</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="n">w</span> <span class="p">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">A</span> <span class="p">=</span> <span class="mf">0.5</span><span class="p">;</span>
<span class="n">F</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">)</span> <span class="n">A</span><span class="o">*</span><span class="nb">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">);</span>
</pre></div>
</div>
<p>we get the graph in Figure <a class="reference internal" href="#sec-de-vib-ode2-fig-linear-damping-sinwt"><span>Effect of linear damping in combination with a sinusoidal external force</span></a>.
The striking difference from Figure <a class="reference internal" href="#sec-de-vib-ode2-fig-linear-damping"><span>Effect of linear damping</span></a>
is that the oscillations start out as a damped <span class="math">\(\cos t\)</span> signal
without much influence of the external force, but then the free oscillations
of the undamped system (<span class="math">\(\cos t\)</span>) <span class="math">\(u'' + u = 0\)</span> die out and
the external force <span class="math">\(0.5\sin(3t)\)</span> induces oscillations with a shorter period
<span class="math">\(2\pi/3\)</span>. You are encouraged to play around with a larger <span class="math">\(A\)</span> and switch
from a sine to a cosine in <span class="math">\(F\)</span> and observe the effects. If you look this up in
a physics book, you can find exact analytical solutions to the differential
equation problem in these cases.</p>
<div class="figure" id="id32">
<span id="sec-de-vib-ode2-fig-linear-damping-sinwt"></span><a class="reference internal image-reference" href="_images/osc_EC_linear_damping1.png"><img alt="_images/osc_EC_linear_damping1.png" src="_images/osc_EC_linear_damping1.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Effect of linear damping in combination with a sinusoidal external force</em></span></p>
</div>
<p>A particularly interesting case arises when the excitation force has
the same frequency as the free oscillations of the undamped system, i.e.,
<span class="math">\(F(t)=A\sin t\)</span>. With the same amplitude <span class="math">\(A=0.5\)</span>, but a smaller damping
<span class="math">\(b=0.1\)</span>, the oscillations in
Figure <a class="reference internal" href="#sec-de-vib-ode2-fig-linear-damping-sinwt"><span>Effect of linear damping in combination with a sinusoidal external force</span></a> becomes qualitatively
very different as the amplitude grows significantly larger over
some periods. This phenomenon is called resonance and is exemplified
in Figure <a class="reference internal" href="#sec-de-vib-ode2-fig-linear-damping-sint"><span>Excitation force that causes resonance</span></a>. Removing the
damping results in an amplitude that grows linearly in time.</p>
<div class="figure" id="id33">
<span id="sec-de-vib-ode2-fig-linear-damping-sint"></span><a class="reference internal image-reference" href="_images/osc_EC_linear_damping2.png"><img alt="_images/osc_EC_linear_damping2.png" src="_images/osc_EC_linear_damping2.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Excitation force that causes resonance</em></span></p>
</div>
</div>
<div class="section" id="spring-mass-system-with-sliding-friction">
<span id="sec-de-vib-ode2-sliding-friction"></span><h3>Spring-mass system with sliding friction<a class="headerlink" href="#spring-mass-system-with-sliding-friction" title="Permalink to this headline">¶</a></h3>
<div class="figure" id="id34">
<span id="sec-de-vib-ode2-fig3"></span><a class="reference internal image-reference" href="_images/oscillator_sliding.png"><img alt="_images/oscillator_sliding.png" src="_images/oscillator_sliding.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><em>Sketch of a one-dimensional, oscillating dynamic system subject to sliding friction and a spring force</em></span></p>
</div>
<p>A body with mass <span class="math">\(m\)</span> is attached to a spring with stiffness <span class="math">\(k\)</span> while sliding
on a plane surface. The body is also subject
to a friction force <span class="math">\(f(u')\)</span> due to the contact between the body and
the plane. Figure <a class="reference internal" href="#sec-de-vib-ode2-fig3"><span>Sketch of a one-dimensional, oscillating dynamic system subject to sliding friction and a spring force</span></a> depicts the situation.
The friction force <span class="math">\(f(u')\)</span> can be
modeled by Coulomb friction:</p>
<div class="math">
\[\begin{split}f(u') = \left\lbrace\begin{array}{ll}
-\mu mg,&amp; u' &lt; 0,\\
\mu mg, &amp; u' &gt; 0,\\
0,      &amp; u'=0
\end{array}\right.\end{split}\]</div>
<p>where <span class="math">\(\mu\)</span> is the friction coefficient, and <span class="math">\(mg\)</span> is the normal force
on the surface where the body slides. This formula can also be
written as <span class="math">\(f(u')=mg\,\mbox{sign}(u')\)</span>, provided the signum function
<span class="math">\(\mbox{sign}(x)\)</span> is defined to be zero for <span class="math">\(x=0\)</span>
(the <code class="docutils literal"><span class="pre">sign</span></code> function in Matlab` has
this property). To check that the signs in the definition of
<span class="math">\(f\)</span> are right, recall that the actual
physical force is <span class="math">\(-f\)</span> and this is positive (i.e., <span class="math">\(f&lt;0\)</span>) when it
works against the body moving with velocity <span class="math">\(u'&lt;0\)</span>.</p>
<p>The nonlinear spring force is taken as</p>
<div class="math">
\[s(u) = -k\alpha^{-1}\tanh (\alpha u),\]</div>
<p>which is approximately <span class="math">\(-ku\)</span> for small <span class="math">\(u\)</span>, but stabilizes at <span class="math">\(\pm k/\alpha\)</span>
for large <span class="math">\(\pm \alpha u\)</span>. Here is a plot with <span class="math">\(k=1000\)</span> and <span class="math">\(u\in [-0.1,0.1]\)</span>
for three <span class="math">\(\alpha\)</span> values:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/spring_tanh.png"><img alt="_images/spring_tanh.png" src="_images/spring_tanh.png" style="width: 600px;" /></a>
</div>
<p>If there are no external
forces acting on the body, we have the equation of motion</p>
<div class="math">
\[mu'' + \mu mg\,\mbox{sign}(u') + k\tanh u = 0\thinspace .\]</div>
<p>Let us simulate a situation where a body of mass 1 kg slides on a surface
with <span class="math">\(\mu =0.4\)</span>, while attached to a spring with stiffness
<span class="math">\(k=1000\)</span> $hbox{kg}/hbox{s}^2$. The initial displacement of the
body is 10 cm, and the <span class="math">\(\alpha\)</span> parameter in <span class="math">\(s(u)\)</span> is set to 60 1/m.
Using the <code class="docutils literal"><span class="pre">EulerCromer</span></code> function from the <code class="docutils literal"><span class="pre">EulerCromer</span></code> code, we can write a function <code class="docutils literal"><span class="pre">sliding_friction</span></code> for solving this problem:</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span><span class="nf">sliding_friction</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="n">f</span> <span class="p">=</span> <span class="p">@(</span><span class="n">v</span><span class="p">)</span> <span class="n">mu</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="nb">sign</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">alpha</span> <span class="p">=</span> <span class="mf">60.0</span><span class="p">;</span>
    <span class="n">s</span> <span class="p">=</span> <span class="p">@(</span><span class="n">u</span><span class="p">)</span> <span class="n">k</span><span class="o">/</span><span class="n">alpha</span><span class="o">*</span><span class="nb">tanh</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">u</span><span class="p">);</span>
    <span class="n">F</span> <span class="p">=</span> <span class="p">@(</span><span class="n">t</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">g</span> <span class="p">=</span> <span class="mf">9.81</span><span class="p">;</span>
    <span class="n">mu</span> <span class="p">=</span> <span class="mf">0.4</span><span class="p">;</span>
    <span class="n">m</span> <span class="p">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">k</span> <span class="p">=</span> <span class="mi">1000</span><span class="p">;</span>

    <span class="n">U_0</span> <span class="p">=</span> <span class="mf">0.1</span><span class="p">;</span>
    <span class="n">V_0</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">T</span> <span class="p">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">dt</span> <span class="p">=</span> <span class="n">T</span><span class="o">/</span><span class="mi">5000</span><span class="p">;</span>

    <span class="p">[</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">]</span> <span class="p">=</span> <span class="n">EulerCromer</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">U_0</span><span class="p">,</span> <span class="n">V_0</span><span class="p">,</span> <span class="n">dt</span><span class="p">);</span>

    <span class="n">plot_u</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="k">end</span>
</pre></div>
</div>
<p>Running the <code class="docutils literal"><span class="pre">sliding_friction</span></code> function gives us the
results in Figure <a class="reference internal" href="#sec-de-vib-ode2-fig-friction"><span>Effect of nonlinear (left) and linear (right) spring on sliding friction</span></a>
with <span class="math">\(s(u)=k\alpha^{-1}\tanh (\alpha u)\)</span> (left) and
the linearized version <span class="math">\(s(u)=ku\)</span> (right):</p>
<div class="figure" id="id35">
<span id="sec-de-vib-ode2-fig-friction"></span><a class="reference internal image-reference" href="_images/sliding_friction.png"><img alt="_images/sliding_friction.png" src="_images/sliding_friction.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Effect of nonlinear (left) and linear (right) spring on sliding friction</em></span></p>
</div>
</div>
<div class="section" id="a-finite-difference-method-undamped-linear-case">
<span id="sec-de-vib-2nd"></span><h3>A finite difference method; undamped, linear case<a class="headerlink" href="#a-finite-difference-method-undamped-linear-case" title="Permalink to this headline">¶</a></h3>
<p>We shall now address numerical methods for the second-order ODE</p>
<div class="math">
\[u'' + \omega^2u = 0,\quad u(0)=U_0,\ u'(0)=0,\ t\in (0,T],\]</div>
<p><em>without</em> rewriting the ODE as a system of first-order ODEs. The primary
motivation for &#8220;yet another solution method&#8221; is that the
discretization principles result in a very good scheme, and more
importantly, the thinking around the discretization can be reused when
solving partial differential equations.</p>
<p>The main idea of this numerical method
is to approximate the second-order derivative <span class="math">\(u''\)</span>
by a finite difference. While there are several choices of difference
approximations to
first-order derivatives, there is one dominating formula for
the second-order derivative:</p>
<div class="math" id="equation-sec:de:vib:2nd:utt">
<span id="eq-sec-de-vib-2nd-utt"></span><span class="eqno">(48)</span>\[     u''(t_n) \approx \frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     \thinspace .\]</div>
<p>The accuracy of this approximation is <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>.
Letting the ODE be valid at some arbitrary time point <span class="math">\(t_n\)</span>,</p>
<div class="math">
\[u''(t_n) + \omega^2 u(t_n) = 0,\]</div>
<p>we just insert the approximation <a href="#equation-sec:de:vib:2nd:utt">(48)</a> to get</p>
<div class="math">
\[\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2} = -\omega^2 u^n
\thinspace .\]</div>
<p>We now assume that <span class="math">\(u^{n-1}\)</span> and <span class="math">\(u^n\)</span> are already computed and
that <span class="math">\(u^{n+1}\)</span> is the new unknown. Solving with respect to
<span class="math">\(u^{n+1}\)</span> gives</p>
<div class="math" id="equation-sec:de:vib:2nd:scheme">
<span id="eq-sec-de-vib-2nd-scheme"></span><span class="eqno">(49)</span>\[     u^{n+1} = 2u^n - u^{n-1} - \Delta t^2\omega^2 u^n
     \thinspace .\]</div>
<p>A major problem arises when we want to start the scheme.
We know that <span class="math">\(u^0=U_0\)</span>, but applying <a href="#equation-sec:de:vib:2nd:scheme">(49)</a> for
<span class="math">\(n=0\)</span> to compute <span class="math">\(u^1\)</span> leads to</p>
<div class="math" id="equation-sec:de:vib:2nd:scheme0">
<span id="eq-sec-de-vib-2nd-scheme0"></span><span class="eqno">(50)</span>\[     u^1 = 2u^0 - u^{-1} - \Delta t^2\omega^2 u^0,\]</div>
<p>where we do not know <span class="math">\(u^{-1}\)</span>. The initial condition <span class="math">\(u'(0)=0\)</span> can help
us to eliminate <span class="math">\(u^{-1}\)</span> -
and this condition must anyway be incorporated in some way.
To this end, we discretize <span class="math">\(u'(0)=0\)</span> by a <em>centered difference</em>,</p>
<div class="math">
\[u'(0) \approx \frac{u^1 - u^{-1}}{2\Delta t} = 0\thinspace .\]</div>
<p>It follows that <span class="math">\(u^{-1}=u^1\)</span>, and we can use this relation to
eliminate <span class="math">\(u^{-1}\)</span> in <a href="#equation-sec:de:vib:2nd:scheme0">(50)</a>:</p>
<div class="math" id="equation-sec:de:vib:2nd:scheme1">
<span id="eq-sec-de-vib-2nd-scheme1"></span><span class="eqno">(51)</span>\[     u^1 = u^0 - \frac{1}{2}\Delta t^2\omega^2 u^0\thinspace .\]</div>
<p>With <span class="math">\(u^0=U_0\)</span> and <span class="math">\(u^1\)</span> computed from <a href="#equation-sec:de:vib:2nd:scheme1">(51)</a>,
we can compute <span class="math">\(u^2\)</span>, <span class="math">\(u^3\)</span>, and so forth from <a href="#equation-sec:de:vib:2nd:scheme">(49)</a>.
<a class="reference internal" href="#sec-de-exer-osc-2nd-v0ic"><span>Exercise 61: Discretize an initial condition</span></a> asks you to explore how the
steps above are modified in case we have a nonzero initial condition
<span class="math">\(u'(0)=V_0\)</span>.</p>
<div class="admonition-remark-on-a-simpler-method-for-computing-math-u-1 admonition">
<p class="first admonition-title">Remark on a simpler method for computing <span class="math">\(u^1\)</span></p>
<p>We could approximate the initial condition <span class="math">\(u'(0)\)</span> by a forward difference:</p>
<div class="math">
\[u'(0) \approx \frac{u^1-u^0}{\Delta t} = 0,\]</div>
<p class="last">leading to <span class="math">\(u^1=u^0\)</span>. Then we can use <a href="#equation-sec:de:vib:2nd:scheme">(49)</a> for
the coming time steps. However, this forward difference has accuracy
<span class="math">\({\mathcal{O}(\Delta t)}\)</span>, while the centered difference we used has
accuracy <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span>, which is compatible with the
accuracy <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span> used in the discretization of the
differential equation.</p>
</div>
<p>The method for the second-order
ODE described above goes under the name
Stormer&#8217;s
method or <a class="reference external" href="http://en.wikipedia.org/wiki/Verlet_integration">Verlet integration</a>.
It turns out that this method
is mathematically equivalent with the Euler-Cromer scheme (!).
Or more precisely, the general formula <a href="#equation-sec:de:vib:2nd:scheme">(49)</a>
is equivalent with the Euler-Cromer formula, but the scheme for
the first time level <a href="#equation-sec:de:vib:2nd:scheme1">(51)</a>
implements the initial condition <span class="math">\(u'(0)\)</span> slightly more accurately
than what is naturally done in the Euler-Cromer scheme. The latter
will do</p>
<div class="math">
\[v^1 = v^0 - \Delta t\omega^2 u^0,\quad u^1 = u^0 + \Delta t v^1
= u^0 - \Delta t^2\omega^2 u^0,\]</div>
<p>which differs from <span class="math">\(u^1\)</span> in <a href="#equation-sec:de:vib:2nd:scheme1">(51)</a> by
an amount <span class="math">\(\frac{1}{2}\Delta t^2\omega^2 u^0\)</span>.</p>
<p>Because of the equivalence of <a href="#equation-sec:de:vib:2nd:scheme">(49)</a> with
the Euler-Cromer scheme, the numerical results will have the same
nice properties such as a constant amplitude. There will be a phase
error as in the Euler-Cromer scheme, but this error is effectively
reduced by reducing <span class="math">\(\Delta t\)</span>, as already demonstrated.</p>
<p>Another implication of the equivalence between <a href="#equation-sec:de:vib:2nd:scheme">(49)</a>
and the Euler-Cromer scheme, is that the latter must also have
accuracy of order <span class="math">\(\Delta t^2\)</span>. One would intuitively think that
using a forward and a backward difference in the Euler-Cromer
scheme implies an <span class="math">\({\mathcal{O}(\Delta t)}\)</span> scheme, but the differences are
used in a symmetric way so together they form an
<span class="math">\({\mathcal{O}(\Delta t^2)}\)</span> scheme.</p>
<p>The implementation of <a href="#equation-sec:de:vib:2nd:scheme1">(51)</a> and
<a href="#equation-sec:de:vib:2nd:scheme">(49)</a> is straightforward in a function
(file <a class="reference external" href="https://github.com/hplgit/prog4comp/src/m/osc_2nd_order.m">osc_2nd_order.m</a>):</p>
<div class="highlight-matlab"><div class="highlight"><pre><span class="k">function</span><span class="w"> </span>[u, t] <span class="p">=</span><span class="w"> </span><span class="nf">osc_2nd_order</span><span class="p">(</span>U_0, omega, dt, T<span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="c">% Solve u&#39;&#39; + omega**2*u = 0 for t in (0,T], u(0)=U_0</span>
    <span class="c">% and u&#39;(0)=0, by a central finite difference method with</span>
    <span class="c">% time step dt.</span>
    <span class="n">N_t</span> <span class="p">=</span> <span class="nb">floor</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">T</span><span class="o">/</span><span class="n">dt</span><span class="p">));</span>
    <span class="n">u</span> <span class="p">=</span> <span class="nb">zeros</span><span class="p">(</span><span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">t</span> <span class="p">=</span> <span class="nb">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N_t</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>

    <span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="n">U_0</span><span class="p">;</span>
    <span class="n">u</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">=</span> <span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span>^<span class="mi">2</span><span class="o">*</span><span class="n">omega</span>^<span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">n</span> <span class="p">=</span> <span class="mi">2</span><span class="p">:</span><span class="n">N_t</span>
        <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span>^<span class="mi">2</span><span class="o">*</span><span class="n">omega</span>^<span class="mi">2</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
</div>
<div class="section" id="a-finite-difference-method-linear-damping">
<span id="sec-de-vib-2nd-damped1"></span><h3>A finite difference method; linear damping<a class="headerlink" href="#a-finite-difference-method-linear-damping" title="Permalink to this headline">¶</a></h3>
<p>A key issue is how to generalize the scheme from the section <a class="reference internal" href="#sec-de-vib-2nd"><span>A finite difference method; undamped, linear case</span></a>
to a differential equation with more terms. We start with
the case of a linear damping term <span class="math">\(f(u')=bu'\)</span>, a possibly nonlinear
spring force <span class="math">\(s(u)\)</span>, and an excitation force <span class="math">\(F(t)\)</span>:</p>
<div class="math">
\[mu'' + bu' + s(u) = F(t),\quad u(0)=U_0,\ u'(0)=0,\ t\in (0,T]
\thinspace .\]</div>
<p>We need to find the appropriate difference approximation to <span class="math">\(u'\)</span>
in the <span class="math">\(bu'\)</span> term.
A good choice is the <em>centered difference</em></p>
<div class="math" id="equation-sec:de:vib:D2tu">
<span id="eq-sec-de-vib-d2tu"></span><span class="eqno">(52)</span>\[     u'(t_n) \approx \frac{u^{n+1}-u^{n-1}}{2\Delta t}\thinspace .\]</div>
<p>Sampling the equation at a time point <span class="math">\(t_n\)</span>,</p>
<div class="math">
\[mu''(t_n) + bu'(t_n) + s(u^n) = F(t_n),\]</div>
<p>and inserting the finite difference approximations to <span class="math">\(u''\)</span> and <span class="math">\(u'\)</span>
results in</p>
<div class="math" id="equation-sec:de:vib:2nd:lin:damping">
<span id="eq-sec-de-vib-2nd-lin-damping"></span><span class="eqno">(53)</span>\[     m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
     + b\frac{u^{n+1}-u^{n-1}}{2\Delta t} + s(u^n) = F^n,\]</div>
<p>where <span class="math">\(F^n\)</span> is a short notation for <span class="math">\(F(t_n)\)</span>.
Equation <a href="#equation-sec:de:vib:2nd:lin:damping">(53)</a> is linear in the unknown <span class="math">\(u^{n+1}\)</span>,
so we can easily solve for this quantity:</p>
<div class="math" id="equation-sec:de:vib:2nd:lin:damping:unp1">
<span id="eq-sec-de-vib-2nd-lin-damping-unp1"></span><span class="eqno">(54)</span>\[     u^{n+1} = (2mu^n + (\frac{b}{2}\Delta t - m)u^{n-1} +
     \Delta t^2(F^n - s(u^n)))(m + \frac{b}{2}\Delta t)^{-1}\]\[     \thinspace .\]</div>
<p>As in the case without damping, we need to derive a special
formula for <span class="math">\(u^1\)</span>. The initial condition <span class="math">\(u'(0)=0\)</span> implies
also now that <span class="math">\(u^{-1}=u^1\)</span>, and with <a href="#equation-sec:de:vib:2nd:lin:damping:unp1">(54)</a> for
<span class="math">\(n=0\)</span>, we get</p>
<div class="math" id="equation-sec:de:vib:2nd:lin:damping:u1">
<span id="eq-sec-de-vib-2nd-lin-damping-u1"></span><span class="eqno">(55)</span>\[     u^1 = u^0 + \frac{\Delta t^2}{2m}(-bV - s(u^0) + F^0)
     \thinspace .\]</div>
<p>In the more general case with a nonlinear damping term <span class="math">\(f(u')\)</span>,</p>
<div class="math">
\[mu'' + f(u') + s(u) = F(t),\]</div>
<p>we get</p>
<div class="math">
\[m\frac{u^{n+1}-2u^n + u^{n-1}}{\Delta t^2}
+ f(\frac{u^{n+1}-u^{n-1}}{2\Delta t}) + s(u^n) = F^n,\]</div>
<p>which is a <em>nonlinear algebraic equation</em> for <span class="math">\(u^{n+1}\)</span> that
must be solved by numerical methods. A much more convenient
scheme arises from using a backward difference for <span class="math">\(u'\)</span>,</p>
<div class="math">
\[u'(t_n)\approx \frac{u^n-u^{n-1}}{\Delta t},\]</div>
<p>because the damping term will then be known,
involving only <span class="math">\(u^n\)</span> and <span class="math">\(u^{n-1}\)</span>, and we can easily solve
for <span class="math">\(u^{n+1}\)</span>.</p>
<p>The downside of the backward difference compared to the centered
difference <a href="#equation-sec:de:vib:D2tu">(52)</a> is that it reduces the accuracy in
the overall scheme from <span class="math">\({\mathcal{O}(\Delta t^2)}\)</span> to <span class="math">\({\mathcal{O}(\Delta t)}\)</span>.  In
fact, the Euler-Cromer scheme evaluates a nonlinear damping term as
<span class="math">\(f(v^n)\)</span> when computing <span class="math">\(v^{n+1}\)</span>, and this is equivalent to
using the backward difference above. Consequently, the convenience of
the Euler-Cromer scheme for nonlinear damping comes at a cost of
lowering the overall accuracy of the scheme from second to first
order in <span class="math">\(\Delta t\)</span>. Using the same trick in the finite difference scheme for
the second-order differential equation, i.e., using the backward
difference in <span class="math">\(f(u')\)</span>, makes this scheme
equally convenient and accurate as the Euler-Cromer scheme
in the general nonlinear case <span class="math">\(mu''+f(u')+s(u)=F\)</span>.</p>
</div>
</div>
<div class="section" id="exercises-4">
<h2>Exercises  (4)<a class="headerlink" href="#exercises-4" title="Permalink to this headline">¶</a></h2>
<div class="section" id="exercise-43-geometric-construction-of-the-forward-euler-method">
<span id="sec-de-exer-geom"></span><h3>Exercise 43: Geometric construction of the Forward Euler method<a class="headerlink" href="#exercise-43-geometric-construction-of-the-forward-euler-method" title="Permalink to this headline">¶</a></h3>
<p>The section <a class="reference internal" href="#sec-de-pg-geom"><span>Understanding the Forward Euler method</span></a> describes a geometric interpretation of
the Forward Euler method. This exercise will demonstrate the geometric
construction of the solution in detail. Consider the differential
equation <span class="math">\(u'=u\)</span> with <span class="math">\(u(0)=1\)</span>. We use time steps <span class="math">\(\Delta t = 1\)</span>.</p>
<p><strong>a)</strong>
Start at <span class="math">\(t=0\)</span> and draw a straight line with slope <span class="math">\(u'(0)=u(0)=1\)</span>.
Go one time step forward to <span class="math">\(t=\Delta t\)</span> and mark the solution point
on the line.</p>
<p><strong>Solution.</strong>
See plot and comments given below.</p>
<p><strong>b)</strong>
Draw a straight line through the solution point <span class="math">\((\Delta t, u^1)\)</span>
with slope <span class="math">\(u'(\Delta t)=u^1\)</span>. Go one time step forward to
<span class="math">\(t=2\Delta t\)</span> and mark the solution point on the line.</p>
<p><strong>Solution.</strong>
See plot and comments given below.</p>
<p><strong>c)</strong>
Draw a straight line through the solution point <span class="math">\((2\Delta t, u^2)\)</span>
with slope <span class="math">\(u'(2\Delta t)=u^2\)</span>. Go one time step forward to
<span class="math">\(t=3\Delta t\)</span> and mark the solution point on the line.</p>
<p><strong>Solution.</strong>
See plot and comments given below.</p>
<p><strong>d)</strong>
Set up the Forward Euler scheme for the problem <span class="math">\(u'=u\)</span>.
Calculate <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span>. Check that the numbers are
the same as obtained in a)-c).</p>
<p><strong>Solution.</strong>
The code may be written as</p>
<p>Here is a missing file: ForwardEuler_geometric_solution</p>
<p>Running the program will print the numbers 1, 2, 4 and 8, as well as produce the plot seen in
Figure <a class="reference internal" href="#fig-fegeom"><span>Forward Euler method (red filled circles) applied to the ode  \( u&#8217; = u \) . For easy comparison, the true solution  \( u(t) = e^t \)  is also shown (blue continuous line)</span></a>. We see the values computed in a)-c) as circles
(which in a)-c) are connected by straight line segments). For comparison, the true solution
is also given. The very large timestep gives a rather poor numerical solution.</p>
<div class="figure" id="id36">
<span id="fig-fegeom"></span><a class="reference internal image-reference" href="_images/fE_geom_sol.png"><img alt="_images/fE_geom_sol.png" src="_images/fE_geom_sol.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Forward Euler method (red filled circles) applied to the ode  \( u&#8217; = u \) . For easy comparison, the true solution  \( u(t) = e^t \)  is also shown (blue continuous line)</em></span></p>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">ForwardEuler_geometric_solution.m</span></code>.</p>
</div>
<div class="section" id="exercise-44-make-test-functions-for-the-forward-euler-method">
<span id="sec-de-exer-fe-test1"></span><h3>Exercise 44: Make test functions for the Forward Euler method<a class="headerlink" href="#exercise-44-make-test-functions-for-the-forward-euler-method" title="Permalink to this headline">¶</a></h3>
<p>The purpose of this exercise is to
make a file <code class="docutils literal"><span class="pre">test_ode_FE.m</span></code> that makes use of the <code class="docutils literal"><span class="pre">ode_FE</span></code>
function in the file <code class="docutils literal"><span class="pre">ode_FE.m</span></code> and automatically verifies the
implementation of <code class="docutils literal"><span class="pre">ode_FE</span></code>.</p>
<p><strong>a)</strong>
The solution computed by hand in <a class="reference internal" href="#sec-de-exer-geom"><span>Exercise 43: Geometric construction of the Forward Euler method</span></a> can be
used as a reference solution. Make a function <code class="docutils literal"><span class="pre">test_ode_FE_1()</span></code>
that calls <code class="docutils literal"><span class="pre">ode_FE</span></code> to compute
three time steps in the problem <span class="math">\(u'=u\)</span>, <span class="math">\(u(0)=1\)</span>, and compare the
three values <span class="math">\(u^1\)</span>, <span class="math">\(u^2\)</span>, and <span class="math">\(u^3\)</span> with the values obtained in
<a class="reference internal" href="#sec-de-exer-geom"><span>Exercise 43: Geometric construction of the Forward Euler method</span></a>.</p>
<p><strong>Solution.</strong>
See code presented below.</p>
<p><strong>b)</strong>
The test in a) can be made more general using the fact
that if <span class="math">\(f\)</span> is linear in <span class="math">\(u\)</span> and does not depend on <span class="math">\(t\)</span>, i.e., we
have <span class="math">\(u'=ru\)</span>, for
some constant <span class="math">\(r\)</span>, the Forward Euler method has a closed form solution
as outlined in the section <a class="reference internal" href="#sec-de-pg-model"><span>Derivation of the model</span></a>: <span class="math">\(u^n=U_0(1+r\Delta t)^n\)</span>.
Use this result to construct a test function <code class="docutils literal"><span class="pre">test_ode_FE_2()</span></code> that
runs a number of steps in <code class="docutils literal"><span class="pre">ode_FE</span></code> and compares the computed
solution with the listed formula for <span class="math">\(u^n\)</span>.</p>
<p><strong>Solution.</strong>
The code may be written as:</p>
<p>Here is a missing file: growth2_test</p>
<p>Filename: <code class="docutils literal"><span class="pre">test_ode_FE.m</span></code>.</p>
</div>
<div class="section" id="exercise-45-implement-and-evaluate-heun-s-method">
<span id="sec-de-exer-heun-pg"></span><h3>Exercise 45: Implement and evaluate Heun&#8217;s method<a class="headerlink" href="#exercise-45-implement-and-evaluate-heun-s-method" title="Permalink to this headline">¶</a></h3>
<p><strong>a)</strong>
A 2nd-order Runge-Kutta method, also known has Heun&#8217;s method,
is derived in the section <a class="reference internal" href="#sec-de-osc-heun"><span>The 2nd-order Runge-Kutta method (or Heun&#8217;s method)</span></a>. Make a function
<code class="docutils literal"><span class="pre">ode_Heun(f,</span> <span class="pre">U_0,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code> (as a counterpart to <code class="docutils literal"><span class="pre">ode_FE(f,</span> <span class="pre">U_0,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>
in <code class="docutils literal"><span class="pre">ode_FE.m</span></code>) for solving  a scalar ODE problem <span class="math">\(u'=f(u,t)\)</span>,
<span class="math">\(u(0)=U_0\)</span>, <span class="math">\(t\in (0,T]\)</span>, with
this method using a time step size <span class="math">\(\Delta t\)</span>.</p>
<p><strong>Solution.</strong>
The code may be written as:</p>
<p>Here is a missing file: ode_Heun</p>
<p><strong>b)</strong>
Solve the simple ODE problem <span class="math">\(u'=u\)</span>, <span class="math">\(u(0)=1\)</span>, by the <code class="docutils literal"><span class="pre">ode_Heun</span></code> and
the <code class="docutils literal"><span class="pre">ode_FE</span></code> function. Make
a plot that compares Heun&#8217;s method and the Forward Euler method
with the exact solution <span class="math">\(u(t)=e^t\)</span> for <span class="math">\(t\in [0,6]\)</span>. Use a
time step <span class="math">\(\Delta t = 0.5\)</span>.</p>
<p><strong>Solution.</strong>
The given ODE may be solved by the function <code class="docutils literal"><span class="pre">demo_ode_Heun</span></code>:</p>
<p>Here is a missing file: demo_ode_Heun</p>
<p>Running the code with <span class="math">\(\Delta t = 0.5\)</span> (seen in the code) gives the plot seen in Figure <a class="reference internal" href="#h-fe-comp"><span>Heun and Forward Euler with timestep </span></a>.</p>
<div class="figure" id="id37">
<span id="h-fe-comp"></span><a class="reference internal image-reference" href="_images/H_FE_comp.png"><img alt="_images/H_FE_comp.png" src="_images/H_FE_comp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text">Heun and Forward Euler with timestep <span class="math">\(\Delta t = 0.5\)</span></span></p>
</div>
<p><strong>c)</strong>
For the case in b),
find through experimentation the largest value of <span class="math">\(\Delta t\)</span> where the
exact solution and the numerical solution by Heun&#8217;s method
cannot be distinguished visually. It is of interest to see how far
off the curve the Forward Euler method is when Heun&#8217;s method can
be regarded as &#8220;exact&#8221; (for visual purposes).</p>
<p><strong>Solution.</strong>
A timestep of <span class="math">\(\Delta t = 0.1\)</span> was found to be the largest reasonable timestep
that still made the solution from Heun&#8217;s method come on top of the exact solution
(from graphical inspection only), see Figure <a class="reference internal" href="#h-exact-fe-comp"><span>Heun and Forward Euler with timestep  \( Delta t = 0.1 \) . A larger timestep makes Heun&#8217;s method deviate from the true solution (only judged graphically)</span></a>.</p>
<div class="figure" id="id38">
<span id="h-exact-fe-comp"></span><a class="reference internal image-reference" href="_images/H_exact_FE_comp.png"><img alt="_images/H_exact_FE_comp.png" src="_images/H_exact_FE_comp.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><em>Heun and Forward Euler with timestep  \( Delta t = 0.1 \) . A larger timestep makes Heun&#8217;s method deviate from the true solution (only judged graphically)</em></span></p>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">ode_Heun.m</span></code>.</p>
</div>
<div class="section" id="exercise-46-find-an-appropriate-time-step-logistic-model">
<span id="sec-de-exer-logistic-dtopt"></span><h3>Exercise 46: Find an appropriate time step; logistic model<a class="headerlink" href="#exercise-46-find-an-appropriate-time-step-logistic-model" title="Permalink to this headline">¶</a></h3>
<p>Compute the numerical solution of the logistic equation for a set of
repeatedly halved time steps: <span class="math">\(\Delta t_k = 2^{-k}\Delta t\)</span>,
<span class="math">\(k=0,1,\ldots\)</span>.  Plot the solutions corresponding to the last two time
steps <span class="math">\(\Delta t_{k}\)</span> and <span class="math">\(\Delta t_{k-1}\)</span> in the same plot.  Continue
doing this until you cannot visually distinguish the two curves in the
plot. Then one has found a sufficiently small time step.</p>
<p><strong>Hint.</strong>
Extend the <code class="docutils literal"><span class="pre">logistic.py</span></code> file. Introduce a loop over <span class="math">\(k\)</span>, write out
<span class="math">\(\Delta t_k\)</span>, and ask the
user if the loop is to be continued.</p>
<p><strong>Solution.</strong>
This may be implemented as:</p>
<p>Here is a missing file: logistic_dt</p>
<p>Filename: <code class="docutils literal"><span class="pre">logistic_dt.m</span></code>.</p>
</div>
<div class="section" id="exercise-47-find-an-appropriate-time-step-sir-model">
<span id="sec-de-exer-sir-dtopt"></span><h3>Exercise 47: Find an appropriate time step; SIR model<a class="headerlink" href="#exercise-47-find-an-appropriate-time-step-sir-model" title="Permalink to this headline">¶</a></h3>
<p>Repeat <a class="reference internal" href="#sec-de-exer-logistic-dtopt"><span>Exercise 46: Find an appropriate time step; logistic model</span></a> for the SIR model.</p>
<p><strong>Hint.</strong>
Import the <code class="docutils literal"><span class="pre">ode_FE</span></code> function from the <code class="docutils literal"><span class="pre">ode_system_FE</span></code> module
and make a modified <code class="docutils literal"><span class="pre">demo_SIR</span></code> function that has a loop
over repeatedly halved time steps. Plot <span class="math">\(S\)</span>, <span class="math">\(I\)</span>, and <span class="math">\(R\)</span>
versus time for the two last time step sizes in the same plot.</p>
<p><strong>Solution.</strong>
This may be implemented as:</p>
<p>Here is a missing file: SIR_dt</p>
<p>Filename: <code class="docutils literal"><span class="pre">SIR_dt.m</span></code>.</p>
</div>
<div class="section" id="exercise-48-model-an-adaptive-vaccination-campaign">
<span id="sec-de-exer-sirv-padapt"></span><h3>Exercise 48: Model an adaptive vaccination campaign<a class="headerlink" href="#exercise-48-model-an-adaptive-vaccination-campaign" title="Permalink to this headline">¶</a></h3>
<p>In the SIRV model with time-dependent vaccination from
the section <a class="reference internal" href="#sec-de-flu-vaccine-discont"><span>Discontinuous coefficients: a vaccination campaign</span></a>, we want to test the effect
of an adaptive vaccination campaign where vaccination is offered as
long as half of the population is not vaccinated. The campaign starts
after <span class="math">\(\Delta\)</span> days. That is,
<span class="math">\(p=p_0\)</span> if <span class="math">\(V&lt;\frac{1}{2}(S^0+I^0)\)</span> and <span class="math">\(t&gt;\Delta\)</span> days,
otherwise <span class="math">\(p=0\)</span>.</p>
<p>Demonstrate the effect of this vaccination policy: choose <span class="math">\(\beta\)</span>,
<span class="math">\(\gamma\)</span>, and <span class="math">\(\nu\)</span> as in the section <a class="reference internal" href="#sec-de-flu-vaccine-discont"><span>Discontinuous coefficients: a vaccination campaign</span></a>,
set <span class="math">\(p=0.001\)</span>, <span class="math">\(\Delta =10\)</span> days, and simulate for 200 days.</p>
<p><strong>Hint.</strong>
This discontinuous <span class="math">\(p(t)\)</span> function is easiest implemented as a
Matlab function containing the indicated <code class="docutils literal"><span class="pre">if</span></code> test.
You may use the file <code class="docutils literal"><span class="pre">SIRV1.m</span></code>
as starting point, but note that it implements a time-dependent
<span class="math">\(p(t)\)</span> via an array.</p>
<p><strong>Solution.</strong>
An appropriate program is</p>
<p>Here is a missing file: SIRV_p_adapt</p>
<p>The result looks like</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/SIRV_p_adapt.png"><img alt="_images/SIRV_p_adapt.png" src="_images/SIRV_p_adapt.png" style="width: 600px;" /></a>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">SIRV_p_adapt.m</span></code>.</p>
</div>
<div class="section" id="exercise-49-make-a-sirv-model-with-time-limited-effect-of-vaccination">
<span id="id2"></span><h3>Exercise 49: Make a SIRV model with time-limited effect of vaccination<a class="headerlink" href="#exercise-49-make-a-sirv-model-with-time-limited-effect-of-vaccination" title="Permalink to this headline">¶</a></h3>
<p>We consider the SIRV model from
the section <a class="reference internal" href="#sec-de-flu-vaccine"><span>Incorporating vaccination</span></a>, but now the effect of vaccination is
time-limited. After a characteristic period of time, <span class="math">\(\pi\)</span>, the
vaccination is no more effective and individuals are
consequently moved from the V
to the S category and can be infected again. Mathematically, this
can be modeled as an average leakage <span class="math">\(-\pi^{-1}V\)</span> from the V category to the S
category (i.e., a gain <span class="math">\(\pi^{-1}V\)</span> in the latter). Write up the
complete model, implement it, and rerun the case from
the section <a class="reference internal" href="#sec-de-flu-vaccine"><span>Incorporating vaccination</span></a> with various choices of parameters to
illustrate various effects.
Filename: <code class="docutils literal"><span class="pre">SIRV1_V2S.m</span></code>.</p>
</div>
<div class="section" id="exercise-50-refactor-a-flat-program">
<span id="sec-de-exer-vib-fe-func"></span><h3>Exercise 50: Refactor a flat program<a class="headerlink" href="#exercise-50-refactor-a-flat-program" title="Permalink to this headline">¶</a></h3>
<p>Consider the file <code class="docutils literal"><span class="pre">osc_FE.m</span></code> implementing the Forward Euler
method for the oscillating system model
<a href="#equation-sec:de:model:osc2:u">(24)</a>-<a href="#equation-sec:de:model:osc2:v">(25)</a>.
The <code class="docutils literal"><span class="pre">osc_FE.m</span></code> is what we often refer to as a flat program,
meaning that it is just one main program with no functions.
To easily reuse the numerical computations in other contexts,
place the part that produces the numerical solution (allocation of arrays,
initializing the arrays at time zero, and the time loop) in
a function <code class="docutils literal"><span class="pre">osc_FE(X_0,</span> <span class="pre">omega,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>, which returns <code class="docutils literal"><span class="pre">u,</span> <span class="pre">v,</span> <span class="pre">t</span></code>.
Place the particular
computational example in <code class="docutils literal"><span class="pre">osc_FE.m</span></code> in a function
<code class="docutils literal"><span class="pre">demo()</span></code>.
Construct the file <code class="docutils literal"><span class="pre">osc_FE_func.m</span></code> such that the
<code class="docutils literal"><span class="pre">osc_FE</span></code> function can easily be reused
in other programs.</p>
<p><strong>Solution.</strong>
Here is the file
<code class="docutils literal"><span class="pre">osc_FE.m</span></code>:</p>
<p>Here is a missing file: osc_FE</p>
<p>which is run from the demo file:</p>
<p>Here is a missing file: demo_osc_FE</p>
<p>Filename: <code class="docutils literal"><span class="pre">osc_FE_func.m</span></code>.</p>
</div>
<div class="section" id="exercise-51-simulate-oscillations-by-a-general-ode-solver">
<span id="sec-de-exer-vib-ode-fe"></span><h3>Exercise 51: Simulate oscillations by a general ODE solver<a class="headerlink" href="#exercise-51-simulate-oscillations-by-a-general-ode-solver" title="Permalink to this headline">¶</a></h3>
<p>Solve the system <a href="#equation-sec:de:model:osc2:u">(24)</a>-<a href="#equation-sec:de:model:osc2:v">(25)</a>
using the general solver <code class="docutils literal"><span class="pre">ode_FE</span></code> in the file <code class="docutils literal"><span class="pre">ode_system_FE.m</span></code>
described in the section <a class="reference internal" href="#sec-de-flu-prog-generic"><span>Programming the numerical method; the general case</span></a>. Program the ODE system
and the call to the <code class="docutils literal"><span class="pre">ode_FE</span></code> function in a separate file
<code class="docutils literal"><span class="pre">osc_ode_FE.m</span></code>.</p>
<p>Equip this file with a test function that reads a file with correct
<span class="math">\(u\)</span> values and compares these with those computed by the <code class="docutils literal"><span class="pre">ode_FE</span></code>
function. To find correct <span class="math">\(u\)</span> values, modify the program
<code class="docutils literal"><span class="pre">osc_FE.m</span></code> to dump the <code class="docutils literal"><span class="pre">u</span></code> array to file, run <code class="docutils literal"><span class="pre">osc_FE.m</span></code>, and
let the test function read the reference results from that file.</p>
<p><strong>Solution.</strong>
The program may be implemented as:</p>
<p>Here is a missing file: osc_ode_FE</p>
<p>Filename: <code class="docutils literal"><span class="pre">osc_ode_FE.m</span></code>.</p>
</div>
<div class="section" id="exercise-52-compute-the-energy-in-oscillations">
<span id="sec-de-exer-vib-be"></span><h3>Exercise 52: Compute the energy in oscillations<a class="headerlink" href="#exercise-52-compute-the-energy-in-oscillations" title="Permalink to this headline">¶</a></h3>
<p><strong>a)</strong>
Make a function <code class="docutils literal"><span class="pre">osc_energy(u,</span> <span class="pre">v,</span> <span class="pre">omega)</span></code> for returning the potential and
kinetic energy of an oscillating system described by
<a href="#equation-sec:de:model:osc2:u">(24)</a>-<a href="#equation-sec:de:model:osc2:v">(25)</a>.
The potential energy is taken as <span class="math">\(\frac{1}{2}\omega^2u^2\)</span> while
the kinetic energy is <span class="math">\(\frac{1}{2}v^2\)</span>. (Note that these expressions
are not exactly the <em>physical</em> potential and kinetic energy, since
these would be <span class="math">\(\frac{1}{2}mv^2\)</span> and <span class="math">\(\frac{1}{2}ku^2\)</span> for a model
<span class="math">\(mx'' + kx=0\)</span>.)</p>
<p>Place the <code class="docutils literal"><span class="pre">osc_energy</span></code> in a separate file <code class="docutils literal"><span class="pre">osc_energy.m</span></code>
such that the function can be called from other functions.</p>
<p><strong>Solution.</strong>
The function may be implemented as:</p>
<p>Here is a missing file: osc_energy</p>
<p><strong>b)</strong>
Add a call to <code class="docutils literal"><span class="pre">osc_energy</span></code> in the programs <code class="docutils literal"><span class="pre">osc_FE.m</span></code> and
<code class="docutils literal"><span class="pre">osc_EC.m</span></code> and plot the <em>sum</em> of the kinetic and potential energy.
How does the total energy develop for the Forward Euler and the
Euler-Cromer schemes?</p>
<p><strong>Solution.</strong>
The Forward Euler code reads</p>
<p>Here is a missing file: osc_FE_energy</p>
<p>The program generates the following plot showing how the energy increases with time.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_FE_energy.png"><img alt="_images/osc_FE_energy.png" src="_images/osc_FE_energy.png" style="width: 600px;" /></a>
</div>
<p>The Euler-Cromer code might be implemented as</p>
<p>Here is a missing file: osc_EC_energy</p>
<p>In this case, as illustrated by the plot produced, the energy does not increase.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_EC_energy.png"><img alt="_images/osc_EC_energy.png" src="_images/osc_EC_energy.png" style="width: 600px;" /></a>
</div>
<p>Filenames: <code class="docutils literal"><span class="pre">osc_energy.m</span></code>, <code class="docutils literal"><span class="pre">osc_FE_energy.m</span></code>, <code class="docutils literal"><span class="pre">osc_EC_energy.m</span></code>.</p>
</div>
<div class="section" id="exercise-53-use-a-backward-euler-scheme-for-population-growth">
<span id="sec-de-exer-pg-be"></span><h3>Exercise 53: Use a Backward Euler scheme for population growth<a class="headerlink" href="#exercise-53-use-a-backward-euler-scheme-for-population-growth" title="Permalink to this headline">¶</a></h3>
<p>We consider the ODE problem <span class="math">\(N'(t)=rN(t)\)</span>,
<span class="math">\(N(0)=N_0\)</span>. At some time, <span class="math">\(t_n=n\Delta t\)</span>,
we can approximate the derivative <span class="math">\(N'(t_n)\)</span> by a <em>backward difference</em>,
see Figure <a class="reference internal" href="#sec-de-fig-be"><span>Illustration of a backward difference approximation to the derivative</span></a>:</p>
<div class="math">
\[N'(t_n)\approx \frac{N(t_n) - N(t_n-\Delta t)}{\Delta t} = \frac{N^n - N^{n-1}}{\Delta t},\]</div>
<p>which leads to</p>
<div class="math">
\[\frac{N^n - N^{n-1}}{\Delta t} = rN^n\thinspace,\]</div>
<p>called the <em>Backward Euler scheme</em>.</p>
<p><strong>a)</strong>
Find an expression for the <span class="math">\(N^n\)</span> in terms of <span class="math">\(N^{n-1}\)</span> and formulate
an algorithm for computing <span class="math">\(N^n\)</span>, <span class="math">\(n=1,2,\ldots,N_t\)</span>.</p>
<p><strong>Solution.</strong>
Re-arranging the given expression leads to:</p>
<div class="math">
\[N^n = \frac{N^{n-1}}{1-r\Delta t}.\]</div>
<p>Noting that the right hand side may be expressed by use of <span class="math">\(N^0\)</span>, we
may formulate the following algorithm:</p>
<p>For <span class="math">\(n = 1,2,...,N\)</span> compute</p>
<div class="math">
\[N^n = \left(1-r\Delta t\right)^{-n} N^0.\]</div>
<p><strong>b)</strong>
Implement the algorithm in a) in a function <code class="docutils literal"><span class="pre">growth_BE(N_0,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>
for solving <span class="math">\(N'=rN\)</span>, <span class="math">\(N(0)=N_0\)</span>, <span class="math">\(t\in (0,T]\)</span>, with time step <span class="math">\(\Delta t\)</span> (<code class="docutils literal"><span class="pre">dt</span></code>).</p>
<p><strong>Solution.</strong>
Here is the code:</p>
<p>Here is a missing file: growth_BE</p>
<p><strong>c)</strong>
Implement the Forward Euler scheme in a function <code class="docutils literal"><span class="pre">growth_FE(N_0,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>
as described in b).</p>
<p><strong>Solution.</strong>
The FE function reads:</p>
<p>Here is a missing file: growth_FE</p>
<p>To use the two functions and produce the requested results, we
implemented the following function:</p>
<p>Here is a missing file: apply_growth_BE_and_FE</p>
<p>The two plots generated are seen below.</p>
<p><strong>d)</strong>
Compare visually the solution produced by the Forward and Backward
Euler schemes with the exact solution when <span class="math">\(r=1\)</span> and <span class="math">\(T=6\)</span>. Make
two plots, one with
<span class="math">\(\Delta t = 0.5\)</span> and one with <span class="math">\(\Delta t=0.05\)</span>.</p>
<p><strong>Solution.</strong>
With a time step of 0.5, the BE approach deviates substantially more
from the true solution than the FE. This is a consequence of the very large
time step used.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/growth_BE_FE_dt05.png"><img alt="_images/growth_BE_FE_dt05.png" src="_images/growth_BE_FE_dt05.png" style="width: 600px;" /></a>
</div>
<p>Reducing the time step to 0.05 improves the situation for BE, so that
FE and BE now give approximately the same error at each time step, but
with opposite signs.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/growth_BE_FE_dt005.png"><img alt="_images/growth_BE_FE_dt005.png" src="_images/growth_BE_FE_dt005.png" style="width: 600px;" /></a>
</div>
<p>With both time steps and both methods, the error grows with time. It should
be noted that the graph produced with FE is <em>below</em> the true solution, while
the one from BE is <em>above</em>. This should be expected because of the following.
The slope of the true graph (or solution) increases with time. The FE does, at
each time step, use the derivative from the <em>beginning</em> of the time step. This
derivative is the smallest on the time interval covered by that time step. Therefore,
the corresponding graph ends up below the true one. With BE, it is the other
way around, since it uses the derivative at the <em>end</em> of each timestep, which
then is the largest derivative on the time interval covered by that time step.</p>
<p>Filename: <code class="docutils literal"><span class="pre">growth_BE.m</span></code>.</p>
</div>
<div class="section" id="exercise-54-use-a-crank-nicolson-scheme-for-population-growth">
<span id="sec-de-exer-pg-cn"></span><h3>Exercise 54: Use a Crank-Nicolson scheme for population growth<a class="headerlink" href="#exercise-54-use-a-crank-nicolson-scheme-for-population-growth" title="Permalink to this headline">¶</a></h3>
<p>It is recommended to do <a class="reference internal" href="#sec-de-exer-pg-be"><span>Exercise 53: Use a Backward Euler scheme for population growth</span></a> prior to the
present one.
Here we look at the same population growth model <span class="math">\(N'(t)=rN(t)\)</span>, <span class="math">\(N(0)=N_0\)</span>.
The time derivative <span class="math">\(N'(t)\)</span> can be approximated by various types of
finite differences. <a class="reference internal" href="#sec-de-exer-pg-be"><span>Exercise 53: Use a Backward Euler scheme for population growth</span></a> considers
a backward difference (Figure <a class="reference internal" href="#sec-de-fig-be"><span>Illustration of a backward difference approximation to the derivative</span></a>), while the section <a class="reference internal" href="#sec-de-pg-numerics"><span>Numerical solution  (1)</span></a> explained the forward difference (Figure <a class="reference internal" href="#sec-de-fig-fe"><span>Illustration of a forward difference approximation to the derivative</span></a>).
A <em>centered difference</em> is more accurate than a backward or forward
difference:</p>
<div class="math">
\[N'(t_n+\frac{1}{2}\Delta t)\approx\frac{N(t_n+\Delta t)-N(t_n)}{\Delta t}=
\frac{N^{n+1}-N^n}{\Delta t}\thinspace .\]</div>
<p>This type of difference, applied at the point <span class="math">\(t_{n+\frac{1}{2}}=t_n +
\frac{1}{2}\Delta t\)</span>, is illustrated geometrically in Figure
<a class="reference internal" href="#sec-de-fig-cn"><span>Illustration of a centered difference approximation to the derivative</span></a>.</p>
<p><strong>a)</strong>
Insert the finite difference approximation in the ODE <span class="math">\(N'=rN\)</span> and
solve for the unknown <span class="math">\(N^{n+1}\)</span>, assuming <span class="math">\(N^n\)</span> is already computed and
hence known. The resulting computational scheme is often referred
to as a <em>Crank-Nicolson</em> scheme.</p>
<p><strong>Solution.</strong>
With a central difference approximation used for the derivative, we also
need to reformulate the function (expressing the derivative) on the right
hand side to include the unknowns that we want only. For the right hand
side we use the average of the derivative from <span class="math">\(n\)</span> and <span class="math">\(n+1\)</span>, i.e. at
each end of the time step. We then get</p>
<div class="math">
\[\frac{N^{n+1} - N^n}{\Delta t} = \frac{1}{2}(rN^n + rN^{n+1})\thinspace,\]</div>
<p>which means that</p>
<div class="math">
\[N^{n+1} - \frac{\Delta t}{2}rN^{n+1} = N^n + \frac{\Delta t}{2}(rN^n)\thinspace.\]</div>
<p>Isolating <span class="math">\(N^{n+1}\)</span>, we get the Crank-Nicolson scheme as</p>
<div class="math">
\[N^{n+1} =  \frac{1+\frac{\Delta t}{2}r}{1-\frac{\Delta t}{2}r} N^n\thinspace.\]</div>
<p><strong>b)</strong>
Implement the algorithm in a) in a function <code class="docutils literal"><span class="pre">growth_CN(N_0,</span> <span class="pre">dt,</span> <span class="pre">T)</span></code>
for solving <span class="math">\(N'=rN\)</span>, <span class="math">\(N(0)=N_0\)</span>, <span class="math">\(t\in (0,T]\)</span>, with time step <span class="math">\(\Delta t\)</span> (<code class="docutils literal"><span class="pre">dt</span></code>).</p>
<p><strong>Solution.</strong>
The function was implemented as</p>
<p>Here is a missing file: growth_CN</p>
<p><strong>c)</strong>
Make plots for comparing
the Crank-Nicolson scheme with the Forward and Backward Euler
schemes in the same test problem as in
<a class="reference internal" href="#sec-de-exer-pg-be"><span>Exercise 53: Use a Backward Euler scheme for population growth</span></a>.</p>
<p><strong>Solution.</strong>
To use the CN function and produce the requested results, we
implemented the following function:</p>
<p>Here is a missing file: apply_growth_CN</p>
<p>With a time step of 0.5, we get the following plot:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/growth_CN_dt05.png"><img alt="_images/growth_CN_dt05.png" src="_images/growth_CN_dt05.png" style="width: 600px;" /></a>
</div>
<p>Reducing the time step to 0.05, it changes into:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/growth_CN_dt005.png"><img alt="_images/growth_CN_dt005.png" src="_images/growth_CN_dt005.png" style="width: 600px;" /></a>
</div>
<p>We observe that CN produces the best solution of the three alternatives.
This should be expected, since it is the most accurate one (second order
accuracy compared to first order with FE and BE).</p>
<p>Filename: <code class="docutils literal"><span class="pre">growth_CN.m</span></code>.</p>
</div>
<div class="section" id="exercise-55-understand-finite-differences-via-taylor-series">
<span id="sec-de-exer-fd-taylor"></span><h3>Exercise 55: Understand finite differences via Taylor series<a class="headerlink" href="#exercise-55-understand-finite-differences-via-taylor-series" title="Permalink to this headline">¶</a></h3>
<p>The Taylor series around a point <span class="math">\(x=a\)</span> can for a function <span class="math">\(f(x)\)</span> be
written</p>
<div class="math">
\[\begin{split}f(x) &amp;= f(a) + \frac{d}{dx}f(a)(x-a) + \frac{1}{2!}\frac{d^2}{dx^2}f(a)(x-a)^2
 + \frac{1}{3!}\frac{d^3}{dx^3}f(a)(x-a)^3 + \ldots\\
&amp; =
\sum_{i=0}^\infty \frac{1}{i!}\frac{d^i}{dx^i}f(a)(x-a)^i\thinspace .\end{split}\]</div>
<p>For a function of time, as addressed in our ODE problems, we would
use <span class="math">\(u\)</span> instead of <span class="math">\(f\)</span>, <span class="math">\(t\)</span> instead of <span class="math">\(x\)</span>, and a time point <span class="math">\(t_n\)</span> instead
of <span class="math">\(a\)</span>:</p>
<div class="math">
\[\begin{split}u(t) &amp;= u(t_n) + \frac{d}{dt}u(t_n)(t-t_n) +
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)(t-t_n)^2
 + \frac{1}{3!}\frac{d^3}{dt^3}u(t_n)(t-t_n)^3 + \ldots\\
&amp; =
\sum_{i=0}^\infty \frac{1}{i!}\frac{d^i}{dt^i}u(t_n)(t-t_n)^i\thinspace .\end{split}\]</div>
<p><strong>a)</strong>
A forward finite difference approximation to the derivative <span class="math">\(f'(a)\)</span> reads</p>
<div class="math">
\[u'(t_n) \approx \frac{u(t_n+\Delta t)- u(t_n)}{\Delta t}\thinspace .\]</div>
<p>We can justify this formula mathematically through Taylor series.
Write up the Taylor series for <span class="math">\(u(t_n+\Delta t)\)</span> (around <span class="math">\(t=t_n\)</span>, as
given above), and then solve the expression with respect to <span class="math">\(u'(t_n)\)</span>.
Identify, on the right-hand side, the finite difference approximation <em>and</em>
an infinite series. This series is then the error in the finite difference
approximation. If <span class="math">\(\Delta t\)</span> is assumed small (i.e. <span class="math">\(\Delta t &lt;&lt; 1\)</span>),
<span class="math">\(\Delta t\)</span> will be much larger than <span class="math">\(\Delta t^2\)</span>, which will be much
larger than <span class="math">\(\Delta t^3\)</span>, and so on. The <em>leading order term</em> in the
series for the error, i.e., the error with the least power of <span class="math">\(\Delta t\)</span>
is a good approximation of the error. Identify this term.</p>
<p><strong>Solution.</strong>
We get</p>
<div class="math">
\[\begin{split}u(t_n+\Delta t) &amp;= u(t_n) + \frac{d}{dt}u(t_n)\Delta t +
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t^2
 + \frac{1}{3!}\frac{d^3}{dt^3}u(t_n)\Delta t^3 + \ldots\\
\frac{d}{dt}u(t_n) &amp; = \frac{u(t_n+\Delta t) - u(t_n)}{\Delta t} -
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t -
 \frac{1}{3!}\frac{d^3}{dt^3}u(t_n)\Delta t^2 + \ldots\\
\thinspace .\end{split}\]</div>
<p>The finite difference approximation is found as the first term on the right
hand side, while the remaining terms make up the infinite series that represents
the error of the finite difference approximation.</p>
<p>The leading order error term is therefore <span class="math">\(-\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t\)</span>.</p>
<p><strong>b)</strong>
Repeat a) for a backward difference:</p>
<div class="math">
\[u'(t_n) \approx \frac{u(t_n)- u(t_n-\Delta t)}{\Delta t}\thinspace .\]</div>
<p>This time, write up the Taylor series for <span class="math">\(u(t_n-\Delta t)\)</span> around
<span class="math">\(t_n\)</span>. Solve with respect to <span class="math">\(u'(t_n)\)</span>, and identify the leading order
term in the error. How is the error compared to the forward difference?</p>
<p><strong>Solution.</strong>
We get</p>
<div class="math">
\[\begin{split}u(t_n-\Delta t) &amp;= u(t_n) - \frac{d}{dt}u(t_n)\Delta t +
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t^2
 - \frac{1}{3!}\frac{d^3}{dt^3}u(t_n)\Delta t^3 + \ldots\\
\frac{d}{dt}u(t_n) &amp; = \frac{u(t_n) - u(t_n-\Delta t)}{\Delta t} +
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t -
 \frac{1}{3!}\frac{d^3}{dt^3}u(t_n)\Delta t^2 + \ldots\\
\thinspace .\end{split}\]</div>
<p>The finite difference approximation is found as the first term on the right
hand side, while the remaining terms make up the infinite series that represents
the error of the finite difference approximation.</p>
<p>The leading order error term is therefore <span class="math">\(+\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t\)</span>,
which is of the same magnitude as the corresponding error in a), but with opposite sign.</p>
<p><strong>c)</strong>
A centered difference approximation to the derivative,
as explored in <a class="reference internal" href="#sec-de-exer-pg-cn"><span>Exercise 54: Use a Crank-Nicolson scheme for population growth</span></a>,
can be written</p>
<div class="math">
\[u'(t_n+\frac{1}{2}\Delta t) \approx \frac{u(t_n+\Delta t)- u(t_n)}{\Delta t}\thinspace .\]</div>
<p>Write up the Taylor series for <span class="math">\(u(t_n)\)</span> around <span class="math">\(t_n+\frac{1}{2}\Delta t\)</span>
and the Taylor series for <span class="math">\(u(t_n+\Delta t)\)</span> around <span class="math">\(t_n+\frac{1}{2}\Delta t\)</span>.
Subtract the two series, solve with respect to
<span class="math">\(u'(t_n+\frac{1}{2}\Delta t)\)</span>, identify the finite difference approximation
and the error terms on the right-hand side, and write up the leading order
error term. How is this term compared to the ones for the forward and
backward differences?</p>
<p><strong>Solution.</strong>
We write</p>
<div class="math">
\[\begin{split}u(t_n) &amp;= u(t_n+\frac{\Delta t}{2}) - \frac{d}{dt}u(t_n+\frac{\Delta t}{2})\frac{\Delta t}{2} +
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n+\frac{\Delta t}{2})\left(\frac{\Delta t}{2}\right)^2 -
 \frac{1}{3!}\frac{d^3}{dt^3}u(t_n+\frac{\Delta t}{2})\left(\frac{\Delta t}{2}\right)^3 + \ldots\\
u(t_n+\Delta t) &amp;= u(t_n+\frac{\Delta t}{2}) + \frac{d}{dt}u(t_n+\frac{\Delta t}{2})\frac{\Delta t}{2} +
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n+\frac{\Delta t}{2})\left(\frac{\Delta t}{2}\right)^2 +
 \frac{1}{3!}\frac{d^3}{dt^3}u(t_n+\frac{\Delta t}{2})\left(\frac{\Delta t}{2}\right)^3 + \ldots\\
\thinspace .\end{split}\]</div>
<p>If we next subtract the first of these two equations from the last one, we may proceed as</p>
<div class="math">
\[\begin{split}u(t_n+\Delta t) - u(t_n) &amp;= 2\frac{d}{dt}u(t_n+\frac{\Delta t}{2})\frac{\Delta t}{2} +
  2\frac{1}{3!}\frac{d^3}{dt^3}u(t_n+\frac{\Delta t}{2})\left(\frac{\Delta t}{2}\right)^3 + \ldots\\
\frac{d}{dt}u(t_n+\frac{\Delta t}{2}) &amp;= \frac{u(t_n+\Delta t) - u(t_n)}{\Delta t} -
 \frac{1}{3!}\frac{d^3}{dt^3}u(t_n+\frac{\Delta t}{2})\left(\frac{\Delta t}{2}\right)^2 - \ldots\\
\thinspace .\end{split}\]</div>
<p>The finite difference approximation is found as the first term on the right
hand side, while the remaining terms make up the infinite series that represents
the error of the finite difference approximation.</p>
<p>The leading order error term is
<span class="math">\(-\frac{1}{3!}\frac{d^3}{dt^3}u(t_n+\frac{\Delta t}{2})\left(\frac{\Delta t}{2}\right)^2\)</span>.
This term will be smaller than the corresponding error terms from the previous approximations
since <span class="math">\(\frac{\Delta t}{2}^2 &lt;&lt; \Delta t\)</span>.</p>
<p><strong>d)</strong>
Can you use the leading order error terms in a)-c) to explain the
visual observations in the numerical experiment in
<a class="reference internal" href="#sec-de-exer-pg-cn"><span>Exercise 54: Use a Crank-Nicolson scheme for population growth</span></a>?</p>
<p><strong>Solution.</strong>
The error term for the centered difference is <span class="math">\(\Delta t^2\)</span> and hence
smaller than the error terms for the forward and backward differences.
Therefore, the Crank-Nicolson curve is closer to the analytical solution.
Also, the error terms of the forward and backward differences are
the same, except for the sign, which explains why the corresponding curves
lie on each side of the analytical solution, with approximately the
same distance. Note: the leading order error term is only a good
approximation to the true error as <span class="math">\(\Delta t\rightarrow 0\)</span>, so for
small <span class="math">\(\Delta t\)</span>, the forward and backward schemes will deviate
an equal amount from the analytical solution in the center, but for
large <span class="math">\(\Delta t\)</span> errors will deviate from this observation (and,
in particular, the backward scheme may give oscillatory solutions for
large <span class="math">\(\Delta t\)</span> in this problem).</p>
<p><strong>e)</strong>
Find the leading order error term in the following standard
finite difference approximation
to the second-order derivative:</p>
<div class="math">
\[u''(t_n) \approx \frac{u(t_n+\Delta t)- 2u(t_n) + u(t_n-\Delta t)}{\Delta t}\thinspace .\]</div>
<p><strong>Hint.</strong>
Express <span class="math">\(u(t_n\pm \Delta t)\)</span> via Taylor series and insert them in
the difference formula.</p>
<p><strong>Solution.</strong>
We write</p>
<div class="math">
\[\begin{split}u(t_n+\Delta t) &amp;= u(t_n) + \frac{d}{dt}u(t_n)\Delta t +
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t^2 +
 \frac{1}{3!}\frac{d^3}{dt^3}u(t_n)\Delta t^3 + \ldots\\
u(t_n-\Delta t) &amp;= u(t_n) - \frac{d}{dt}u(t_n)\Delta t +
\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t^2 -
 \frac{1}{3!}\frac{d^3}{dt^3}u(t_n)\Delta t^3 + \ldots\\
\thinspace .\end{split}\]</div>
<p>If we now add the two equations, it gives us</p>
<div class="math">
\[u(t_n+\Delta t) + u(t_n-\Delta t) = 2 u(t_n) +
2\frac{1}{2!}\frac{d^2}{dt^2}u(t_n)\Delta t^2 +
2\frac{1}{4!}\frac{d^4}{dt^4}u(t_n)\Delta t^4 + \ldots\thinspace .\]</div>
<p>This allows us to isolate <span class="math">\(u''(t_n)\)</span> on the left hand side as</p>
<div class="math">
\[\frac{d^2}{dt^2}u(t_n) = \frac{u(t_n+\Delta t) - 2 u(t_n) + u(t_n-\Delta t)}{\Delta t^2} -
2\frac{1}{4!}\frac{d^4}{dt^4}u(t_n)\Delta t^2 - \ldots\thinspace .\]</div>
<p>The leading error term therefore appears as <span class="math">\(-2\frac{1}{4!}\frac{d^4}{dt^4}u(t_n)\Delta t^2\)</span>.</p>
<p>Filename: <code class="docutils literal"><span class="pre">Taylor_differences.pdf</span></code>.</p>
</div>
<div class="section" id="exercise-56-use-a-backward-euler-scheme-for-oscillations">
<span id="id3"></span><h3>Exercise 56: Use a Backward Euler scheme for oscillations<a class="headerlink" href="#exercise-56-use-a-backward-euler-scheme-for-oscillations" title="Permalink to this headline">¶</a></h3>
<p>Consider <a href="#equation-sec:de:model:osc2:u">(24)</a>-<a href="#equation-sec:de:model:osc2:v">(25)</a>
modeling an oscillating engineering system. This <span class="math">\(2\times 2\)</span> ODE system
can be solved by the <em>Backward Euler scheme</em>, which is based on
discretizing derivatives by collecting information backward
in time. More specifically, <span class="math">\(u'(t)\)</span> is approximated as</p>
<div class="math">
\[u'(t) \approx \frac{u(t) - u(t-\Delta t)}{\Delta t}\thinspace .\]</div>
<p>A general vector ODE <span class="math">\(u'=f(u,t)\)</span>, where <span class="math">\(u\)</span> and <span class="math">\(f\)</span> are vectors,
can use this approximation as follows:</p>
<div class="math">
\[\frac{u^{n} - u^{n-1}}{\Delta t} = f(u^n,t_n),\]</div>
<p>which leads to an equation for the new value <span class="math">\(u^n\)</span>:</p>
<div class="math">
\[u^n -\Delta tf(u^n,t_n) = u^{n-1}\thinspace .\]</div>
<p>For a general <span class="math">\(f\)</span>, this is a system of <em>nonlinear algebraic equations</em>.</p>
<p>However, the ODE <a href="#equation-sec:de:model:osc2:u">(24)</a>-<a href="#equation-sec:de:model:osc2:v">(25)</a>
is <em>linear</em>, so a Backward Euler scheme leads to a system of two
algebraic equations for two unknowns:</p>
<div class="math" id="equation-vib:undamped:BE1">
<span id="eq-vib-undamped-be1"></span><span class="eqno">(56)</span>\[     u^{n} - \Delta t v^{n} = u^{n-1},\]</div>
<div class="math" id="equation-vib:undamped:BE2">
<span id="eq-vib-undamped-be2"></span><span class="eqno">(57)</span>\[     v^{n} + \Delta t \omega^2 u^{n} = v^{n-1}\]\[     \thinspace .\]</div>
<p><strong>a)</strong>
Solve the system for <span class="math">\(u^n\)</span> and <span class="math">\(v^n\)</span>.</p>
<p><strong>Solution.</strong>
In the first of these equations, we may isolate <span class="math">\(u^n\)</span> on the left hand side.
This gives</p>
<div class="math">
\[u^n = \Delta t v^n + u^{n-1}\thinspace .\]</div>
<p>Inserting this for <span class="math">\(u^n\)</span> in the second equation, we can solve for <span class="math">\(v^n\)</span>. That is,</p>
<div class="math">
\[v^n + \Delta t \omega^2 (\Delta t v^n + u^{n-1}) = v^{n-1}\thinspace ,\]</div>
<p>so that</p>
<div class="math">
\[v^n = \frac{1}{1 + (\Delta t \omega)^2}(-\Delta t \omega^2 u^{n-1} + v^{n-1})\thinspace .\]</div>
<p>Finally, we may insert this expression for <span class="math">\(v^n\)</span> into the one for <span class="math">\(u^n\)</span>, which gives</p>
<div class="math">
\[u^n = \Delta t (\frac{1}{1 + (\Delta t \omega)^2}(-\Delta t \omega^2 u^{n-1} + v^{n-1})) + u^{n-1}\thinspace .\]</div>
<p>Simplifying, we arrive at</p>
<div class="math">
\[u^n = \frac{\Delta t v^{n-1} + u^{n-1}}{1 + (\Delta t \omega)^2}\thinspace .\]</div>
<p>Thus, we have an explicit scheme for advancing the solution <span class="math">\(v^n\)</span> and <span class="math">\(u^n\)</span> in time.</p>
<p><strong>b)</strong>
Implement the found formulas for <span class="math">\(u^n\)</span> and <span class="math">\(v^n\)</span>
in a program for computing the entire numerical solution of
<a href="#equation-sec:de:model:osc2:u">(24)</a>-<a href="#equation-sec:de:model:osc2:v">(25)</a>.</p>
<p><strong>Solution.</strong></p>
<p>Here is a missing file: osc_BE</p>
<p><strong>c)</strong>
Run the program with a <span class="math">\(\Delta t\)</span> corresponding to 20 time steps per
period of the oscillations (see the section <a class="reference internal" href="#sec-de-vib-special"><span>Programming the numerical method; the special case  (2)</span></a>
for how to find such a <span class="math">\(\Delta t\)</span>). What do you observe?
Increase to 2000 time steps per period. How much does this improve
the solution?</p>
<p><strong>Solution.</strong>
With 20 time steps per period, the oscillations develop as</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_BE_20.png"><img alt="_images/osc_BE_20.png" src="_images/osc_BE_20.png" style="width: 600px;" /></a>
</div>
<p>Changing to 2000 time steps per period, the solution improves dramatically into</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_BE_2000.png"><img alt="_images/osc_BE_2000.png" src="_images/osc_BE_2000.png" style="width: 600px;" /></a>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">osc_BE.m</span></code>.</p>
<div class="section" id="remarks-6">
<h4>Remarks  (6)<a class="headerlink" href="#remarks-6" title="Permalink to this headline">¶</a></h4>
<p>While the Forward Euler method applied to oscillation problems
<span class="math">\(u''+\omega^2u=0\)</span> gives growing amplitudes, the Backward Euler
method leads to significantly damped amplitudes.</p>
</div>
</div>
<div class="section" id="exercise-57-use-heun-s-method-for-the-sir-model">
<span id="sec-de-exer-sir-heun"></span><h3>Exercise 57: Use Heun&#8217;s method for the SIR model<a class="headerlink" href="#exercise-57-use-heun-s-method-for-the-sir-model" title="Permalink to this headline">¶</a></h3>
<p>Make a program that computes the solution of the SIR model from
the section <a class="reference internal" href="#sec-de-flu"><span>Spreading of a flu</span></a> both by the Forward Euler method and by Heun&#8217;s method
(or equivalently: the 2nd-order Runge-Kutta method) from
the section <a class="reference internal" href="#sec-de-osc-heun"><span>The 2nd-order Runge-Kutta method (or Heun&#8217;s method)</span></a>. Compare the two methods in
the simulation case from the section <a class="reference internal" href="#sec-de-flu-prog-spec"><span>Programming the numerical method; the special case  (1)</span></a>.
Make two comparison plots, one for a large and one for a
small time step. Experiment to find what &#8220;large&#8221; and &#8220;small&#8221;
should be: the large one gives significant differences, while
the small one lead to very similar curves.</p>
<p><strong>Solution.</strong></p>
<p>Here is a missing file: SIR_Heun</p>
<p>With a (large) time step of <span class="math">\(24 h\)</span>, we get the following behavior,</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/SIR_H_large_dt_eq_24.png"><img alt="_images/SIR_H_large_dt_eq_24.png" src="_images/SIR_H_large_dt_eq_24.png" style="width: 600px;" /></a>
</div>
<p>Reducing the time step to <span class="math">\(4 h\)</span>, the curves get very similar.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/SIR_H_small_dt_eq_4.png"><img alt="_images/SIR_H_small_dt_eq_4.png" src="_images/SIR_H_small_dt_eq_4.png" style="width: 600px;" /></a>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">SIR_Heun.m</span></code>.</p>
</div>
<div class="section" id="exercise-58-use-odespy-to-solve-a-simple-ode">
<span id="sec-de-exer-odespy-decay"></span><h3>Exercise 58: Use Odespy to solve a simple ODE<a class="headerlink" href="#exercise-58-use-odespy-to-solve-a-simple-ode" title="Permalink to this headline">¶</a></h3>
<p>Solve</p>
<div class="math">
\[u' = -au + b,\quad u(0)=U_0,\quad t\in (0,T]\]</div>
<p>by the Odespy software. Let the problem parameters <span class="math">\(a\)</span> and <span class="math">\(b\)</span>
be arguments to the right-hand side function that specifies the
ODE to be solved. Plot the solution for the case when
<span class="math">\(a=2\)</span>, <span class="math">\(b=1\)</span>, <span class="math">\(T=6/a\)</span>, and we use 100 time intervals in <span class="math">\([0,T]\)</span>.</p>
<p><strong>Solution.</strong></p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">odespy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="o">*</span><span class="n">u</span> <span class="o">+</span> <span class="n">b</span>

<span class="c"># Problem parameters</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">U0</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">method</span> <span class="o">=</span> <span class="n">odespy</span><span class="o">.</span><span class="n">RK2</span>

<span class="c"># Run Odespy solver</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">f_args</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="n">solver</span><span class="o">.</span><span class="n">set_initial_condition</span><span class="p">(</span><span class="n">U0</span><span class="p">)</span>
<span class="n">T</span> <span class="o">=</span> <span class="mf">6.0</span><span class="o">/</span><span class="n">a</span>  <span class="c"># final simulation time</span>
<span class="n">N_t</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c"># no of intervals</span>
<span class="n">time_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N_t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">time_points</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">odespy_demo.m</span></code>.</p>
</div>
<div class="section" id="exercise-59-set-up-a-backward-euler-scheme-for-oscillations">
<span id="sec-de-exer-osc-be"></span><h3>Exercise 59: Set up a Backward Euler scheme for oscillations<a class="headerlink" href="#exercise-59-set-up-a-backward-euler-scheme-for-oscillations" title="Permalink to this headline">¶</a></h3>
<p>Write the ODE <span class="math">\(u'' + \omega^2u=0\)</span> as a system of two first-order
ODEs and discretize these with backward differences as illustrated
in Figure <a class="reference internal" href="#sec-de-fig-be"><span>Illustration of a backward difference approximation to the derivative</span></a>. The resulting method is referred to as
a Backward Euler scheme. Identify the matrix and right-hand side
of the linear system that has to be solved at each time level.
Implement the method, either from scratch yourself or using
Odespy (the name is <code class="docutils literal"><span class="pre">odespy.BackwardEuler</span></code>).
Demonstrate that contrary to a Forward Euler scheme, the Backward
Euler scheme leads to significant non-physical damping. The figure
below shows that even with 60 time steps per period, the results
after a few periods are useless:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_odespy_BE.png"><img alt="_images/osc_odespy_BE.png" src="_images/osc_odespy_BE.png" style="width: 600px;" /></a>
</div>
<p><strong>Solution.</strong>
The first-order system is</p>
<div class="math">
\[\begin{split}v' &amp;= -\omega^2 u\\
u' &amp;= v\end{split}\]</div>
<p>Backward differences mean</p>
<div class="math">
\[\begin{split}\frac{v^{n}-v^{n-1}}{\Delta t} &amp;= -\omega^2 u^n\\
\frac{u^{n}-u^{n-1}}{\Delta t} &amp;= v^n\end{split}\]</div>
<p>Collecting the unknowns <span class="math">\(u^n\)</span> and <span class="math">\(v^n\)</span> on the left-hand side,</p>
<div class="math">
\[\begin{split}v^{n} + \Delta t\omega^2 u^n &amp;= v^{n-1} \\
u^{n} - \Delta t v^n &amp;= u^{n-1}\end{split}\]</div>
<p>shows that this is a coupled <span class="math">\(2\times 2\)</span> system for <span class="math">\(u^n\)</span> and <span class="math">\(v^n\)</span>:</p>
<div class="math">
\[\begin{split}\left(\begin{array}{cc}
1 &amp; \Delta t\omega^2\\
-\Delta t &amp; 1
\end{array}\right)
\left(\begin{array}{c}
v^n\\
u^n
\end{array}\right)
=
\left(\begin{array}{c}
v^{n-1}\\
u^{n-1}
\end{array}\right)\end{split}\]</div>
<p>The simplest way of implementing the scheme is to use the
<code class="docutils literal"><span class="pre">osc_odespy.py</span></code> code explained in the section <a class="reference internal" href="#sec-de-osc-odespy"><span>Odespy: software for solving ODEs</span></a>
and make a call</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">compare</span><span class="p">(</span><span class="n">odespy_methods</span><span class="o">=</span><span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">EulerCromer</span><span class="p">,</span> <span class="n">odespy</span><span class="o">.</span><span class="n">BackwardEuler</span><span class="p">],</span>
        <span class="n">omega</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">X_0</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">number_of_periods</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
        <span class="n">time_intervals_per_period</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">osc_BE.m</span></code>.</p>
</div>
<div class="section" id="exercise-60-set-up-a-forward-euler-scheme-for-nonlinear-and-damped-oscillations">
<span id="sec-de-exer-osc-fe-general"></span><h3>Exercise 60: Set up a Forward Euler scheme for nonlinear and damped oscillations<a class="headerlink" href="#exercise-60-set-up-a-forward-euler-scheme-for-nonlinear-and-damped-oscillations" title="Permalink to this headline">¶</a></h3>
<p>Derive a Forward Euler method for the ODE system
<a href="#equation-sec:de:vib:ode2:v">(42)</a>-<a href="#equation-sec:de:vib:ode2:u">(43)</a>.
Compare the method with the Euler-Cromer scheme for
the sliding friction problem
from the section <a class="reference internal" href="#sec-de-vib-ode2-sliding-friction"><span>Spring-mass system with sliding friction</span></a>:</p>
<ol class="arabic simple">
<li>Does the Forward Euler scheme give growing amplitudes?</li>
<li>Is the period of oscillation accurate?</li>
<li>What is the required time step size for the two methods to
have visually coinciding curves?</li>
</ol>
<p><strong>Solution.</strong>
A Forward Euler scheme is easy to derive:</p>
<div class="math" id="equation-sec:de:vib:ode2:v:FE1">
<span id="eq-sec-de-vib-ode2-v-fe1"></span><span class="eqno">(58)</span>\[     \frac{v^{n+1}-v^n}{\Delta t} = \frac{1}{m}\left(F(t_n) - s(u^n) - f(v^n)\right),\]</div>
<div class="math" id="equation-sec:de:vib:ode2:u:FE1">
<span id="eq-sec-de-vib-ode2-u-fe1"></span><span class="eqno">(59)</span>\[     \frac{u^{n+1}-u^n}{\Delta t} = v^n,\]</div>
<p>which is, as usual, reordered to the algorithmic form</p>
<div class="math" id="equation-sec:de:vib:ode2:v:FE2">
<span id="eq-sec-de-vib-ode2-v-fe2"></span><span class="eqno">(60)</span>\[     v^{n+1} = v^n + \frac{\Delta t}{m}\left(F(t_n) - s(u^n) - f(v^n)\right),\]</div>
<div class="math" id="equation-sec:de:vib:ode2:u:FE2">
<span id="eq-sec-de-vib-ode2-u-fe2"></span><span class="eqno">(61)</span>\[     u^{n+1} = u^n + \Delta t v^n\thinspace .\]</div>
<p>However, we have already seen that the Forward Euler method is not
well suited for simulating oscillations as the scheme gives rise
to a non-physical, growing amplitude. It remains to see how
damped systems are treated.</p>
<p>An implementation can be done utilizing Odespy and the <code class="docutils literal"><span class="pre">compare</span></code>
function in <code class="docutils literal"><span class="pre">osc_odespy_general.py</span></code>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">sliding_friction</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">tanh</span><span class="p">,</span> <span class="n">sign</span>

    <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">mu</span><span class="o">*</span><span class="n">m</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">sign</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">60.0</span>
    <span class="n">s</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">u</span><span class="p">:</span> <span class="n">k</span><span class="o">/</span><span class="n">alpha</span><span class="o">*</span><span class="n">tanh</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">u</span><span class="p">)</span>
    <span class="c">#s = lambda u: k*u</span>
    <span class="n">F</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">0</span>

    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="mf">0.4</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">1000</span>

    <span class="n">U_0</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">V_0</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="mf">100.</span>

    <span class="n">methods</span> <span class="o">=</span> <span class="p">[</span><span class="n">odespy</span><span class="o">.</span><span class="n">EulerCromer</span><span class="p">,</span> <span class="n">odespy</span><span class="o">.</span><span class="n">ForwardEuler</span><span class="p">]</span>
    <span class="n">compare</span><span class="p">(</span><span class="n">methods</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">U_0</span><span class="o">=</span><span class="n">U_0</span><span class="p">,</span> <span class="n">V_0</span><span class="o">=</span><span class="n">V_0</span><span class="p">,</span>
            <span class="n">T</span><span class="o">=</span><span class="n">T</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">start_of_plot</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>With <span class="math">\(\Delta t =10^{-2}\)</span> we get the plot below.</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_FE_general_dt100.png"><img alt="_images/osc_FE_general_dt100.png" src="_images/osc_FE_general_dt100.png" style="width: 600px;" /></a>
</div>
<p>We observe that 1) the amplitude is not growing, it is decaying, but
not at all at the rate it should, compared to the Euler-Cromer
scheme (which we anticipate is fairly accurate, also for this fairly
coarse time resolution), and 2) there is a significant phase error.</p>
<p>Reducing <span class="math">\(\Delta t\)</span> by a factor of 10 increases the accuracy
incredibly:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_FE_general_dt1000.png"><img alt="_images/osc_FE_general_dt1000.png" src="_images/osc_FE_general_dt1000.png" style="width: 600px;" /></a>
</div>
<p>Experimenting a bit, we arrive at <span class="math">\(\Delta t=5\cdot 10^{-3}\)</span> as
a time step size where the two methods gives approximately equal
results:</p>
<div class="figure">
<a class="reference internal image-reference" href="_images/osc_FE_general_dt5000.png"><img alt="_images/osc_FE_general_dt5000.png" src="_images/osc_FE_general_dt5000.png" style="width: 600px;" /></a>
</div>
<p>Filename: <code class="docutils literal"><span class="pre">osc_FE_general.m</span></code>.</p>
</div>
<div class="section" id="exercise-61-discretize-an-initial-condition">
<span id="sec-de-exer-osc-2nd-v0ic"></span><h3>Exercise 61: Discretize an initial condition<a class="headerlink" href="#exercise-61-discretize-an-initial-condition" title="Permalink to this headline">¶</a></h3>
<p>Assume that the initial condition on <span class="math">\(u'\)</span> is nonzero in
the finite difference method from the section <a class="reference internal" href="#sec-de-vib-2nd"><span>A finite difference method; undamped, linear case</span></a>:
<span class="math">\(u'(0)=V_0\)</span>. Derive the special formula for <span class="math">\(u^1\)</span> in this case.</p>
<p><strong>Solution.</strong>
We use the same centered finite difference approximation,</p>
<div class="math">
\[u'(0)\approx = \frac{u^1 - u^{-1}}{2\Delta t}=V_0,\]</div>
<p>which leads to</p>
<div class="math">
\[u^{-1} = u^1 - 2\Delta t\,V_0\thinspace .\]</div>
<p>Using this expression to eliminate <span class="math">\(u^{-1}\)</span> in <a href="#equation-sec:de:vib:2nd:scheme0">(50)</a>
leads to</p>
<div class="math">
\[u^1 = u^0 + \Delta t\,V_0 - \frac{1}{2}\Delta t^2\omega^2 u^0\thinspace .\]</div>
<p>Filename: <code class="docutils literal"><span class="pre">ic_with_V_0.pdf</span></code>.</p>
<span class="target" id="th-solvpdes"></span></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Solving ordinary differential equations</a><ul>
<li><a class="reference internal" href="#population-growth">Population growth</a><ul>
<li><a class="reference internal" href="#derivation-of-the-model">Derivation of the model</a></li>
<li><a class="reference internal" href="#numerical-solution-1">Numerical solution  (1)</a></li>
<li><a class="reference internal" href="#programming-the-forward-euler-scheme-the-special-case">Programming the Forward Euler scheme; the special case</a></li>
<li><a class="reference internal" href="#understanding-the-forward-euler-method">Understanding the Forward Euler method</a></li>
<li><a class="reference internal" href="#programming-the-forward-euler-scheme-the-general-case">Programming the Forward Euler scheme; the general case</a></li>
<li><a class="reference internal" href="#making-the-population-growth-model-more-realistic">Making the population growth model more realistic</a></li>
<li><a class="reference internal" href="#verification-exact-linear-solution-of-the-discrete-equations">Verification: exact linear solution of the discrete equations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#spreading-of-diseases">Spreading of diseases</a><ul>
<li><a class="reference internal" href="#spreading-of-a-flu">Spreading of a flu</a></li>
<li><a class="reference internal" href="#a-forward-euler-method-for-the-differential-equation-system">A Forward Euler method for the differential equation system</a></li>
<li><a class="reference internal" href="#programming-the-numerical-method-the-special-case-1">Programming the numerical method; the special case  (1)</a></li>
<li><a class="reference internal" href="#outbreak-or-not">Outbreak or not</a></li>
<li><a class="reference internal" href="#abstract-problem-and-notation">Abstract problem and notation</a></li>
<li><a class="reference internal" href="#programming-the-numerical-method-the-general-case">Programming the numerical method; the general case</a></li>
<li><a class="reference internal" href="#time-restricted-immunity">Time-restricted immunity</a></li>
<li><a class="reference internal" href="#incorporating-vaccination">Incorporating vaccination</a></li>
<li><a class="reference internal" href="#discontinuous-coefficients-a-vaccination-campaign">Discontinuous coefficients: a vaccination campaign</a></li>
</ul>
</li>
<li><a class="reference internal" href="#oscillating-one-dimensional-systems">Oscillating one-dimensional systems</a><ul>
<li><a class="reference internal" href="#derivation-of-a-simple-model">Derivation of a simple model</a></li>
<li><a class="reference internal" href="#numerical-solution-2">Numerical solution  (2)</a></li>
<li><a class="reference internal" href="#programming-the-numerical-method-the-special-case-2">Programming the numerical method; the special case  (2)</a></li>
<li><a class="reference internal" href="#a-magic-fix-of-the-numerical-method">A magic fix of the numerical method</a></li>
<li><a class="reference internal" href="#the-2nd-order-runge-kutta-method-or-heun-s-method">The 2nd-order Runge-Kutta method (or Heun&#8217;s method)</a></li>
<li><a class="reference internal" href="#odespy-software-for-solving-odes">Odespy: software for solving ODEs</a></li>
<li><a class="reference internal" href="#the-4th-order-runge-kutta-method">The 4th-order Runge-Kutta method</a><ul>
<li><a class="reference internal" href="#the-algorithm">The algorithm</a></li>
<li><a class="reference internal" href="#application">Application</a></li>
<li><a class="reference internal" href="#implementation-5">Implementation  (5)</a></li>
<li><a class="reference internal" href="#derivation">Derivation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#more-effects-damping-nonlinearity-and-external-forces">More effects: damping, nonlinearity, and external forces</a><ul>
<li><a class="reference internal" href="#the-euler-cromer-scheme">The Euler-Cromer scheme</a></li>
<li><a class="reference internal" href="#the-4-th-order-runge-kutta-method">The 4-th order Runge-Kutta method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#illustration-of-linear-damping">Illustration of linear damping</a></li>
<li><a class="reference internal" href="#illustration-of-linear-damping-with-sinusoidal-excitation">Illustration of linear damping with sinusoidal excitation</a></li>
<li><a class="reference internal" href="#spring-mass-system-with-sliding-friction">Spring-mass system with sliding friction</a></li>
<li><a class="reference internal" href="#a-finite-difference-method-undamped-linear-case">A finite difference method; undamped, linear case</a></li>
<li><a class="reference internal" href="#a-finite-difference-method-linear-damping">A finite difference method; linear damping</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercises-4">Exercises  (4)</a><ul>
<li><a class="reference internal" href="#exercise-43-geometric-construction-of-the-forward-euler-method">Exercise 43: Geometric construction of the Forward Euler method</a></li>
<li><a class="reference internal" href="#exercise-44-make-test-functions-for-the-forward-euler-method">Exercise 44: Make test functions for the Forward Euler method</a></li>
<li><a class="reference internal" href="#exercise-45-implement-and-evaluate-heun-s-method">Exercise 45: Implement and evaluate Heun&#8217;s method</a></li>
<li><a class="reference internal" href="#exercise-46-find-an-appropriate-time-step-logistic-model">Exercise 46: Find an appropriate time step; logistic model</a></li>
<li><a class="reference internal" href="#exercise-47-find-an-appropriate-time-step-sir-model">Exercise 47: Find an appropriate time step; SIR model</a></li>
<li><a class="reference internal" href="#exercise-48-model-an-adaptive-vaccination-campaign">Exercise 48: Model an adaptive vaccination campaign</a></li>
<li><a class="reference internal" href="#exercise-49-make-a-sirv-model-with-time-limited-effect-of-vaccination">Exercise 49: Make a SIRV model with time-limited effect of vaccination</a></li>
<li><a class="reference internal" href="#exercise-50-refactor-a-flat-program">Exercise 50: Refactor a flat program</a></li>
<li><a class="reference internal" href="#exercise-51-simulate-oscillations-by-a-general-ode-solver">Exercise 51: Simulate oscillations by a general ODE solver</a></li>
<li><a class="reference internal" href="#exercise-52-compute-the-energy-in-oscillations">Exercise 52: Compute the energy in oscillations</a></li>
<li><a class="reference internal" href="#exercise-53-use-a-backward-euler-scheme-for-population-growth">Exercise 53: Use a Backward Euler scheme for population growth</a></li>
<li><a class="reference internal" href="#exercise-54-use-a-crank-nicolson-scheme-for-population-growth">Exercise 54: Use a Crank-Nicolson scheme for population growth</a></li>
<li><a class="reference internal" href="#exercise-55-understand-finite-differences-via-taylor-series">Exercise 55: Understand finite differences via Taylor series</a></li>
<li><a class="reference internal" href="#exercise-56-use-a-backward-euler-scheme-for-oscillations">Exercise 56: Use a Backward Euler scheme for oscillations</a><ul>
<li><a class="reference internal" href="#remarks-6">Remarks  (6)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercise-57-use-heun-s-method-for-the-sir-model">Exercise 57: Use Heun&#8217;s method for the SIR model</a></li>
<li><a class="reference internal" href="#exercise-58-use-odespy-to-solve-a-simple-ode">Exercise 58: Use Odespy to solve a simple ODE</a></li>
<li><a class="reference internal" href="#exercise-59-set-up-a-backward-euler-scheme-for-oscillations">Exercise 59: Set up a Backward Euler scheme for oscillations</a></li>
<li><a class="reference internal" href="#exercise-60-set-up-a-forward-euler-scheme-for-nonlinear-and-damped-oscillations">Exercise 60: Set up a Forward Euler scheme for nonlinear and damped oscillations</a></li>
<li><a class="reference internal" href="#exercise-61-discretize-an-initial-condition">Exercise 61: Discretize an initial condition</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="._pylight004.html"
                        title="previous chapter">Computing integrals</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="._pylight006.html"
                        title="next chapter">Solving partial differential equations</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/._pylight005.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" size="18" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2015, S. Linge and H. P. Langtangen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.3.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.4</a>
      
      |
      <a href="_sources/._pylight005.txt"
          rel="nofollow">Page source</a></li>
    </div>

    

    
  </body>
</html>