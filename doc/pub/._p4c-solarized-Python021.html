<!--
Automatically generated HTML file from DocOnce source
(https://github.com/hplgit/doconce/)
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/hplgit/doconce/" />
<meta name="description" content="Programming for Computations - A Gentle Introduction to Numerical Simulations with Python">
<meta name="keywords" content="DocOnce,computer program,programming,language programming,language computer,MATLAB,Octave,Fortran,C,C++,Python,Maple,Mathematica,syntax,bug,debugging,script (and scripting),algorithm,execute (a program),implement (a program),bug,debugging,simulation,model mathematical,print,program run,program execute,code,comment,instruction,program statement,variable,assignment,calculator,text editor,Emacs,Vim,Gedit,Notepad++,TextWrangler,Spyder,Python  installation,IPython,prompt,program typing,program run,program execute,function,function call,atan,function input parameter,function output parameter,function return,function take a parameter,library,library function,from,module,package,NameError,WARNING,import  math,math,plot,numpy,import numpy,matplotlib.pyplot,import matplotlib.pyplot,linspace,xlabel,ylabel,plot,array,interactive use (of Python),keyboard arrow up/down,prompt,Python shell,IPython,import,operator Arithmetic,parentheses,rounding error,variable type,variable name,object,float,int,str,type conversion,reserved words,variable int,variable float,variable str,variable assignment,type conversion automatic,integer division,rounding error,printing formatted,printf formatting,default,array,array element,zeros,allocate,array index,indexing zero based,indexing one based,Python zero-based indexing,array slice of,copy,graph,hold (on/off),plot figure,title (plot),legend (plot),axis (plot),hardcopy (plot),format png,matrix mat,transpose (of matrix),matrix vector product,linear algebra,matrix,vector,error message,debugging,debugger,try-exception,exception handling,program crash,program testing,testing,program verification,verification,validation,list,tuple,raw input,program input,program output,input,symbolic computations,symbolic operations,symbolic simplifications,SymPy,library SymPy,WolframAlpha,Mathematica,Sage (symbolic package),variable delete,Python documentation,garbage collection,long lines (splitting of),fast code,commenting code,if,elif,else,colon,indent,boolean,boolean expression,True,False,boolean True,boolean False,pseudo code,random walk,random (function),import random (function),operator Logical,def,function,function definition,return,argument,parameter input,parameter output,main program,return value,variable local,variable global,argument keyword,argument named,argument ordinary,argument positional,doc string,function handle,function local,function global,function nested,lambda function,range,loop for,for loop,loop iteration,loop index,loop double,loop multiple,loop nested,linear algebra,while loop,loop while,loop infinite,loop iteration,loop index,stop program (Ctrl+c),list,list append,list convert to array,list delete,list create,tuple,list comprehension,read (from file),write (to file),loadtxt,savetxt,array sorting,Leibniz pi,Euler pi,programming game,linear interpolation,least squares method,Fourier series,integral analytically,integral exact,integral numerically,integral approximately,Trapezoidal rule,composite trapezoidal rule,integration points,implementation specific,implementation general,import module,module,test block,code re-use,flat program,program flat,error function (erf),Midpoint method,composite midpoint method,Simpson's rule,Gauss quadrature,bug,unit tests,testing procedures,convergence rate,rate of convergence,error asymptotic,finite precision (of float),floating point number (float),error rounding,error tolerance,difference absolute,difference relative,assert (function),function assert,nose (testing),py.test,test function,vectorization,computational speed (measuring),domain,double integral midpoint,double sum,code re-use,triple integral midpoint,domain,domain complex,domain,Monte Carlo integration,seed (random generators),dynamical system,scheme,differential equation first-order,model mathematical,model differential equation,model computational,exp math notation,finite difference method,mesh,mesh uniform,mesh points,forward difference approximation,difference forward,Forward Euler scheme,Euler's method,numerical scheme,demo function,logistic model carrying capacity,SIR model,compartment model,mathematical modeling,scalar ODE,ODE scalar,vector ODE,ODE vector,system of ODEs,asarray (function),function asarray,discontinuous coefficient,spring oscillations,spring damping of,differential equation second-order,simple pendulum,second-order ODE rewritten as two first-order ODEs,difference forward,difference backward,Heun's method,Runge-Kutta, 2nd-order method,2nd-order Runge-Kutta method,RK2,difference centered,nonlinear algebraic equation,Runge-Kutta-Fehlberg,Crank-Nicolson method,spring damping of,spring nonlinear,spring linear,scaling,resonance,Verlet integration,Crank-Nicolson method,Taylor series,PDE,heat equation,diffusion equation,source term,domain,initial conditions,boundary conditions,MOL forward Euler,method of lines,MOL,mesh points,cell,method of lines,class,closure,unstable solutions,instability,stability criterion,scaling,vectorization,tridiagonal matrix,matrix tridiagonal,theta rule,Poisson equation,Laplace equation,root finding,brute force method,code robust,divergence,code exception,code try-except,Newton starting value,sys.exit,exit (sys),return None,rate of convergence,Idle,Emacs,Vim,Gedit,TextWrangler,Notepad++">

<title>Programming for Computations - A Gentle Introduction to Numerical Simulations with Python</title>


<link href="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<link href="http://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/hplgit/doconce/master/bundled/html_images/small_yellow_question.png); }

div { text-align: justify; text-justify: inter-word; }
</style>

<style type="text/css">
/* Let inline verbatim have the same color as the surroundings */
code { color: inherit; background-color: transparent; }
/* Let pre tags for code blocks have the same color as the surroundings */
pre { color: inherit; background-color: transparent; }
</style>


</head>

<!-- tocinfo
{'highest level': 0,
 'sections': [(u'Preface', 0, None, '___sec0'),
              (u'Why learn programming?', 3, None, '___sec1'),
              (u'Target audience and background knowledge',
               3,
               None,
               '___sec2'),
              (u'Numerical methods', 3, None, '___sec3'),
              (u'The computer language: Python', 3, None, '___sec4'),
              (u'How this book is different', 3, None, '___sec5'),
              (u'Supplementary materials', 3, None, '___sec6'),
              (u'Acknowledgments', 3, None, '___sec7'),
              (u'The first few steps',
               0,
               u'1st:TheFirstFewSteps',
               u'1st:TheFirstFewSteps'),
              (u'What is a program? And what is programming?',
               1,
               None,
               '___sec9'),
              (u'A Python program with variables', 1, u'1st:ex1', u'1st:ex1'),
              (u'The program', 2, None, '___sec11'),
              (u'Dissection of the program', 2, None, '___sec12'),
              (u'Why not just use a pocket calculator?', 2, None, '___sec13'),
              (u'Why you must use a text editor to write programs',
               2,
               None,
               '___sec14'),
              (u'Installation of Python', 2, None, '___sec15'),
              (u'Write and run your first program', 2, None, '___sec16'),
              (u'A Python program with a library function',
               1,
               u'1st:ex2',
               u'1st:ex2'),
              (u'A Python program with vectorization and plotting',
               1,
               u'1st:ex3',
               u'1st:ex3'),
              (u'More basic concepts', 1, None, '___sec19'),
              (u'Using Python interactively', 2, None, '___sec20'),
              (u'Arithmetics, parentheses and rounding errors',
               2,
               None,
               '___sec21'),
              (u'Variables and objects', 2, None, '___sec22'),
              (u'Integer division', 2, None, '___sec23'),
              (u'Formatting text and numbers', 2, None, '___sec24'),
              (u'Arrays', 2, None, '___sec25'),
              (u'Plotting', 2, None, '___sec26'),
              (u'Error messages and warnings', 2, None, '___sec27'),
              (u'Input data', 2, None, '___sec28'),
              (u'Symbolic computations', 2, None, '___sec29'),
              (u'Concluding remarks', 2, None, '___sec30'),
              (u'Exercises', 1, None, '___sec31'),
              (u'Exercise 1: Error messages',
               2,
               u'1st:exer:ErrorMessages',
               u'1st:exer:ErrorMessages'),
              (u'Exercise 2: Volume of a cube',
               2,
               u'1st:exer:cubeVolume',
               u'1st:exer:cubeVolume'),
              (u'Exercise 3: Area and circumference of a circle',
               2,
               u'1st:exer:areaCircle',
               u'1st:exer:areaCircle'),
              (u'Exercise 4: Volumes of three cubes',
               2,
               u'1st:exer:volumes3cubes',
               u'1st:exer:volumes3cubes'),
              (u'Exercise 5: Average of integers',
               2,
               u'1st:exer:averageOf5Integers',
               u'1st:exer:averageOf5Integers'),
              (u'Exercise 6: Interactive computing of volume and area',
               2,
               u'1st:exer:cubeVolInteractively',
               u'1st:exer:cubeVolInteractively'),
              (u'Exercise 7: Peculiar results from division',
               2,
               u'1st:exer:intDivInteractively',
               u'1st:exer:intDivInteractively'),
              (u'Exercise 8: Update variable at command prompt',
               2,
               u'1st:exer:updateVarInteractively',
               u'1st:exer:updateVarInteractively'),
              (u'Exercise 9: Formatted print to screen',
               2,
               u'1st:exer:printfScreen',
               u'1st:exer:printfScreen'),
              (u'Exercise 10: Python documentation and random numbers',
               2,
               u'1st:exer:PythonDocRandom',
               u'1st:exer:PythonDocRandom'),
              (u'Basic constructions',
               0,
               u'2nd:BasicConstructins',
               u'2nd:BasicConstructins'),
              (u'If tests, colon and indentation', 1, None, '___sec43'),
              (u'Functions', 1, u'sec:functions', u'sec:functions'),
              (u'For loops', 1, u'sec:for:loops', u'sec:for:loops'),
              (u'While loops', 1, u'sec:while:loops', u'sec:while:loops'),
              (u'Lists and tuples - alternatives to arrays',
               1,
               u'sec:lists',
               u'sec:lists'),
              (u'Reading from and writing to files',
               1,
               u'sec:file:reading:writing',
               u'sec:file:reading:writing'),
              (u'Exercises', 1, None, '___sec49'),
              (u'Exercise 11: Errors with colon, indent, etc.',
               2,
               u'2nd:exer:ErrorsColonIndent',
               u'2nd:exer:ErrorsColonIndent'),
              (u'Exercise 12: Compare integers a and b',
               2,
               u'2nd:exer:compInt',
               u'2nd:exer:compInt'),
              (u'Exercise 13: Functions for circumference and area of a circle',
               2,
               u'2nd:exer:funcCircArea',
               u'2nd:exer:funcCircArea'),
              (u'Exercise 14: Function for area of a rectangle',
               2,
               u'2nd:exer:funcAreaRectangle',
               u'2nd:exer:funcAreaRectangle'),
              (u'Exercise 15: Area of a polygon',
               2,
               u'2nd:exer:area:polygon',
               u'2nd:exer:area:polygon'),
              (u'Exercise 16: Average of integers',
               2,
               u'2nd:exer:avNInt',
               u'2nd:exer:avNInt'),
              (u'Exercise 17: While loop with errors',
               2,
               u'2nd:exer:whileLoopErrors',
               u'2nd:exer:whileLoopErrors'),
              (u'Exercise 18: Area of rectangle versus circle',
               2,
               u'2nd:exer:areaRectCircle',
               u'2nd:exer:areaRectCircle'),
              (u'Exercise 19: Find crossing points of two graphs',
               2,
               u'2nd:exer:Cross2Graphs',
               u'2nd:exer:Cross2Graphs'),
              (u'Exercise 20: Sort array with numbers',
               2,
               u'2nd:exer:sortNumbers',
               u'2nd:exer:sortNumbers'),
              (u'Exercise 21: Compute $\\pi$',
               2,
               u'2nd:exer:computingPi',
               u'2nd:exer:computingPi'),
              (u'Exercise 22: Compute combinations of sets',
               2,
               u'2nd:exer:combinatorics1',
               u'2nd:exer:combinatorics1'),
              (u'Exercise 23: Frequency of random numbers',
               2,
               u'2nd:exer:numberOccurrence',
               u'2nd:exer:numberOccurrence'),
              (u'Remarks', 3, None, '___sec63'),
              (u'Exercise 24: Game 21',
               2,
               u'2nd:exer:Game21',
               u'2nd:exer:Game21'),
              (u'Exercise 25: Linear interpolation',
               2,
               u'2nd:exer:linearInterpol',
               u'2nd:exer:linearInterpol'),
              (u'Exercise 26: Test straight line requirement',
               2,
               u'2nd:exer:testStraightLine',
               u'2nd:exer:testStraightLine'),
              (u'Exercise 27: Fit straight line to data',
               2,
               u'2nd:exer:fitLine',
               u'2nd:exer:fitLine'),
              (u'Remarks', 3, None, '___sec68'),
              (u'Exercise 28: Fit sines to straight line',
               2,
               u'2nd:exer:fitSines',
               u'2nd:exer:fitSines'),
              (u'Remarks', 3, None, '___sec70'),
              (u'Exercise 29: Count occurrences of a string in a string',
               2,
               u'2nd:exer:countTextString',
               u'2nd:exer:countTextString'),
              (u'Remarks', 3, None, '___sec72'),
              (u'Computing integrals', 0, u'sec:integrals', u'sec:integrals'),
              (u'Basic ideas of numerical integration',
               1,
               u'sec:integrals:basic',
               u'sec:integrals:basic'),
              (u'Computational example', 3, None, '___sec75'),
              (u'The composite trapezoidal rule',
               1,
               u'sec:integrals:trap',
               u'sec:integrals:trap'),
              (u'The general formula',
               2,
               u'sec:integrals:formula',
               u'sec:integrals:formula'),
              (u'Implementation',
               2,
               u'sec:integrals:trap:impl',
               u'sec:integrals:trap:impl'),
              (u'Specific or general implementation?', 3, None, '___sec79'),
              (u'Implementation with functions', 3, None, '___sec80'),
              (u'Solving our specific problem in a session',
               3,
               None,
               '___sec81'),
              (u'Solving our specific problem in a program',
               3,
               None,
               '___sec82'),
              (u'Making a module', 2, None, '___sec83'),
              (u'Alternative flat special-purpose implementation',
               2,
               None,
               '___sec84'),
              (u'The composite midpoint method',
               1,
               u'sec:integrals:Midpoint',
               u'sec:integrals:Midpoint'),
              (u'The idea', 3, None, '___sec86'),
              (u'The general formula', 2, None, '___sec87'),
              (u'Implementation',
               2,
               u'sec:midpoint:code',
               u'sec:midpoint:code'),
              (u'Comparing the trapezoidal and the midpoint methods',
               2,
               None,
               '___sec89'),
              (u'Testing', 1, None, '___sec90'),
              (u'Problems with brief testing procedures',
               2,
               None,
               '___sec91'),
              (u'Proper test procedures',
               2,
               u'sec:integrals:testprocs',
               u'sec:integrals:testprocs'),
              (u'Hand-computed results', 3, None, '___sec93'),
              (u'Solving a problem without numerical errors',
               3,
               None,
               '___sec94'),
              (u'Demonstrating correct convergence rates',
               3,
               None,
               '___sec95'),
              (u'Finite precision of floating-point numbers',
               2,
               u'sec:integrals:finite_prec',
               u'sec:integrals:finite_prec'),
              (u'Constructing unit tests and writing test functions',
               2,
               u'sec:integrals:test:functions',
               u'sec:integrals:test:functions'),
              (u'Hand-computed numerical results', 3, None, '___sec98'),
              (u'Solving a problem without numerical errors',
               3,
               None,
               '___sec99'),
              (u'Demonstrating correct convergence rates',
               3,
               None,
               '___sec100'),
              (u'Vectorization', 1, None, '___sec101'),
              (u'Vectorizing the midpoint rule', 3, None, '___sec102'),
              (u'Vectorizing the trapezoidal rule', 3, None, '___sec103'),
              (u'Measuring computational speed', 1, None, '___sec104'),
              (u'Double and triple integrals',
               1,
               u'sec:int:double',
               u'sec:int:double'),
              (u'The midpoint rule for a double integral',
               2,
               u'sec:int:double:midpoint',
               u'sec:int:double:midpoint'),
              (u'Derivation via one-dimensional integrals',
               3,
               None,
               '___sec107'),
              (u'Direct derivation', 3, None, '___sec108'),
              (u'Programming a double sum', 3, None, '___sec109'),
              (u'Reusing code for one-dimensional integrals',
               3,
               None,
               '___sec110'),
              (u'Verification via test functions', 3, None, '___sec111'),
              (u'The midpoint rule for a triple integral',
               2,
               None,
               '___sec112'),
              (u'Theory', 3, None, '___sec113'),
              (u'Implementation', 3, None, '___sec114'),
              (u'Monte Carlo integration for complex-shaped domains',
               2,
               u'sec:int:complex:domain',
               u'sec:int:complex:domain'),
              (u'The Monte Carlo integration algorithm',
               3,
               None,
               '___sec116'),
              (u'Implementation', 3, None, '___sec117'),
              (u'Verification', 3, None, '___sec118'),
              (u'Test function for function with random numbers',
               3,
               None,
               '___sec119'),
              (u'Integral over a circle', 3, None, '___sec120'),
              (u'Exercises', 1, None, '___sec121'),
              (u'Exercise 30: Hand calculations for the trapezoidal method',
               2,
               u'sec:exer:trap:hand',
               u'sec:exer:trap:hand'),
              (u'Exercise 31: Hand calculations for the midpoint method',
               2,
               u'sec:exer:midpt:hand',
               u'sec:exer:midpt:hand'),
              (u'Exercise 32: Compute a simple integral',
               2,
               u'sec:exer:trap:mid:parabola',
               u'sec:exer:trap:mid:parabola'),
              (u'Exercise 33: Hand-calculations with sine integrals',
               2,
               u'sec:exer:hand:sine',
               u'sec:exer:hand:sine'),
              (u'Exercise 34: Make test functions for the midpoint method',
               2,
               u'sec:exer:test:midpoint',
               u'sec:exer:test:midpoint'),
              (u'Exercise 35: Explore rounding errors with large numbers',
               2,
               u'sec:exer:test:roundoff',
               u'sec:exer:test:roundoff'),
              (u'Exercise 36: Write test functions for $\\int_0^4\\sqrt{x}dx$',
               2,
               u'sec:exer:test:convrates:sqrt',
               u'sec:exer:test:convrates:sqrt'),
              (u'Remarks', 3, None, '___sec129'),
              (u'Exercise 37: Rectangle methods',
               2,
               u'sec:exer:rectangleMethod',
               u'sec:exer:rectangleMethod'),
              (u'Exercise 38: Adaptive integration',
               2,
               u'sec:exer:adaptive:int',
               u'sec:exer:adaptive:int'),
              (u'Remarks', 3, None, '___sec132'),
              (u'Exercise 39: Integrating x raised to x',
               2,
               u'sec:exer:integrate:x2x',
               u'sec:exer:integrate:x2x'),
              (u'Exercise 40: Integrate products of sine functions',
               2,
               u'sec:exer:sine:products',
               u'sec:exer:sine:products'),
              (u'Exercise 41: Revisit fit of sines to a function',
               2,
               u'sec:exer:revisitFitSines',
               u'sec:exer:revisitFitSines'),
              (u'Exercise 42: Derive the trapezoidal rule for a double integral',
               2,
               u'sec:exer:trapezoidal:2D',
               u'sec:exer:trapezoidal:2D'),
              (u'Exercise 43: Compute the area of a triangle by Monte Carlo integration',
               2,
               u'sec:exer:MC:ellipse',
               u'sec:exer:MC:ellipse'),
              (u'Solving ordinary differential equations',
               0,
               u'5th:SolvODEs',
               u'5th:SolvODEs'),
              (u'Population growth', 1, u'sec:de:pg', u'sec:de:pg'),
              (u'Derivation of the model',
               2,
               u'sec:de:pg:model',
               u'sec:de:pg:model'),
              (u'Numerical solution',
               2,
               u'sec:de:pg:numerics',
               u'sec:de:pg:numerics'),
              (u'Programming the Forward Euler scheme; the special case',
               2,
               u'sec:de:pg:prog1',
               u'sec:de:pg:prog1'),
              (u'Understanding the Forward Euler method',
               2,
               u'sec:de:pg:geom',
               u'sec:de:pg:geom'),
              (u'Programming the Forward Euler scheme; the general case',
               2,
               u'sec:de:FE:gen',
               u'sec:de:FE:gen'),
              (u'Making the population growth model more realistic',
               2,
               None,
               '___sec145'),
              (u'Verification: exact linear solution of the discrete equations',
               2,
               u'sec:de:growth:test:linear',
               u'sec:de:growth:test:linear'),
              (u'Spreading of diseases', 1, None, '___sec147'),
              (u'Spreading of a flu', 2, u'sec:de:flu', u'sec:de:flu'),
              (u'A Forward Euler method for the differential equation system',
               2,
               u'sec:de:flu:FE',
               u'sec:de:flu:FE'),
              (u'Programming the numerical method; the special case',
               2,
               u'sec:de:flu:prog:spec',
               u'sec:de:flu:prog:spec'),
              (u'Outbreak or not', 2, None, '___sec151'),
              (u'Abstract problem and notation',
               2,
               u'sec:de:flu:generic',
               u'sec:de:flu:generic'),
              (u'Programming the numerical method; the general case',
               2,
               u'sec:de:flu:prog:generic',
               u'sec:de:flu:prog:generic'),
              (u'Time-restricted immunity', 2, None, '___sec154'),
              (u'Incorporating vaccination',
               2,
               u'sec:de:flu:vaccine',
               u'sec:de:flu:vaccine'),
              (u'Discontinuous coefficients: a vaccination campaign',
               2,
               u'sec:de:flu:vaccine:discont',
               u'sec:de:flu:vaccine:discont'),
              (u'Oscillating one-dimensional systems',
               1,
               u'sec:de:vib',
               u'sec:de:vib'),
              (u'Derivation of a simple model', 2, None, '___sec158'),
              (u'Numerical solution', 2, None, '___sec159'),
              (u'Programming the numerical method; the special case',
               2,
               u'sec:de:vib:special',
               u'sec:de:vib:special'),
              (u'A magic fix of the numerical method', 2, None, '___sec161'),
              (u"The 2nd-order Runge-Kutta method (or Heun's method)",
               2,
               u'sec:de:osc:Heun',
               u'sec:de:osc:Heun'),
              (u'Software for solving ODEs',
               2,
               u'sec:de:osc:odespy',
               u'sec:de:osc:odespy'),
              (u'The 4th-order Runge-Kutta method', 2, None, '___sec164'),
              (u'The algorithm', 3, None, '___sec165'),
              (u'Application', 3, None, '___sec166'),
              (u'Implementation', 3, None, '___sec167'),
              (u'Derivation', 3, None, '___sec168'),
              (u'More effects: damping, nonlinearity, and external forces',
               2,
               None,
               '___sec169'),
              (u'The Euler-Cromer scheme', 3, None, '___sec170'),
              (u'The 4-th order Runge-Kutta method', 3, None, '___sec171'),
              (u'Illustration of linear damping', 2, None, '___sec172'),
              (u'Illustration of linear damping with sinusoidal excitation',
               2,
               None,
               '___sec173'),
              (u'Spring-mass system with sliding friction',
               2,
               u'sec:de:vib:ode2:sliding:friction',
               u'sec:de:vib:ode2:sliding:friction'),
              (u'A finite difference method; undamped, linear case',
               2,
               u'sec:de:vib:2nd',
               u'sec:de:vib:2nd'),
              (u'A finite difference method; linear damping',
               2,
               u'sec:de:vib:2nd:damped1',
               u'sec:de:vib:2nd:damped1'),
              (u'Exercises', 1, None, '___sec177'),
              (u'Exercise 44: Geometric construction of the Forward Euler method',
               2,
               u'sec:de:exer:geom',
               u'sec:de:exer:geom'),
              (u'Exercise 45: Make test functions for the Forward Euler method',
               2,
               u'sec:de:exer:FE:test1',
               u'sec:de:exer:FE:test1'),
              (u"Exercise 46: Implement and evaluate Heun's method",
               2,
               u'sec:de:exer:Heun:pg',
               u'sec:de:exer:Heun:pg'),
              (u'Exercise 47: Find an appropriate time step; logistic model',
               2,
               u'sec:de:exer:logistic:dtopt',
               u'sec:de:exer:logistic:dtopt'),
              (u'Exercise 48: Find an appropriate time step; SIR model',
               2,
               u'sec:de:exer:SIR:dtopt',
               u'sec:de:exer:SIR:dtopt'),
              (u'Exercise 49: Model an adaptive vaccination campaign',
               2,
               u'sec:de:exer:SIRV:padapt',
               u'sec:de:exer:SIRV:padapt'),
              (u'Exercise 50: Make a SIRV model with time-limited effect of vaccination',
               2,
               u'sec:de:exer:SIRV:padapt_time_limited',
               u'sec:de:exer:SIRV:padapt_time_limited'),
              (u'Exercise 51: Refactor a flat program',
               2,
               u'sec:de:exer:vib:FE:func',
               u'sec:de:exer:vib:FE:func'),
              (u'Exercise 52: Simulate oscillations by a general ODE solver',
               2,
               u'sec:de:exer:vib:ode_FE',
               u'sec:de:exer:vib:ode_FE'),
              (u'Exercise 53: Compute the energy in oscillations',
               2,
               u'sec:de:exer:vib:energy',
               u'sec:de:exer:vib:energy'),
              (u'Exercise 54: Use a Backward Euler scheme for population growth',
               2,
               u'sec:de:exer:pg:BE',
               u'sec:de:exer:pg:BE'),
              (u'Exercise 55: Use a Crank-Nicolson scheme for population growth',
               2,
               u'sec:de:exer:pg:CN',
               u'sec:de:exer:pg:CN'),
              (u'Exercise 56: Understand finite differences via Taylor series',
               2,
               u'sec:de:exer:fd:Taylor',
               u'sec:de:exer:fd:Taylor'),
              (u'Exercise 57: Use a Backward Euler scheme for oscillations',
               2,
               u'sec:de:exer:vib:BE',
               u'sec:de:exer:vib:BE'),
              (u'Remarks', 3, None, '___sec192'),
              (u"Exercise 58: Use Heun's method for the SIR model",
               2,
               u'sec:de:exer:SIR:Heun',
               u'sec:de:exer:SIR:Heun'),
              (u'Exercise 59: Use Odespy to solve a simple ODE',
               2,
               u'sec:de:exer:odespy:decay',
               u'sec:de:exer:odespy:decay'),
              (u'Exercise 60: Set up a Backward Euler scheme for oscillations',
               2,
               u'sec:de:exer:osc:BE',
               u'sec:de:exer:osc:BE'),
              (u'Exercise 61: Set up a Forward Euler scheme for nonlinear and damped oscillations',
               2,
               u'sec:de:exer:osc:FE:general',
               u'sec:de:exer:osc:FE:general'),
              (u'Exercise 62: Discretize an initial condition',
               2,
               u'sec:de:exer:osc:2nd:V0ic',
               u'sec:de:exer:osc:2nd:V0ic'),
              (u'Solving partial differential equations',
               0,
               u'6th:SolvPDEs',
               u'6th:SolvPDEs'),
              (u'Finite difference methods',
               1,
               u'6th:SolvPDEs:MOLandFE',
               u'6th:SolvPDEs:MOLandFE'),
              (u'Reduction of a PDE to a system of ODEs',
               2,
               u'sec:pde:diff1D:reduce',
               u'sec:pde:diff1D:reduce'),
              (u'Construction of a test problem with known discrete solution',
               2,
               u'sec:pde:diff1D:testproblem',
               u'sec:pde:diff1D:testproblem'),
              (u'Implementation: Forward Euler method', 2, None, '___sec202'),
              (u'Application: heat conduction in a rod',
               2,
               u'sec:pde:diff1D:rod',
               u'sec:pde:diff1D:rod'),
              (u'Vectorization', 2, None, '___sec204'),
              (u'Using Odespy to solve the system of ODEs',
               2,
               None,
               '___sec205'),
              (u'Implicit methods', 2, None, '___sec206'),
              (u'Exercises', 1, None, '___sec207'),
              (u'Exercise 63: Simulate a diffusion equation by hand',
               2,
               u'sec:pde:diff1D:exer:handFE',
               u'sec:pde:diff1D:exer:handFE'),
              (u'Exercise 64: Compute temperature variations in the ground',
               2,
               u'sec:pde:diff1D:exer:groundtemp',
               u'sec:pde:diff1D:exer:groundtemp'),
              (u'Exercise 65: Compare implicit methods',
               2,
               u'sec:pde:diff1D:exer:compare:implicit',
               u'sec:pde:diff1D:exer:compare:implicit'),
              (u'Exercise 66: Explore adaptive and implicit methods',
               2,
               u'sec:pde:diff1D:exer:groundtemp:adapt',
               u'sec:pde:diff1D:exer:groundtemp:adapt'),
              (u'Exercise 67: Investigate the $\\theta$ rule',
               2,
               u'sec:pde:diff1D:exer:CN',
               u'sec:pde:diff1D:exer:CN'),
              (u'Remarks', 3, None, '___sec213'),
              (u'Exercise 68: Compute the diffusion of a Gaussian peak',
               2,
               u'sec:pde:diff1D:exer:Gaussian',
               u'sec:pde:diff1D:exer:Gaussian'),
              (u'Remarks', 3, None, '___sec215'),
              (u'Exercise 69: Vectorize a function for computing the area of a polygon',
               2,
               u'2nd:exer:area:polygon2',
               u'2nd:exer:area:polygon2'),
              (u'Exercise 70: Explore symmetry',
               2,
               u'sec:pde:diff1D:exer:Gaussian:symm',
               u'sec:pde:diff1D:exer:Gaussian:symm'),
              (u'Remarks', 3, None, '___sec218'),
              (u'Exercise 71: Compute solutions as $t\\rightarrow\\infty$',
               2,
               u'sec:pde:diff1D:exer:stationary',
               u'sec:pde:diff1D:exer:stationary'),
              (u'Remarks', 3, None, '___sec220'),
              (u'Exercise 72: Solve a two-point boundary value problem',
               2,
               u'sec:pde:diff1D:exer:stationary2',
               u'sec:pde:diff1D:exer:stationary2'),
              (u'Solving nonlinear algebraic equations',
               0,
               u'4th:NonlinAlgEq',
               u'4th:NonlinAlgEq'),
              (u'Brute force methods',
               1,
               u'4th:bruteforce',
               u'4th:bruteforce'),
              (u'Brute force root finding', 2, None, '___sec224'),
              (u'Numerical algorithm', 3, None, '___sec225'),
              (u'Implementation', 3, None, '___sec226'),
              (u'Brute force optimization', 2, None, '___sec227'),
              (u'Numerical algorithm', 3, None, '___sec228'),
              (u'Implementation', 3, None, '___sec229'),
              (u'Model problem for algebraic equations',
               2,
               None,
               '___sec230'),
              (u"Newton's method",
               1,
               u'4th:NonlinAlgEq:Newt',
               u'4th:NonlinAlgEq:Newt'),
              (u"Deriving and implementing Newton's method",
               2,
               None,
               '___sec232'),
              (u'Making a more efficient and robust implementation',
               2,
               u'4th:Newton:robust',
               u'4th:Newton:robust'),
              (u'The secant method',
               1,
               u'4th:NonlinAlgEq:Secant',
               u'4th:NonlinAlgEq:Secant'),
              (u'The bisection method',
               1,
               u'4th:NonlinAlgEq:Bisect',
               u'4th:NonlinAlgEq:Bisect'),
              (u'Rate of convergence',
               1,
               u'4th:NonlinAlgEq:RateConv',
               u'4th:NonlinAlgEq:RateConv'),
              (u'Solving multiple nonlinear algebraic equations',
               1,
               u'nonlin:Newton:systems',
               u'nonlin:Newton:systems'),
              (u'Abstract notation',
               2,
               u'nonlin:Newton:systems:notation',
               u'nonlin:Newton:systems:notation'),
              (u'Taylor expansions for multi-variable functions',
               2,
               None,
               '___sec239'),
              (u"Newton's method", 2, None, '___sec240'),
              (u'Implementation', 2, None, '___sec241'),
              (u'Exercises', 1, None, '___sec242'),
              (u"Exercise 73: Understand why Newton's method can fail",
               2,
               u'4th:exer:Newton:failure',
               u'4th:exer:Newton:failure'),
              (u'Exercise 74: See if the secant method fails',
               2,
               u'4th:exer:Secant:failure',
               u'4th:exer:Secant:failure'),
              (u'Exercise 75: Understand why the bisection method cannot fail',
               2,
               u'4th:exer:Bisection:failure',
               u'4th:exer:Bisection:failure'),
              (u"Exercise 76: Combine the bisection method with Newton's method",
               2,
               u'4th:exer:Bisection:Newton',
               u'4th:exer:Bisection:Newton'),
              (u"Exercise 77: Write a test function for Newton's method",
               2,
               u'4th:exer:NewtonHand',
               u'4th:exer:NewtonHand'),
              (u'Exercise 78: Solve nonlinear equation for a vibrating beam',
               2,
               u'4th:exer:beam:vib',
               u'4th:exer:beam:vib'),
              (u'Appendix: Getting access to Python',
               0,
               u'app:accesspy',
               u'app:accesspy'),
              (u'Required software',
               1,
               u'sec:accesspy:softwarelist',
               u'sec:accesspy:softwarelist'),
              (u'Anaconda and Spyder',
               1,
               u'sec:accesspy:anaconda',
               u'sec:accesspy:anaconda'),
              (u'Spyder on Mac', 2, None, '___sec252'),
              (u'Installation of additional packages', 2, None, '___sec253'),
              (u'How to write and run a Python program',
               1,
               u'sec:accesspy:writerun',
               u'sec:accesspy:writerun'),
              (u'The need for a text editor', 2, None, '___sec255'),
              (u'Text editors', 2, None, '___sec256'),
              (u'Terminal windows', 2, None, '___sec257'),
              (u'Using a plain text editor and a terminal window',
               2,
               None,
               '___sec258'),
              (u'Spyder', 2, None, '___sec259'),
              (u'The SageMathCloud and Wakari web services',
               1,
               u'sec:accesspy:sagemath:wakari',
               u'sec:accesspy:sagemath:wakari'),
              (u'Basic intro to SageMathCloud', 2, None, '___sec261'),
              (u'Basic intro to Wakari', 2, None, '___sec262'),
              (u'Installing your own Python packages', 2, None, '___sec263'),
              (u'Writing IPython notebooks',
               1,
               u'sec:accesspy:ipynb',
               u'sec:accesspy:ipynb'),
              (u'A simple program in the notebook', 2, None, '___sec265'),
              (u'Mixing text, mathematics, code, and graphics',
               2,
               None,
               '___sec266'),
              (u'References', 0, None, '___sec267')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "none"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript"
 src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<!-- newcommands.tex -->
$$
\newcommand{\Oof}[1]{\mathcal{O}(#1)}
\newcommand{\F}{\boldsymbol{F}}
\newcommand{\J}{\boldsymbol{J}}
\newcommand{\x}{\boldsymbol{x}}
\renewcommand{\c}{\boldsymbol{c}}
$$




    
<a name="part0021"></a>
<p>
<!-- begin top navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._p4c-solarized-Python020.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._p4c-solarized-Python022.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end top navigation -->
</p>

<p>
<!-- !split -->

<h1 id="___sec147">Spreading of diseases </h1>

<p>
Our aim with this section is to show in detail how one can apply
mathematics and programming to investigate spreading of diseases. The
mathematical model is now a system of three differential equations
with three unknown functions. To derive such a model, we can use
mainly intuition, so no specific background knowledge of diseases is
required.

<h2 id="sec:de:flu">Spreading of a flu</h2>

<p>
Imagine a boarding school out in the country side.  This school is a
small and closed society. Suddenly, one or more of the pupils get a
flu. We expect that the flu may spread quite effectively or die
out. The question is how many of the pupils and the school's staff
will be affected. Some quite simple mathematics can help us to
achieve insight into the dynamics of how the disease spreads.

<p>
Let the mathematical function \( S(t) \) count how many individuals, at
time \( t \), that have the possibility to get infected. Here, \( t \) may
count hours or days, for instance.  These individuals make up a
category called susceptibles, labeled as S. Another category, I,
consists of the individuals that are infected. Let \( I(t) \) count how
many there are in category I at time \( t \). An individual having
recovered from the disease is assumed to gain immunity. There is also
a small possibility that an infected will die. In either case, the
individual is moved from the I category to a category we call the
removed category, labeled with R.  We let \( R(t) \) count the number of
individuals in the \( R \) category at time \( t \). Those who enter the \( R \)
category, cannot leave this category.

<p>
To summarize, the spreading of this disease is essentially the dynamics
of moving individuals from the S to the I and then to the R
category:

<p>
<br />
<br />

<p>
<center><p><img src="figs/categories_SIR.png" align="bottom" width=400></p></center>

<p>
<br />
<br />

<p>
We can use mathematics to more precisely describe the
exchange between the categories. The fundamental idea is to describe
the changes that take place during a small
time interval, denoted by \( \Delta t \).

<p>
Our disease model is often referred to as a <em>compartment model</em>, where
quantities are shuffled between compartments (here a synonym for
categories) according to some rules. The rules express <em>changes</em> in
a small time interval \( \Delta t \), and
from these changes we can let \( \Delta t \) go to zero and obtain
derivatives. The resulting equations then go from difference equations
(with finite \( \Delta t \)) to differential equations (\( \Delta t\rightarrow 0 \)).

<p>
We introduce a uniform mesh in time, \( t_n=n\Delta t \),
\( n=0,\ldots,N_t \), and seek \( S \) at the mesh points. The numerical
approximation to \( S \) at time \( t_n \) is denoted by \( S^n \). Similarly, we seek the unknown
values of \( I(t) \) and \( R(t) \) at the mesh points and
introduce a similar notation \( I^n \) and \( R^n \) for the approximations
to the exact values \( I(t_n) \) and \( R(t_n) \).

<p>
In the time interval \( \Delta t \) we know that some people will be
infected, so \( S \) will decrease. We shall soon argue by mathematics
that there will be \( \beta\Delta tSI \) new infected individuals in this
time interval, where \( \beta \) is a parameter reflecting how easy people
get infected during a time interval of unit length. If the loss in \( S \)
is \( \beta\Delta tSI \), we have that the change in \( S \) is

$$
\begin{equation}
S^{n+1} - S^n = -\beta\Delta tS^nI^n\thinspace .
\tag{37}
\end{equation}
$$

Dividing by \( \Delta t \) and letting \( \Delta t\rightarrow 0 \), makes
the left-hand side approach \( S'(t_n) \) such that we obtain a
differential equation

$$
\begin{equation}
S' = -\beta SI\thinspace .
\tag{38}
\end{equation}
$$

The reasoning in going from the difference equation <a href="#mjx-eqn-37">(37)</a>
to the differential equation <a href="#mjx-eqn-38">(38)</a> follows exactly
the steps explained in the section <a href="._p4c-solarized-Python020.html#sec:de:pg:model">Derivation of the model</a>.

<p>
Before proceeding with how \( I \) and \( R \) develops in time,
let us explain the formula \( \beta\Delta tSI \).  We
have \( S \) susceptibles and \( I \) infected people. These can make up \( SI \)
pairs. Now, suppose that during a time interval \( T \) we measure that
\( m \) actual pairwise meetings do occur among \( n \) theoretically possible
pairings of people from the S and I categories. The probability
that people meet in pairs during a time \( T \) is
(by the empirical frequency definition
of probability) equal to
\( m/n \), i.e., the number of successes divided by the number of possible
outcomes. From such statistics we normally derive quantities
expressed per unit time, i.e., here we want the
probability per unit time, \( \mu \),
which is found from dividing by \( T \): \( \mu = m/(nT) \).
<!-- The value of \( \mu \) -->
<!-- can be found by observing an experiment over some hours -->
<!-- where people meet and talk, where we count the number of such meetings (\( m \)). -->

<p>
Given the probability \( \mu \), the expected number of meetings per
time interval of \( SI \) possible pairs of people is (from basic statistics)
\( \mu SI \). During a time interval \( \Delta t \), there will be
\( \mu SI\Delta t \) expected number of meetings between susceptibles and infected
people such that
the virus may spread.  Only a fraction of the \( \mu\Delta t SI \) meetings are
effective in the sense that the susceptible actually becomes infected.
Counting that \( m \) people get infected in \( n \) such pairwise meetings
(say 5 are infected from 1000 meetings), we can estimate the
probability of being infected as \( p=m/n \). The expected number of
individuals in the S category that in a time interval \( \Delta t \)
catch the virus and get infected
is then \( p\mu\Delta t SI \). Introducing a new constant \( \beta =p\mu \)
to save some writing, we arrive at the formula \( \beta\Delta tSI \).

<p>
The value of \( \beta \) must be known in order to predict the future
with the disease model. One possibility is to
estimate \( p \) and \( \mu \) from their meanings in the derivation
above. Alternatively, we can observe an &quot;experiment&quot; where there
are \( S_0 \) susceptibles and \( I_0 \) infected at some point in time.
During a time interval \( T \) we count that \( N \) susceptibles have become
infected. Using <a href="#mjx-eqn-37">(37)</a> as a rough approximation of how
\( S \) has developed during time \( T \) (and now \( T \) is not necessarily small,
but we use <a href="#mjx-eqn-37">(37)</a> anyway), we get

$$
\begin{equation}
N = \beta T S_0I_0\quad\Rightarrow\quad\beta = {N\over TS_0I_0}\thinspace .
\tag{39}
\end{equation}
$$

<p>
We need an additional equation to describe the evolution of \( I(t) \).
Such an equation is easy to establish by noting that
the loss in the S category is a corresponding gain in the I category.
More precisely,

$$
\begin{equation}
I^{n+1} - I^n = \beta\Delta tS^nI^n\thinspace .
\tag{40}
\end{equation}
$$

However, there is also a loss in the I category because people recover
from the disease. Suppose that we can measure that \( m \) out of \( n \)
individuals recover in a time period \( T \) (say 10 of 40 sick
people recover during a day: \( m=10 \), \( n=40 \), \( T=24 \) h). Now,
\( \gamma =m/(nT) \) is the probability that one individual recovers in
a unit time interval. Then (on average) \( \gamma\Delta t I \) infected
will recover in a time interval \( \Delta t \). This quantity represents
a loss in the I category and a gain in the R category. We can therefore
write the total change in the I category as

$$
\begin{equation}
I^{n+1} - I^n = \beta\Delta tS^nI^n - \gamma\Delta t I^n\thinspace .
\tag{41}
\end{equation}
$$

<p>
The change in the R category is simple: there is always an increase
from the I category:

$$
\begin{equation}
R^{n+1} - R^n = \gamma\Delta t I^n\thinspace .
\tag{42}
\end{equation}
$$

Since there is no loss in the R category (people are either recovered
and immune, or dead), we are done with the modeling of this category.
In fact, we do not strictly need the equation <a href="#mjx-eqn-42">(42)</a> for \( R \),
but extensions of the model later will need an equation for \( R \).

<p>
Dividing by \( \Delta t \) in <a href="#mjx-eqn-41">(41)</a> and <a href="#mjx-eqn-42">(42)</a>
and letting \( \Delta t\rightarrow 0 \), results in the corresponding
differential equations

$$
\begin{equation}
I' = \beta\Delta tSI - \gamma\Delta t I,
\tag{43}
\end{equation}
$$

and

$$
\begin{equation}
R' = \gamma I\thinspace .
\tag{44}
\end{equation}
$$

<p>
To summarize, we have derived difference equations
<a href="#mjx-eqn-37">(37)</a>-<a href="#mjx-eqn-42">(42)</a>, and alternative
differential equations <a href="#mjx-eqn-43">(43)</a>-<a href="#mjx-eqn-44">(44)</a>.
For reference, we list the complete set of the three difference
equations:

$$
\begin{align}
S^{n+1} &= S^n -\beta\Delta tS^nI^n,
\tag{45}\\ 
I^{n+1} &= I^n + \beta\Delta tS^nI^n - \gamma\Delta t I^n,
\tag{46}\\ 
R^{n+1} &= R^n + \gamma\Delta t I^n\thinspace .
\tag{47}
\end{align}
$$

Note that we have isolated the new unknown quantities \( S^{n+1} \), \( I^{n+1} \),
and \( R^{n+1} \) on the left-hand side, such that these can readily be
computed if \( S^n \), \( I^n \), and \( R^n \) are known. To get such a procedure
started, we need to know \( S^0 \), \( I^0 \), \( R^0 \). Obviously, we also need
to have values for the parameters \( \beta \) and \( \gamma \).

<p>
We also list the system of three differential equations:

$$
\begin{align}
S' &= -\beta SI,
\tag{48}\\ 
I' &= \beta SI - \gamma I,
\tag{49}\\ 
R' &= \gamma I\thinspace .
\tag{50}
\end{align}
$$

This differential equation model (and also its discrete counterpart above)
is known as a <em>SIR model</em>. The input data to the differential equation
model consist of the parameters \( \beta \) and \( \gamma \) as well
as the initial conditions \( S(0)=S_0 \), \( I(0)=I_0 \), and \( R(0)=R_0 \).

<h2 id="sec:de:flu:FE">A Forward Euler method for the differential equation system</h2>

<p>
Let us apply the same principles as we did in the section <a href="._p4c-solarized-Python020.html#sec:de:pg:numerics">Numerical solution</a>
to discretize the differential equation system by the Forward Euler
method.
We already have a time mesh and time-discrete quantities \( S^n \), \( I^n \),
\( R^n \), \( n=0,\ldots,N_t \). The three differential equations are
assumed to be valid at the mesh points. At the point \( t_n \) we then
have

$$
\begin{align}
S'(t_n) &= -\beta S(t_n)I(t_n),
\tag{51}\\ 
I'(t_n) &= \beta S(t_n)I(t_n) - \gamma I(t_n),
\tag{52}\\ 
R'(t_n) &= \gamma I(t_n),
\tag{53}
\end{align}
$$

for \( n=0,1,\ldots,N_t \).
This is an approximation since the differential equations are originally
valid at all times \( t \) (usually in some finite interval \( [0,T] \)).
Using forward finite differences for the derivatives results in
an additional approximation,

$$
\begin{align}
\frac{S^{n+1}- S^n}{\Delta t} &= -\beta S^nI^n,
\tag{54}\\ 
\frac{I^{n+1}- I^n}{\Delta t} &= \beta S^nI^n - \gamma I^n,
\tag{55}\\ 
\frac{R^{n+1}- R^n}{\Delta t} &= \gamma I^n\thinspace .
\tag{56}
\end{align}
$$

As we see, these equations are identical to the difference equations that
naturally arise in the derivation of the model. However, other numerical
methods than the Forward Euler scheme
will result in slightly different difference equations.

<h2 id="sec:de:flu:prog:spec">Programming the numerical method; the special case</h2>

<p>
The computation of <a href="#mjx-eqn-54">(54)</a>-<a href="#mjx-eqn-56">(56)</a> can be
readily made in a computer program
<a href="https://github.com/hplgit/prog4comp/tree/master/src/py/SIR1.py" target="_self"><tt>SIR1.py</tt></a>:

<p>
<!-- begin verbatim block  pypro-->
<pre><code>from numpy import zeros, linspace
import matplotlib.pyplot as plt

# Time unit: 1 h
beta = 10./(40*8*24)
gamma = 3./(15*24)
dt = 0.1             # 6 min
D = 30               # Simulate for D days
N_t = int(D*24/dt)   # Corresponding no of hours

t = linspace(0, N_t*dt, N_t+1)
S = zeros(N_t+1)
I = zeros(N_t+1)
R = zeros(N_t+1)

# Initial condition
S[0] = 50
I[0] = 1
R[0] = 0

# Step equations forward in time
for n in range(N_t):
    S[n+1] = S[n] - dt*beta*S[n]*I[n]
    I[n+1] = I[n] + dt*beta*S[n]*I[n] - dt*gamma*I[n]
    R[n+1] = R[n] + dt*gamma*I[n]

fig = plt.figure()
l1, l2, l3 = plt.plot(t, S, t, I, t, R)
fig.legend((l1, l2, l3), ('S', 'I', 'R'), 'upper left')
plt.xlabel('hours')
plt.show()
plt.savefig('tmp.pdf'); plt.savefig('tmp.png')
</code></pre>
<!-- end verbatim block -->

<p>
This program was written to investigate the spreading of a flu at the
mentioned boarding school, and the reasoning for the specific choices
\( \beta \) and \( \gamma \) goes as follows. At some other school where the
disease has already spread, it was observed that in the beginning of a
day there were 40 susceptibles and 8 infected, while the numbers were
30 and 18, respectively, 24 hours later. Using 1 h as time unit, we
then have from <a href="#mjx-eqn-39">(39)</a> that \( \beta = 10/(40\cdot
8\cdot 24) \).  Among 15 infected, it was observed that 3 recovered
during a day, giving \( \gamma = 3/(15\cdot 24) \). Applying these
parameters to a new case where there is one infected initially and 50
susceptibles, gives the graphs in Figure <a href="#sec:de:flu:fig1">28</a>. These
graphs are just straight lines between the values at times
\( t_i=i\Delta t \) as computed by the program. We observe that \( S \)
reduces as \( I \) and \( R \) grows. After about 30 days everyone has become
ill and recovered again.

<p>
<center> <!-- figure label: --> <div id="sec:de:flu:fig1"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 28:  Natural evolution of a flu at a boarding school.  <!-- caption label: sec:de:flu:fig1 --> </p></center>
<p><img src="figs/SIR1.png" align="bottom" width=600></p>
</center>

<p>
We can experiment with \( \beta \) and \( \gamma \) to see whether we get an
outbreak of the disease or not. Imagine that a &quot;wash your hands&quot;
campaign was successful and that the other school in this case
experienced a reduction of \( \beta \) by a factor of 5. With this lower
\( \beta \) the disease spreads very slowly so we simulate for 60
days. The curves appear in Figure <a href="#sec:de:flu:fig2">29</a>.

<p>
<center> <!-- figure label: --> <div id="sec:de:flu:fig2"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 29:  Small outbreak of a flu at a boarding school (\( \beta \) is much smaller than in Figure <a href="#sec:de:flu:fig1">28</a>).  <!-- caption label: sec:de:flu:fig2 --> </p></center>
<p><img src="figs/SIR1b.png" align="bottom" width=600></p>
</center>

<h2 id="___sec151">Outbreak or not </h2>

<p>
Looking at the equation for \( I \), it is clear that we must have \( \beta
SI - \gamma I>0 \) for \( I \) to increase. When we start the simulation it
means that

$$ \beta S(0)I(0) - \gamma I(0)>0,
$$

or simpler

$$
\begin{equation}
\frac{\beta S(0)}{\gamma} > 1
\tag{57}
\end{equation}
$$

to increase the number of infected people and accelerate the spreading
of the disease. You can run the <code>SIR1.py</code> program with a smaller \( \beta \)
such that <a href="#mjx-eqn-57">(57)</a> is violated and observe that there is
no outbreak.

<p>
<div class="alert alert-block alert-notice alert-text-normal">
<b>The power of mathematical modeling.</b>
<p>
The reader should notice our careful use of words in the previous
paragraphs. We started out with modeling a very specific case, namely
the spreading of a flu among pupils and staff at a boarding school.
With purpose we exchanged words like pupils and flu with more neutral
and general words like <em>individuals</em> and <em>disease</em>,
respectively. Phrased equivalently, we raised the abstraction level by
moving from a specific case (flu at a boarding school) to a more
general case (disease in a closed society).  Very often, when
developing mathematical models, we start with a specific example and
see, through the modeling, that what is going on of essence in this
example also will take place in many similar problem settings.  We try
to incorporate this generalization in the model so that the model has
a much wider application area than what we aimed at in the
beginning. This is the very power of mathematical modeling: by solving
one specific case we have often developed more generic tools that can
readily be applied to solve seemingly different problems.  The next
sections will give substance to this assertion.
</div>


<h2 id="sec:de:flu:generic">Abstract problem and notation</h2>

<p>
When we had a specific differential equation with one unknown, we quickly
turned to an abstract differential equation written in the generic
form \( u'=f(u,t) \). We refer to such a problem as a <em>scalar ODE</em>.
A specific equation corresponds to a specific
choice of the formula \( f(u,t) \) involving \( u \) and (optionally) \( t \).

<p>
It is advantageous to also write a system of differential equations
in the same abstract notation,

$$ u'=f(u,t),$$

but this time it is understood
that \( u \) is a vector of functions and \( f \) is also vector.
We say that \( u'=f(u,t) \) is a <em>vector ODE</em> or <em>system of ODEs</em> in this case.
For the SIR model we introduce the two 3-vectors, one for the unknowns,

$$ u = (S(t), I(t), R(t)),$$

and one for the right-hand side functions,

$$ f(u,t) = (-\beta SI, \beta SI -\gamma I, \gamma I)\thinspace .$$

The equation \( u'=f(u,t) \) means setting the two vectors equal, i.e.,
each component must be equal. Since \( u'=(S', I', R') \), we get that
\( u'=f \) implies

$$
\begin{align*}
S' &= -\beta SI,\\ 
I' &= \beta SI - \gamma I,\\ 
R' &= \gamma I\thinspace .
\end{align*}
$$

The generalized short notation \( u'=f(u,t) \) is very handy since we can
derive numerical methods and implement software for this abstract system
and in a particular application just identify the formulas in the \( f \) vector,
implement these, and call functionality that solves the differential
equation system.

<h2 id="sec:de:flu:prog:generic">Programming the numerical method; the general case</h2>

<p>
In Python code, the Forward Euler step

$$ u^{n+1} = u^n + \Delta t f(u^n, t_n),$$

being a scalar or a vector equation,
can be coded as

<p>
<!-- begin verbatim block  pycod-->
<pre><code>u[n+1] = u[n] + dt*f(u[n], t[n])
</code></pre>
<!-- end verbatim block -->
both in the scalar and vector case. In the vector case,
<code>u[n]</code> is a one-dimensional <code>numpy</code> array of length \( m+1 \)
holding the mathematical quantity
\( u^n \), and the Python function <code>f</code> must return a <code>numpy</code> array
of length \( m+1 \). Then the expression <code>u[n] + dt*f(u[n], t[n])</code>
is an array plus a scalar times an array.

<p>
For all this to work, the complete numerical solution must be represented by a
two-dimensional array, created by <code>u = zeros((N_t+1, m+1))</code>.
The first index counts the time points and the second the components
of the solution vector at one time point.
That is, <code>u[n,i]</code> corresponds
to the mathematical quantity \( u^n_i \). When we use only one index,
as in <code>u[n]</code>, this is the same as <code>u[n,:]</code> and
picks out all the components in the solution at the time point with index
<code>n</code>. Then the assignment <code>u[n+1] = ...</code> becomes correct because it is
actually an in-place assignment <code>u[n+1, :] = ...</code>.
The nice feature of these facts is that the same piece of
Python code works for both a scalar ODE and a system of ODEs!

<p>
The <code>ode_FE</code> function for the vector ODE is placed in the file
<a href="https://github.com/hplgit/prog4comp/tree/master/src/py/ode_system_FE.py" target="_self"><tt>ode_system_FE.py</tt></a>
and was written as follows:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>from numpy import linspace, zeros, asarray
import matplotlib.pyplot as plt

def ode_FE(f, U_0, dt, T):
    N_t = int(round(float(T)/dt))
    # Ensure that any list/tuple returned from f_ is wrapped as array
    f_ = lambda u, t: asarray(f(u, t))
    u = zeros((N_t+1, len(U_0)))
    t = linspace(0, N_t*dt, len(u))
    u[0] = U_0
    for n in range(N_t):
        u[n+1] = u[n] + dt*f_(u[n], t[n])
    return u, t
</code></pre>
<!-- end verbatim block -->

<p>
The line <code>f_ = lambda ...</code> needs an explanation. For a user, who just
needs to define the \( f \) in the ODE system, it is convenient to insert the
various mathematical expressions on the right-hand sides in a list and
return that list.  Obviously, we could demand the user to convert the
list to a <code>numpy</code> array, but it is so easy to do a general such
conversion in the <code>ode_FE</code> function as well.  To make sure that the
result from <code>f</code> is indeed an array that can be used for array
computing in the formula <code>u[n] + dt*f(u[n], t[n])</code>, we introduce a new
function <code>f_</code> that calls the user's <code>f</code> and sends the results through
the <code>numpy</code> function <code>asarray</code>, which ensures that its argument is
converted to a <code>numpy</code> array (if it is not already an array).

<p>
Note also the extra parenthesis required when calling <code>zeros</code> with two indices.

<p>
Let us show how the previous SIR model can be solved using the new
general <code>ode_FE</code> that can solve <em>any</em> vector ODE. The user's <code>f(u, t)</code>
function takes a vector <code>u</code>, with three components corresponding to
\( S \), \( I \), and \( R \) as argument, along with the current time point <code>t[n]</code>,
and must return the values of the formulas of the right-hand sides
in the vector ODE. An appropriate implementation is

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(u, t):
    S, I, R = u
    return [-beta*S*I, beta*S*I - gamma*I, gamma*I]
</code></pre>
<!-- end verbatim block -->
Note that the <code>S</code>, <code>I</code>, and <code>R</code> values correspond to \( S^n \), \( I^n \), and \( R^n \).
These values are then just inserted in the various formulas
in the vector ODE. Here we collect the values in a list since the
<code>ode_FE</code> function will anyway wrap this list in an array. We could,
of course, returned an array instead:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def f(u, t):
    S, I, R = u
    return array([-beta*S*I, beta*S*I - gamma*I, gamma*I])
</code></pre>
<!-- end verbatim block -->
The list version looks a bit nicer, so that is why we prefer
a list and rather introduce <code>f_ = lambda u, t: asarray(f(u,t))</code>
in the general <code>ode_FE</code> function.

<p>
We can now show a function that runs the previous SIR example,
while using the generic <code>ode_FE</code> function:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def demo_SIR():
    &quot;&quot;&quot;Test case using a SIR model.&quot;&quot;&quot;
    def f(u, t):
        S, I, R = u
        return [-beta*S*I, beta*S*I - gamma*I, gamma*I]

    beta = 10./(40*8*24)
    gamma = 3./(15*24)
    dt = 0.1             # 6 min
    D = 30               # Simulate for D days
    N_t = int(D*24/dt)   # Corresponding no of hours
    T = dt*N_t           # End time
    U_0 = [50, 1, 0]

    u, t = ode_FE(f, U_0, dt, T)

    S = u[:,0]
    I = u[:,1]
    R = u[:,2]
    fig = plt.figure()
    l1, l2, l3 = plt.plot(t, S, t, I, t, R)
    fig.legend((l1, l2, l3), ('S', 'I', 'R'), 'lower right')
    plt.xlabel('hours')
    plt.show()

    # Consistency check:
    N = S[0] + I[0] + R[0]
    eps = 1E-12  # Tolerance for comparing real numbers
    for n in range(len(S)):
        SIR_sum = S[n] + I[n] + R[n]
        if abs(SIR_sum - N) &gt; eps:
            print '*** consistency check failed: S+I+R=%g != %g' %\ 
                  (SIR_sum, N)

if __name__ == '__main__':
    demo_SIR()
</code></pre>
<!-- end verbatim block -->
Recall that the <code>u</code> returned from <code>ode_FE</code> contains all components
(\( S \), \( I \), \( R \)) in the solution vector at all time points. We
therefore need to extract the \( S \), \( I \), and \( R \) values in separate
arrays for further analysis and easy plotting.

<p>
Another key feature of this higher-quality code is the consistency
check. By adding the three differential equations in the SIR
model, we realize that \( S' + I' + R'=0 \), which means that
\( S+I+R=\mbox{const} \). We can check that this relation holds
by comparing \( S^n+I^n+R^n \) to the sum of the initial conditions.
The check is not a full-fledged
verification, but it is a much better than doing nothing and hoping
that the computation is correct.
<a href="._p4c-solarized-Python023.html#sec:de:exer:SIR:dtopt">Exercise 48: Find an appropriate time step; SIR model</a> suggests another method for
controlling the quality of the numerical solution.

<h2 id="___sec154">Time-restricted immunity </h2>

<p>
Let us now assume that immunity after the disease
only lasts for some certain time period. This means that there is
transport from the R state to the S state:

<p>
<br />
<br />

<p>
<center><p><img src="figs/categories_SIR_feedback.png" align="bottom" width=400></p></center>

<p>
<br />
<br />

<p>
Modeling the loss of immunity
is very similar to modeling recovery from the disease: the
amount of people losing immunity is proportional to the amount
of recovered patients and the length of the time interval \( \Delta t \).
We can therefore write the loss in the R category as
\( -\nu\Delta t R \) in time \( \Delta t \), where \( \nu^{-1} \) is the
typical time it takes to lose immunity. The loss in \( R(t) \)
is a gain in \( S(t) \). The &quot;budgets&quot; for the categories
therefore become

$$
\begin{align}
S^{n+1} &= S^n -\beta\Delta tS^nI^n + \nu\Delta t R^n,
\tag{58}\\ 
I^{n+1} &= I^n + \beta\Delta tS^nI^n - \gamma\Delta t I^n,
\tag{59}\\ 
R^{n+1} &= R^n + \gamma\Delta t I^n - \nu\Delta t R^n\thinspace .
\tag{60}
\end{align}
$$

Dividing by \( \Delta t \) and letting \( \Delta t\rightarrow 0 \) gives
the differential equation system

$$
\begin{align}
S' &= -\beta SI + \nu R,
\tag{61}\\ 
I' &= \beta SI - \gamma I,
\tag{62}\\ 
R' &= \gamma I - \nu R\thinspace .
\tag{63}
\end{align}
$$

This system can be solved by the same methods as we demonstrated for
the original SIR model. Only one modification in the program is
necessary: adding <code>nu*R[n]</code> to the <code>S[n+1]</code> update and subtracting
the same quantity in the <code>R[n+1]</code> update:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>for n in range(N_t):
    S[n+1] = S[n] - dt*beta*S[n]*I[n] + dt*nu*R[n]
    I[n+1] = I[n] + dt*beta*S[n]*I[n] - dt*gamma*I[n]
    R[n+1] = R[n] + dt*gamma*I[n] - dt*nu*R[n]
</code></pre>
<!-- end verbatim block -->
The modified code is found in the file <code>SIR2.py</code>.

<p>
Setting \( \nu^{-1} \) to 50 days, reducing \( \beta \) by a factor of 4 compared
to the previous example (\( \beta=0.00033 \)),
and simulating for 300 days gives an oscillatory
behavior in the categories, as depicted in Figure <a href="#sec:de:flu:fig3">30</a>.
It is easy now to play around and study how the parameters affect the
spreading of the disease.
For example,
making the disease slightly more effective (increase \( \beta \) to 0.00043)
and increasing the average time to loss of immunity to 90 days lead
to other oscillations in Figure <a href="#sec:de:flu:fig4">31</a>.

<p>
<center> <!-- figure label: --> <div id="sec:de:flu:fig3"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 30:  Including loss of immunity.  <!-- caption label: sec:de:flu:fig3 --> </p></center>
<p><img src="figs/SIR2.png" align="bottom" width=600></p>
</center>

<p>
<center> <!-- figure label: --> <div id="sec:de:flu:fig4"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 31:  Increasing \( \beta \) and reducing \( \nu \) compared to Figure <a href="#sec:de:flu:fig3">30</a>.  <!-- caption label: sec:de:flu:fig4 --> </p></center>
<p><img src="figs/SIR2b.png" align="bottom" width=600></p>
</center>

<h2 id="sec:de:flu:vaccine">Incorporating vaccination</h2>

<p>
We can extend the model to also include vaccination. To this end, it can
be useful to track those who are vaccinated and those who are not. So, we introduce
a fourth category, V, for those who have taken a successful
vaccination. Furthermore, we assume that in a time interval \( \Delta t \),
a fraction \( p\Delta t \) of the S category is subject to a successful
vaccination. This means that in the time \( \Delta t \), \( p\Delta t S \) people
leave from the S to the V category. Since the vaccinated ones cannot
get the disease, there is no impact on the I or R categories. We can
visualize the categories, and the movement between them, as

<p>
<br />
<br />

<p>
<center><p><img src="figs/categories_SIRV2.png" align="bottom" width=400></p></center>

<p>
<br />
<br />

<p>
The new, extended differential equations with the \( V \) quantity become

$$
\begin{align}
S' &= -\beta SI + \nu R -pS,
\tag{64}\\ 
V' &= pS,
\tag{65}\\ 
I' &= \beta SI - \gamma I,
\tag{66}\\ 
R' &= \gamma I - \nu R\thinspace .
\tag{67}
\end{align}
$$

We shall refer to this model as the SIRV model.

<p>
The new equation for \( V' \) poses no difficulties when it comes to the
numerical method. In a Forward Euler scheme we simply add an update

$$ V^{n+1} = V^n + p \Delta t S^n\thinspace .$$

The program needs to store \( V(t) \) in an additional array <code>V</code>,
and the plotting command must be extended with more arguments to
plot <code>V</code> versus <code>t</code> as well. The complete code is found in
the file <code>SIRV1.py</code>.

<p>
Using \( p=0.0005 \) and \( p=0.0001 \) as values for the vaccine efficiency parameter,
the effect of vaccination is seen in Figure <a href="#sec:de:flu:fig5">32</a>
(other parameters are as in Figure <a href="#sec:de:flu:fig3">30</a>).

<p>
<center> <!-- figure label: --> <div id="sec:de:flu:fig5"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 32:  The effect of vaccination: \( p=0005 \) (left) and \( p=0.0001 \) (right).  <!-- caption label: sec:de:flu:fig5 --> </p></center>
<p><img src="figs/SIRV1.png" align="bottom" width=600></p>
</center>

<h2 id="sec:de:flu:vaccine:discont">Discontinuous coefficients: a vaccination campaign</h2>

<p>
What about modeling a vaccination campaign? Imagine that six days
after the outbreak of the disease, the local
health station launches a vaccination campaign. They reach out
to many people, say 10 times as efficiently as in the previous
(constant vaccination) case. If the campaign lasts for 10 days
we can write

$$
\begin{equation*} p(t) = \left\lbrace\begin{array}{ll}
0.005,& 6\cdot 24\leq t\leq 15\cdot 24,\\ 
0,& \hbox{otherwise} \end{array}\right.\end{equation*}
$$

Note that we must multiply the \( t \) value by 24 because \( t \) is measured
in hours, not days.
In the differential equation system, \( pS(t) \) must be replaced by
\( p(t)S(t) \), and in this case we get a differential equation system
with a term that is <em>discontinuous</em>. This is usually quite a challenge
in mathematics, but as long as we solve the equations numerically
in a program, a discontinuous coefficient is easy to treat.

<p>
There are two ways to implement the discontinuous coefficient \( p(t) \):
through a function and through an array. The function approach is
perhaps the easiest:

<p>
<!-- begin verbatim block  pycod-->
<pre><code>def p(t):
    return 0.005 if (6*24 &lt;= t &lt;= 15*24) else 0
</code></pre>
<!-- end verbatim block -->
In the code for updating the arrays <code>S</code> and <code>V</code> we get a term
<code>p(t[n])*S[n]</code>.

<p>
We can also let \( p(t) \) be an array filled with correct values prior
to the simulation. Then we need to allocate an array <code>p</code> of length <code>N_t+1</code>
and find the indices corresponding to the time period between 6 and 15
days. These indices are found from the time point divided by
\( \Delta t \). That is,

<p>
<!-- begin verbatim block  pycod-->
<pre><code>p = zeros(N_t+1)
start_index = 6*24/dt
stop_index = 15*24/dt
p[start_index:stop_index] = 0.005
</code></pre>
<!-- end verbatim block -->
The \( p(t)S(t) \) term in the updating formulas for \( S \) and \( V \) simply becomes
<code>p[n]*S[n]</code>. The file <code>SIRV2.py</code>
contains a program based on filling an array <code>p</code>.

<p>
The effect of a vaccination campaign is illustrated in Figure
<a href="#sec:de:flu:fig6">33</a>. All the data are as in Figure <a href="#sec:de:flu:fig5">32</a> (left),
except that \( p \) is ten times stronger for a period of 10 days and
\( p=0 \) elsewhere.

<p>
<center> <!-- figure label: --> <div id="sec:de:flu:fig6"></div> <!-- FIGURE -->
<hr class="figure">
<center><p class="caption">Figure 33:  The effect of a vaccination campaign.  <!-- caption label: sec:de:flu:fig6 --> </p></center>
<p><img src="figs/SIRV2.png" align="bottom" width=600></p>
</center>

<p>
<p>
<!-- begin bottom navigation -->
<table style="width: 100%"><tr><td>
<div style="text-align: left;"><a href="._p4c-solarized-Python020.html">&laquo; Previous</a></div>
</td><td>
<div style="text-align: right;"><a href="._p4c-solarized-Python022.html">Next &raquo;</a></div>
</td></tr></table>
<!-- end bottom navigation -->
</p>

<!-- ------------------- end of main content --------------- -->


</body>
</html>
    

